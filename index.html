<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS Developer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Talk is cheap， show me the code. 用心创造美好未来">
<meta property="og:type" content="website">
<meta property="og:title" content="iOS Developer">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="iOS Developer">
<meta property="og:description" content="Talk is cheap， show me the code. 用心创造美好未来">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS Developer">
<meta name="twitter:description" content="Talk is cheap， show me the code. 用心创造美好未来">
  
    <link rel="alternate" href="/atom.xml" title="iOS Developer" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">iOS Developer</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello World</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS推送机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/25/iOS推送机制/" class="article-date">
  <time datetime="2017-04-25T12:38:00.000Z" itemprop="datePublished">2017-04-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/25/iOS推送机制/">iOS推送机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    <strong>Push Notification是如何工作的？</strong></p>
<ul>
<li>推送通知分为两种,一个是本地推送,一个是远程推送</li>
<li>本地推送：不需要联网也可以推送,是开发人员在App内设定特定的时间来提醒用户干什么</li>
<li>远程推送：需要联网,用户的设备会于苹果APNS服务器形成一个长连接,用户设备会发送UUID 和Bundle idenidentifier给苹果服务器,苹果服务器会加密生成一个deviceToken返回给用户设备,然后设备会将deviceToken发送给APP的服务器,服务器会将deviceToken存进他们的数据库,这时候如果有人发送消息给我,服务器端就会去查询我的deviceToken,然后将deviceToken和要发送的信息发送给苹果服务器,苹果服务器通过deviceToken找到我的设备并将消息推送到我的设备上,这里还有个情况是如果App在线,那么App服务器会于App产生一个长连接,这时候App服务器会直接通过deviceToken将消息 msg 推送到设备上。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/25/iOS推送机制/" data-id="cj46tfgxq0013o3s68bcam32w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ios应用程序的生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/21/ios应用程序的生命周期/" class="article-date">
  <time datetime="2017-03-21T05:51:18.000Z" itemprop="datePublished">2017-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ios/">ios</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/21/ios应用程序的生命周期/"> ios应用程序的生命周期</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    每一个程序在运行期必须有且仅有一个 UIApplication（或则其子类）的一个实例。在程序开始运行的时候，UIApplicationMain 函数是程序进入点，这个函数做了很多工作，其中一个重要的工作就是创建一个 UIApplication 的单例实例。在你的代码中你，你可以通过调用 <code>[UIApplication sharedApplication]</code> 来得到这个单例实例的指针。</p>
<p>​    UIApplication 的一个主要工作是处理用户事件，它会起一个队列，把所有用户事件都放入队列，逐个处理，在处理的时候，它会发送当前事件 到一个合适的处理事件的目标控件。此外，UIApplication 实例还维护一个在本应用中打开的 window 列表（UIWindow 实例），这样它就 可以接触应用中的任何一个 UIView 对象。UIApplication 实例会被赋予一个代理对象，以处理应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警告）等等。</p>
<h2 id="UIApplicaion-生命周期"><a href="#UIApplicaion-生命周期" class="headerlink" title="UIApplicaion 生命周期"></a>UIApplicaion 生命周期</h2><p>一个 UIApplication 可以有如下几种状态：</p>
<ul>
<li><code>Not running（未运行）</code></li>
<li><code>Inactive（未激活）</code></li>
<li><code>Active（激活）</code></li>
<li><code>Background（后台）</code> </li>
<li><code>Suspended（挂起）</code></li>
</ul>
<p>常见的代理方法有:</p>
<ol>
<li><p><code>-(void)applicationWillResignActive:(UIApplication *)application</code></p>
<p>说明：当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</p>
</li>
<li><p><code>-(void)applicationDidBecomeActive:(UIApplication *)application</code></p>
<p>说明：当应用程序入活动状态执行，这个刚好跟上面那个方法相反</p>
</li>
<li><p><code>-(void)applicationDidEnterBackground:(UIApplication *)application</code></p>
<p>说明：当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</p>
</li>
<li><p><code>-(void)applicationWillEnterForeground:(UIApplication *)application</code></p>
<p>说明：当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</p>
</li>
<li><p><code>-(void)applicationWillTerminate:(UIApplication *)application</code></p>
<p>说明：当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要设置 UIApplicationExitsOnSuspend 的键值。</p>
</li>
<li><p><code>-(void)applicationDidReceiveMemoryWarning:(UIApplication *)application</code></p>
<p>说明：iPhone 设备只有有限的内存，如果为应用程序分配了太多内存操作系统会终止应用程序的运行，在终止前会执行这个方法，通常可以在这里进行内存清理工作防止程序被终止</p>
</li>
<li><p><code>-(void)applicationSignificantTimeChange:(UIApplication*)application</code></p>
<p>说明：当系统时间发生改变时执行</p>
</li>
<li><p><code>-(void)applicationDidFinishLaunching:(UIApplication*)application</code></p>
<p>说明：当程序载入后执行</p>
</li>
</ol>
<p>下面是一个用于展示整个 App 生命周期的示意图：</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcly1fduexdc18mj30fz0lqdhd.jpg" alt=""></p>
<p>这一张来自 Twitter 的图片，对于理解 iOS App 的生命周期起到了非常大的作用！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/21/ios应用程序的生命周期/" data-id="cj46tfgy3001do3s63t29az7u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OC内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/20/OC内存管理/" class="article-date">
  <time datetime="2017-03-20T09:47:39.000Z" itemprop="datePublished">2017-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/20/OC内存管理/">OC内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Objective-C-中的内存分配"><a href="#Objective-C-中的内存分配" class="headerlink" title="Objective-C 中的内存分配"></a>Objective-C 中的内存分配</h2><p>在 Objective-C 中，对象通常是使用 <code>alloc</code> 方法在堆上创建的。 <code>[NSObject alloc]</code> 方法会在对堆上分配一块内存，按照<code>NSObject</code>的内部结构填充这块儿内存区域。</p>
<p>一旦对象创建完成，就不可能再移动它了。因为很可能有很多指针都指向这个对象，这些指针并没有被追踪。因此没有办法在移动对象的位置之后更新全部的这些指针。</p>
<h2 id="MRC-与-ARC"><a href="#MRC-与-ARC" class="headerlink" title="MRC 与 ARC"></a>MRC 与 ARC</h2><p>Objective-C中提供了两种内存管理机制：MRC（MannulReference Counting）和 ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。现在苹果推荐使用 ARC 来进行内存管理。</p>
<h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><h4 id="对象操作的四个类别"><a href="#对象操作的四个类别" class="headerlink" title="对象操作的四个类别"></a>对象操作的四个类别</h4><table>
<thead>
<tr>
<th>对象操作</th>
<th>OC中对应的方法</th>
<th>对应的 retainCount 变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy等</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ul>
<li><del>这些对象操作的方法其实并不包括在OC中，而是包含在Cocoa框架下的Foundation框架中。</del><a href="https://developer.apple.com/library/content/releasenotes/General/iOS70APIDiffs/index.html" target="_blank" rel="external">从 iOS 7 开始</a>，这些方法被移动到了 Runtime 当中，可以在 <a href="http://opensource.apple.com/source/objc4/objc4-680/runtime/NSObject.h" target="_blank" rel="external">objc4-680 NSObject.h</a> 找到。</li>
<li>对象的 <code>reatinCount</code> 属性并没有实际上的参考价值，参考苹果官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html" target="_blank" rel="external">《Practical Memory Management》</a>.</li>
</ul>
<h4 id="四个法则"><a href="#四个法则" class="headerlink" title="四个法则"></a>四个法则</h4><ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不在需要自己持有对象的时候，释放。</li>
<li>非自己持有的对象无需释放。</li>
</ul>
<p>如下是四个黄金法则对应的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 自己生成并持有该对象</div><div class="line"> */</div><div class="line"> id obj0 = [[NSObeject alloc] init];</div><div class="line"> id obj1 = [NSObeject new];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 持有非自己生成的对象</div><div class="line"> */</div><div class="line">id obj = [NSArray array]; // 非自己生成的对象，且该对象存在，但自己不持有</div><div class="line">[obj retain]; // 自己持有对象</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 不在需要自己持有的对象的时候，释放</div><div class="line"> */</div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObeject</span> alloc] init]; <span class="comment">// 此时持有对象</span></div><div class="line">[obj release]; <span class="comment">// 释放对象</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 指向对象的指针仍就被保留在obj这个变量中</div><div class="line"> * 但对象已经释放，不可访问</div><div class="line"> */</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 非自己持有的对象无法释放</div><div class="line"> */</div><div class="line">id obj = [NSArray array]; // 非自己生成的对象，且该对象存在，但自己不持有</div><div class="line">[obj release]; // ~~~此时将运行时crash 或编译器报error~~~ 非 ARC 下，调用该方法会导致编译器报 issues。此操作的行为是未定义的，可能会导致运行时 crash 或者其它未知行为</div></pre></td></tr></table></figure>
<p>其中 <code>非自己生成的对象，且该对象存在，但自己不持有</code> 这个特性是使用<code>autorelease</code>来实现的，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (id) getAObjNotRetain &#123;</div><div class="line">    id obj = [[NSObject alloc] init]; // 自己持有对象</div><div class="line">    [obj autorelease]; // 取得的对象存在，但自己不持有该对象</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>autorelease</code> 使得对象在超出生命周期后能正确的被释放(通过调用release方法)。在调用 <code>release</code> 后，对象会被立即释放，而调用 <code>autorelease</code> 后，对象不会被立即释放，而是注册到 <code>autoreleasepool</code> 中，经过一段时间后 <code>pool</code>结束，此时调用release方法，对象被释放。</p>
<p>在MRC的内存管理模式下，与对变量的管理相关的方法有：retain, release 和 autorelease。retain 和 release 方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用 NSAutoreleasePool 对象，对加入自动释放池（autorelease 调用）的变量进行管理，当 drain 时回收内存。</p>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p>ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化。</p>
<h4 id="变量标识符"><a href="#变量标识符" class="headerlink" title="变量标识符"></a>变量标识符</h4><p>在ARC中与内存管理有关的变量标识符，有下面几种：</p>
<ul>
<li><code>__strong</code></li>
<li><code>__weak</code></li>
<li><code>__unsafe_unretained</code></li>
<li><code>__autoreleasing</code></li>
</ul>
<p><code>__strong</code> 是默认使用的标识符。只要还有一个强指针指向某个对象，这个对象就会一直存活。</p>
<p><code>__weak</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，弱引用会被置为 nil</p>
<p><code>__unsafe_unretained</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会被置为 nil。如果它引用的对象被回收掉了，该指针就变成了野指针。</p>
<p><code>__autoreleasing</code> 用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉。</p>
<p>变量标识符的用法如下：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>* __strong num = [[<span class="built_in">Number</span> alloc] init]<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>注意 <code>__strong</code> 的位置应该放到 <code>*</code> 和变量名中间，放到其他的位置严格意义上说是不正确的，只不过编译器不会报错。</p>
<h4 id="属性标识符"><a href="#属性标识符" class="headerlink" title="属性标识符"></a>属性标识符</h4><p>类中的属性也可以加上标志符：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>/<span class="keyword">retain</span>/<span class="keyword">strong</span>/<span class="keyword">weak</span>/<span class="keyword">unsafe_unretained</span>/<span class="keyword">copy</span>) Number* num</div></pre></td></tr></table></figure>
<p><code>assign</code>表明 setter 仅仅是一个简单的赋值操作，通常用于基本的数值类型，例如<code>CGFloat</code>和<code>NSInteger</code>。</p>
<p><code>strong</code> 表明属性定义一个拥有者关系。当给属性设定一个新值的时候，首先这个值进行 <code>retain</code> ，旧值进行 <code>release</code> ，然后进行赋值操作。</p>
<p><code>weak</code> 表明属性定义了一个非拥有者关系。当给属性设定一个新值的时候，这个值不会进行 <code>retain</code>，旧值也不会进行 <code>release</code>， 而是进行类似 <code>assign</code> 的操作。不过当属性指向的对象被销毁时，该属性会被置为nil。</p>
<p><code>unsafe_unretained</code> 的语义和 <code>assign</code> 类似，不过是用于对象类型的，表示一个非拥有(unretained)的，同时也不会在对象被销毁时置为nil的(unsafe)关系。</p>
<p><code>copy</code> 类似于 <code>strong</code>，不过在赋值时进行 <code>copy</code> 操作而不是 <code>retain</code> 操作。通常在需要保留某个不可变对象（NSString最常见），并且防止它被意外改变时使用。</p>
<h5 id="错误使用属性标识符的后果"><a href="#错误使用属性标识符的后果" class="headerlink" title="错误使用属性标识符的后果"></a>错误使用属性标识符的后果</h5><p>如果我们给一个原始类型设置 <code>strong\weak\copy</code> ，编译器会直接报错：</p>
<blockquote>
<p>Property with ‘retain (or strong)’ attribute must be of object type</p>
</blockquote>
<p>设置为 <code>unsafe_unretained</code> 倒是可以通过编译，只是用起来跟 <code>assign</code> 也没有什么区别。</p>
<p>反过来，我们给一个 NSObject 属性设置为 assign，编译器会报警：</p>
<blockquote>
<p>Assigning retained object to unsafe property; object will be released after assignment</p>
</blockquote>
<p>正如警告所说的，对象在赋值之后被立即释放，对应的属性也就成了野指针，运行时跑到属性有关操作会直接崩溃掉。和设置成 <code>unsafe_unretained</code> 是一样的效果（设置成 <code>weak</code> 不会崩溃）。</p>
<h5 id="unsafe-unretained-的用处"><a href="#unsafe-unretained-的用处" class="headerlink" title="unsafe_unretained 的用处"></a><code>unsafe_unretained</code> 的用处</h5><p><code>unsafe_unretained</code> 差不多是实际使用最少的一个标识符了，在使用中它的用处主要有下面几点：</p>
<ol>
<li>兼容性考虑。iOS4 以及之前还没有引入 <code>weak</code>，这种情况想表达弱引用的语义只能使用 <code>unsafe_unretained</code>。这种情况现在已经很少见了。</li>
<li>性能考虑。使用 <code>weak</code> 对性能有一些影响，因此对性能要求高的地方可以考虑使用 <code>unsafe_unretained</code> 替换 <code>weak</code>。一个例子是 <a href="https://github.com/ibireme/YYModel/blob/master/YYModel/NSObject%2BYYModel.m" target="_blank" rel="external">YYModel 的实现</a>，为了追求更高的性能，其中大量使用 <code>unsafe_unretained</code> 作为变量标识符。</li>
</ol>
<h4 id="main-m-中-Autorelease-Pool-的解释"><a href="#main-m-中-Autorelease-Pool-的解释" class="headerlink" title="main.m 中 Autorelease Pool 的解释"></a>main.m 中 Autorelease Pool 的解释</h4><p>大家都知道在 iOS 程序的 main.m 文件中有类似这样的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，这里的 pool 有什么作用，能不能去掉呢？在这里我们分析一下：</p>
<p>根据<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIKitFunctionReference/index.html#//apple_ref/c/func/UIApplicationMain" target="_blank" rel="external">苹果官方文档</a>， UIApplicationMain 函数是整个 app 的入口，用来创建 application 对象（单例）和 application delegate。尽管这个函数有返回值，但是实际上却永远不会返回，当按下 Home 键时，app 只是被切换到了后台状态。</p>
<p>同时参考苹果关于 Lifecycle 的<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html" target="_blank" rel="external">官方文档</a>，UIApplication 自己会创建一个 main run loop，我们大致可以得到下面的结论：</p>
<ol>
<li>main.m 中的 UIApplicationMain 永远不会返回，只有在系统 kill 掉整个 app 时，系统会把应用占用的内存全部释放出来。</li>
<li>因为(1)， UIApplicationMain 永远不会返回，这里的 autorelease pool 也就永远不会进入到释放那个阶段</li>
<li>在 (2) 的基础上，假设有些变量真的进入了 main.m 里面这个 pool（没有被更内层的 pool 捕获），那么这些变量实际上就是被泄露的。这个 autorelease pool 等于是把这种泄露情况给隐藏起来了。</li>
<li>UIApplication 自己会创建 main run loop，在 Cocoa 的 runloop 中实际上也是自动包含 autorelease pool 的，因此 main.m 当中的 pool 可以认为是<strong>没有</strong>必要的。</li>
</ol>
<p>在基于 AppKit 框架的 Mac OS 开发中， main.m 当中就是不存在 autorelease pool 的，也进一步验证了我们得到的结论。不过因为我们看不到更底层的代码，加上苹果的文档中不建议修改 main.m ，所以我们也没有理由就直接把它删掉（亲测，删掉之后不影响 App 运行，用 Instruments 也看不到泄露）。</p>
<p>为了进一步理解 ARC 是如何做到这一点的，我们可以参考 Clang 的<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#unretained-return-values" target="_blank" rel="external">文档</a>。</p>
<p>众所周知，weak 不会持有对象，当给一个 weak 赋以一个自己生成的对象（即 retained return value）后，对象会立马被释放。</p>
<p>一个很常见的 warning 就是 Assigning retained object to weak variable, object will be released after assignment.</p>
<p>但是我们前面也提到了，可以持有非自己生成的对象，这通过 autorelease 实现。</p>
<p>那么如果一个 weak 被赋以一个非自己生成的对象（即 unretained return value）呢？代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSNumber __weak *number = [NSNumber numberWithInt:100];</div><div class="line">NSLog(@&quot;number = %@&quot;, number);</div></pre></td></tr></table></figure>
<p>这种情况下是可以正确打印值的。</p>
<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweak" target="_blank" rel="external">clang的文档</a> 是这么说的：这种情况下，weak 并不会立即释放，而是会通过 <code>objc_loadWeak</code> 这个方法注册到 AutoreleasePool 中，以延长生命周期。</p>
<p>ARC 下的临时变量是受到 Autorelease Pool 的管理的，会自动释放。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/20/OC内存管理/" data-id="cj46tfgx9000po3s6wyycius0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-3·15晚会" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/3·15晚会/" class="article-date">
  <time datetime="2017-03-19T14:46:31.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/文字/">文字</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/3·15晚会/">3·15晚会</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2017-3-15晚会播放地址：</p>
<embed id="v_player_cctv" width="620" height="520" flashvars="videoId=VIDE100215108600&filePath=&isAutoPlay=false&url=http://315.cctv.com/special/video/index.shtml&tai=news&configPath=http://js.player.cntv.cn/xml/config/outside.xml&widgetsConfig=http://js.player.cntv.cn/xml/widgetsConfig/common.xml&languageConfig=&hour24DataURL=VodCycleData.xml&outsideChannelId=channelBugu&videoCenterId=112881626d5447e4983af0dfbf6f79ab" allowscriptaccess="always" allowfullscreen="true" menu="false" quality="best" bgcolor="#030609" name="v_player_cctv" src="http://player.cntv.cn/standard/cntvOutSidePlayer.swf" type="application/x-shockwave-flash" lk_mediaid="lk_juiceapp_mediaPopup_1257416656250" lk_media="yes">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/19/3·15晚会/" data-id="cj46tfgwd0000o3s6ls6tnxdz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文字/">文字</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NSString属性什么时候用copy，什么时候用strong" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/17/NSString属性什么时候用copy，什么时候用strong/" class="article-date">
  <time datetime="2017-03-17T09:29:33.000Z" itemprop="datePublished">2017-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/17/NSString属性什么时候用copy，什么时候用strong/">NSString属性什么时候用copy，什么时候用strong?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下边我们来做个实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *strongString;</div><div class="line">@property (nonatomic, copy)   NSString *copyedString;</div><div class="line"></div><div class="line">- (void)test &#123;</div><div class="line">    </div><div class="line">#warning 第一步</div><div class="line">    NSString *string = [NSString stringWithFormat:@&quot;Chaiyh&quot;];</div><div class="line">    </div><div class="line">#warning 第二步</div><div class="line">//    NSMutableString *string = [NSMutableString stringWithFormat:@&quot;Chaiyh&quot;];</div><div class="line">    </div><div class="line">    self.strongString = string;</div><div class="line">    self.copyedString = string;</div><div class="line">    </div><div class="line">    _originLabel.text = [NSString stringWithFormat:@&quot;origin string: %p, &amp;string : %p&quot;, string, &amp;string];</div><div class="line">    _strongLabel.text = [NSString stringWithFormat:@&quot;strong string: %p, &amp;_strongString : %p&quot;, _strongString, &amp;_strongString];</div><div class="line">    _copyedLabel.text = [NSString stringWithFormat:@&quot;copy string: %p, &amp;_copyedString : %p&quot;, _copyedString, &amp;_copyedString];</div><div class="line">    </div><div class="line">    NSLog(@&quot;origin string: %p, &amp;string : %p&quot;, string, &amp;string);</div><div class="line">    NSLog(@&quot;strong string: %p, &amp;_strongString : %p&quot;, _strongString, &amp;_strongString);</div><div class="line">    NSLog(@&quot;copy string: %p, &amp;_copyedString : %p&quot;, _copyedString, &amp;_copyedString);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>ARC 下,其输出结果为⤵️：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcly1fdpzrxkjkkj31120kuq38.jpg" alt=""></p>
<p>ARC 下，我们可以看到，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string指向的地址。</p>
<p>如果我们换作MRC环境，打印string的引用计数的话，会看到其引用计数值是3，即strong操作和copy操作都使原字符串对象的引用计数值加了1。</p>
<h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>我们把string由不可变改为可变对象，看看会是什么结果。即将下面这一句</p>
<blockquote>
<p>NSString *string = [NSString stringWithFormat:@”Chaiyh”];</p>
</blockquote>
<p>改成：</p>
<blockquote>
<p>NSMutableString *string = [NSMutableString stringWithFormat:@”Chaiyh”];</p>
</blockquote>
<p>输出结果是：</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcly1fdpztwitdlj31120kuweq.jpg" alt=""></p>
<p>可以发现，此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让_copyedString对象指向这个字符串。在MRC环境下，打印两者的引用计数，可以看到string对象的引用计数是2，而_copyedString对象的引用计数是1。</p>
<p>此时，我们如果去修改string字符串的话，可以看到：因为_strongString与string是指向同一对象，所以_strongString的值也会跟随着改变(需要注意的是，此时_strongString的类型实际上是NSMutableString，而不是NSString)；而_copyedString是指向另一个对象的，所以并不会改变。</p>
<h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>​    1、由于NSMutableString是NSString的子类，所以一个NSString指针可以指向NSMutableString对象，让我们的strongString指针指向一个可变字符串是OK的。</p>
<p>​    而上面的例子可以看出，当源字符串是NSString时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。</p>
<p>​    2、当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。</p>
<p>​    这里还有一个性能问题，即在源字符串是NSMutableString时候，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是NSString时，则没有这个问题。</p>
<p>所以，在声明NSString属性时，到底是选择strong还是copy，可以根据实际情况来定。不过，一般我们将对象声明为NSString时，都不希望它改变，所以大多数情况下，我们建议用copy，以免因可变字符串的修改导致的一些非预期问题。</p>
<p><a href="https://github.com/Chaiyahang/TestStringPropertyDemo.git" target="_blank" rel="external">Demo下载地址</a></p>
<p>运行 Demo 后，请横屏看结果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/17/NSString属性什么时候用copy，什么时候用strong/" data-id="cj46tfgx4000jo3s63p5vfmy3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络知识点儿" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/网络知识点儿/" class="article-date">
  <time datetime="2017-03-16T02:05:12.000Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络/">网络</a>►<a class="article-category-link" href="/categories/网络/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/网络知识点儿/">网络知识点儿</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcly1fdohe7nscfj30fb051aa3.jpg" alt="http请求-响应模型.jpg"></p>
<h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><ul>
<li>HTTP构建于TCP/IP协议之上，默认端口号是80</li>
<li>HTTP是<strong>无连接无状态</strong>的</li>
</ul>
<h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。</p>
<p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>。<code>URL</code>全称是资源描述符，我们可以这样认为：一个<code>URL</code>地址，它用于描述一个网络上的资源，而 HTTP 中的<code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>就对应着对这个资源的查，增，改，删4个操作。</p>
<p>1、GET用于信息获取，而且应该是安全的 和 幂等的。</p>
<p>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p>
<p>幂等的意味着对同一URL的多个请求应该返回同样的结果。</p>
<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。</p>
<p>2、POST表示可能修改变服务器上的资源的请求。</p>
<p>3、注意:</p>
<ul>
<li>GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制</li>
<li>理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制</li>
</ul>
<h3 id="条件-GET"><a href="#条件-GET" class="headerlink" title="条件 GET"></a>条件 GET</h3><p>HTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。</p>
<ol>
<li><p>HTTP 条件 GET 使用的时机？</p>
<p>客户端之前已经访问过某网站，并打算再次访问该网站。</p>
</li>
<li><p>HTTP 条件 GET 使用的方法？</p>
<p>客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p>
<p>下面是一个具体的发送接受报文示例：</p>
<p>客户端发送请求：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET <span class="regexp">/ HTTP/</span><span class="number">1.1</span>  </div><div class="line"><span class="string">Host:</span> www.sina.com.<span class="string">cn:</span><span class="number">80</span>  </div><div class="line">If-Modified-<span class="string">Since:</span>Thu, <span class="number">4</span> Feb <span class="number">2010</span> <span class="number">20</span>:<span class="number">39</span>:<span class="number">13</span> GMT  </div><div class="line"><span class="string">Connection:</span> Close</div></pre></td></tr></table></figure>
<p>第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 <code>If-Modified-Since</code> 字段判断响应文件没有更新，如果没有更新，服务器返回一个 <code>304 Not Modified</code>响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HTTP/1.0 <span class="number">304</span> Not Modified  </div><div class="line"><span class="attribute">Date</span>: Thu, 04 Feb 2010 12:38:41 GMT  </div><div class="line"><span class="attribute">Content-Type</span>: text/html  </div><div class="line"><span class="attribute">Expires</span>: Thu, 04 Feb 2010 12:39:41 GMT  </div><div class="line"><span class="attribute">Last-Modified</span>: Thu, 04 Feb 2010 12:29:04 GMT  </div><div class="line"><span class="attribute">Age</span>: 28  </div><div class="line"><span class="attribute">X-Cache</span>: HIT from sy32-21.sina.com.cn  </div><div class="line"><span class="attribute">Connection</span>: close</div></pre></td></tr></table></figure>
<p>如果服务器端资源已经更新的话，就返回正常的响应。</p>
</li>
</ol>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="TCP的特性"><a href="#TCP的特性" class="headerlink" title="TCP的特性"></a>TCP的特性</h3><ul>
<li>TCP提供一种<strong>面向连接的、可靠的</strong>字节流服务</li>
<li>在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP</li>
<li>TCP使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP使用累积确认</li>
<li>TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><ul>
<li><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p>
<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p>
</li>
<li><p>TCP连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p>
</li>
</ul>
<h2 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h2><pre><code>HTTPS基础知识：HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版,是使用TLS/SSL加密的HTTP协议。    HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。
TLS/SSL全称安全传输层协议Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。
</code></pre><p><img src="https://ww4.sinaimg.cn/large/006tKfTcly1fdohivlsokj30eu08ewet.jpg" alt=""></p>
<h3 id="HTTPS和HTTP的区别是什么？"><a href="#HTTPS和HTTP的区别是什么？" class="headerlink" title="HTTPS和HTTP的区别是什么？"></a>HTTPS和HTTP的区别是什么？</h3><p><img src="https://ww2.sinaimg.cn/large/006tKfTcly1fdohjefrzvj30bg05wa9y.jpg" alt=""></p>
<p>一、什么是HTTPS<br>​    HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。</p>
<p>HTTPS主要作用是：<br>（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;<br>（2）对网站服务器进行真实身份认证。<br>二、什么是HTTP<br>​    HTTP是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准(TCP)，用于从WWW服务器传输超文本到本地浏览器的传输协议。HTTP是采用明文形式进行数据传输，极易被不法份子窃取和篡改。<br>三、HTTPS和HTTP的区别是什么<br>​    1、HTTPS是加密传输协议，HTTP是名文传输协议;<br>​    2、HTTPS需要用到SSL证书，而HTTP不用;<br>​    3、HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO；<br>​    4、HTTPS标准端口443，HTTP标准端口80;<br>​    5、HTTPS基于传输层，HTTP基于应用层;<br>​    6、HTTPS在浏览器显示绿色安全锁，HTTP没有显示;</p>
<p>【参考:（1）<a href="http://www.wosign.com/news/2015-1225-01.htm" target="_blank" rel="external">为保护用户隐私安全,谷歌优先索引HTTPS网页</a>、</p>
<p>​               （2）<a href="http://www.wosign.com/News/baidu-https.html" target="_blank" rel="external">百度开放收录https站点，https全网化势不可挡】</a>】</p>
<pre><code>总的来说HTTPS比HTTP更加安全，能够有效的保护网站用户的隐私信息安全，这也是为什么现在的HTTPS网站越来越多。如果不想你的网站因为数据泄露上头条的话，就赶快去申请一张SSL证书为自己的网站实现HTTPS加密吧!
</code></pre><h4 id="TLS-SSL工作原理"><a href="#TLS-SSL工作原理" class="headerlink" title="TLS/SSL工作原理"></a>TLS/SSL工作原理</h4><p>​    TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密。其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。  </p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcly1fdohtiwmvcj30fd07ut9a.jpg" alt=""></p>
<h5 id="散列函数Hash"><a href="#散列函数Hash" class="headerlink" title="散列函数Hash"></a>散列函数Hash</h5><p>​        常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性;<br>​        在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;<br><strong>对称加密</strong><br>​        常见的有 AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1;<br>        对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制;<br><strong>非对称加密</strong><br>​        即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。<br>​        非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。<br>​        结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</p>
<h2 id="Socket-基本概念"><a href="#Socket-基本概念" class="headerlink" title="Socket 基本概念"></a>Socket 基本概念</h2><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。</p>
<p>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</p>
<h5 id="Socket-的使用场景："><a href="#Socket-的使用场景：" class="headerlink" title="Socket 的使用场景："></a>Socket 的使用场景：</h5><p><img src="https://ww4.sinaimg.cn/large/006tKfTcly1fdutovsrnej316q0c4tay.jpg" alt=""></p>
<p>这些协议之前的关系：</p>
<p>HTTP是运行在应用层上的应用协议，而不同的层级上都有相应的协议在运行。层级的堆栈关系一般可以这么描述：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">Application Layer -- e.g. HTTP</span></div><div class="line">----</div><div class="line"><span class="section">Transport Layer -- e.g. TCP</span></div><div class="line">----</div><div class="line"><span class="section">Internet Layer -- e.g. IP</span></div><div class="line">----</div><div class="line">Link Layer -- e.g. IEEE 802.2</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/网络知识点儿/" data-id="cj46tfgzc002wo3s6einnnysr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">ios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/图片/">图片</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小说/">小说</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率/">效率</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文字/">文字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/网络/iOS/">iOS</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Authentication/">Authentication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CGRect/">CGRect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NSURLRequest/">NSURLRequest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TouchID/">TouchID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/下载插件/">下载插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/不甘示弱/">不甘示弱</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/仓央嘉措/">仓央嘉措</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/偈子/">偈子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/南工/">南工</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/屏蔽广告/">屏蔽广告</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/悔恨/">悔恨</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/我的母校/">我的母校</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/执子之手，共你一世风霜/">执子之手，共你一世风霜</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文史/">文史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文字/">文字</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文学/">文学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/梦溪湖/">梦溪湖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/湘西王/">湘西王</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生命/">生命</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网页歌曲/">网页歌曲</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网页视频/">网页视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/表单上传/">表单上传</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/西原/">西原</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/见或不见/">见或不见</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/认真的雪/">认真的雪</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/陈渠珍/">陈渠珍</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Authentication/" style="font-size: 10px;">Authentication</a> <a href="/tags/CGRect/" style="font-size: 10px;">CGRect</a> <a href="/tags/NSURLRequest/" style="font-size: 10px;">NSURLRequest</a> <a href="/tags/Objective-C/" style="font-size: 13.33px;">Objective-C</a> <a href="/tags/TouchID/" style="font-size: 10px;">TouchID</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/下载插件/" style="font-size: 10px;">下载插件</a> <a href="/tags/不甘示弱/" style="font-size: 10px;">不甘示弱</a> <a href="/tags/仓央嘉措/" style="font-size: 10px;">仓央嘉措</a> <a href="/tags/偈子/" style="font-size: 10px;">偈子</a> <a href="/tags/南工/" style="font-size: 10px;">南工</a> <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/屏蔽广告/" style="font-size: 10px;">屏蔽广告</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/悔恨/" style="font-size: 10px;">悔恨</a> <a href="/tags/我的母校/" style="font-size: 10px;">我的母校</a> <a href="/tags/执子之手，共你一世风霜/" style="font-size: 10px;">执子之手，共你一世风霜</a> <a href="/tags/文史/" style="font-size: 10px;">文史</a> <a href="/tags/文字/" style="font-size: 16.67px;">文字</a> <a href="/tags/文学/" style="font-size: 10px;">文学</a> <a href="/tags/梦溪湖/" style="font-size: 10px;">梦溪湖</a> <a href="/tags/湘西王/" style="font-size: 10px;">湘西王</a> <a href="/tags/生命/" style="font-size: 10px;">生命</a> <a href="/tags/网页歌曲/" style="font-size: 10px;">网页歌曲</a> <a href="/tags/网页视频/" style="font-size: 10px;">网页视频</a> <a href="/tags/表单上传/" style="font-size: 10px;">表单上传</a> <a href="/tags/西原/" style="font-size: 10px;">西原</a> <a href="/tags/见或不见/" style="font-size: 10px;">见或不见</a> <a href="/tags/认真的雪/" style="font-size: 10px;">认真的雪</a> <a href="/tags/陈渠珍/" style="font-size: 10px;">陈渠珍</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/25/iOS推送机制/">iOS推送机制</a>
          </li>
        
          <li>
            <a href="/2017/03/21/ios应用程序的生命周期/"> ios应用程序的生命周期</a>
          </li>
        
          <li>
            <a href="/2017/03/20/OC内存管理/">OC内存管理</a>
          </li>
        
          <li>
            <a href="/2017/03/19/3·15晚会/">3·15晚会</a>
          </li>
        
          <li>
            <a href="/2017/03/17/NSString属性什么时候用copy，什么时候用strong/">NSString属性什么时候用copy，什么时候用strong?</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 柴亚航<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>