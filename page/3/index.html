<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS Developer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Talk is cheap， show me the code. 用心创造美好未来">
<meta property="og:type" content="website">
<meta property="og:title" content="iOS Developer">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="iOS Developer">
<meta property="og:description" content="Talk is cheap， show me the code. 用心创造美好未来">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS Developer">
<meta name="twitter:description" content="Talk is cheap， show me the code. 用心创造美好未来">
  
    <link rel="alternate" href="/atom.xml" title="iOS Developer" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">iOS Developer</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello World</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS网络编程的三种方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/21/iOS网络编程的三种方式/" class="article-date">
  <time datetime="2017-02-21T06:54:50.000Z" itemprop="datePublished">2017-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/21/iOS网络编程的三种方式/">iOS网络编程的三种方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <a href="http://lib.csdn.net/base/ios" target="_blank" rel="external"><strong>iOS</strong></a> 可以采用三类api 接口进行网络编程，根据抽象层次从低到高分别为socket方式、stream方式、url 方式</p>
<h3 id="一-、socket-方式【比如：ASIHttpRequest】"><a href="#一-、socket-方式【比如：ASIHttpRequest】" class="headerlink" title="一 、socket 方式【比如：ASIHttpRequest】"></a>一 、socket 方式【比如：ASIHttpRequest】</h3><blockquote>
<p>​    iOS 提供的socket 方式的网络编程接口为CFSocket。CFSocket是BSD sockets的抽象和封装，CFSocket提供BSD sockets几乎所有的功能，并与run loop集成，用来实现多线程网络编程和网络事件监听。基于 CFSocket可以实现各种类型的 socket编程，包括stream-based 的sockets(如tcp)和packet-based 的sockets(如udp)。需要注意的是在iOS中CFSocket接口在需要时不自动激活设备的 cellular modem或on-demand VPN。</p>
<pre><code>CFSocket包括以下编程接口，包括Socket的 创建、配置，以及根据创建和配置好的Socket 进行 远程通讯等接口。
</code></pre></blockquote>
<h4 id="1-Socket的-创建"><a href="#1-Socket的-创建" class="headerlink" title="1.  Socket的 创建"></a>1.  Socket的 创建</h4><h5 id="1-1、CFSocketCreate"><a href="#1-1、CFSocketCreate" class="headerlink" title="1 .1、CFSocketCreate"></a>1 .1、CFSocketCreate</h5><p>创建一个特定协议和类型的 CFSocket对象</p>
<h5 id="1-2、CFSocketCreateWithSocketSignature"><a href="#1-2、CFSocketCreateWithSocketSignature" class="headerlink" title="1.2、CFSocketCreateWithSocketSignature"></a>1.2、CFSocketCreateWithSocketSignature</h5><p>该接口根据一个包含通讯协议和地址的CFSocketSignature结构来创建一个CFSocket对象</p>
<h5 id="1-3、-CFSocketCreateConnectedToSocketSignature"><a href="#1-3、-CFSocketCreateConnectedToSocketSignature" class="headerlink" title="1.3、 CFSocketCreateConnectedToSocketSignature"></a>1.3、 CFSocketCreateConnectedToSocketSignature</h5><p>该接口在创建一个CFSocket对象的同时还与一个远端主机进行连接。</p>
<h5 id="1-4、CFSocketCreateWithNative"><a href="#1-4、CFSocketCreateWithNative" class="headerlink" title="1.4、CFSocketCreateWithNative"></a>1.4、CFSocketCreateWithNative</h5><p>该接口通过封装一个存在的 BSD socket来创建一个CFSocket对象。</p>
<h4 id="2-Socket的配置"><a href="#2-Socket的配置" class="headerlink" title="2.   Socket的配置"></a>2.   Socket的配置</h4><h5 id="2-1-CFSocketCopyAddress"><a href="#2-1-CFSocketCopyAddress" class="headerlink" title="2.1   CFSocketCopyAddress"></a>2.1   CFSocketCopyAddress</h5><p>功能： 返回一个 CFSocket对象的本地地址。</p>
<p>语法：（Swift）func CFSocketCopyAddress(_ s: CFSocket!) -&gt; CFData!</p>
<h5 id="2-2、CFSocketCopyPeerAddress"><a href="#2-2、CFSocketCopyPeerAddress" class="headerlink" title="2.2、CFSocketCopyPeerAddress"></a>2.2、CFSocketCopyPeerAddress</h5><p>功能：返回与一个 CFSocket对象连接的远端地址。</p>
<p>语法：（Swift）func CFSocketCopyPeerAddress(_ s: CFSocket!) -&gt; CFData!</p>
<h5 id="2-3-CFSocketDisableCallBacks"><a href="#2-3-CFSocketDisableCallBacks" class="headerlink" title="2.3  CFSocketDisableCallBacks"></a>2.3  CFSocketDisableCallBacks</h5><p>功能：临时取消一个CFSocket对象创建时指定的某种类型的事件回调。</p>
<p>语法：Swift func CFSocketDisableCallBacks(_ s: CFSocket!,</p>
<pre><code>_ callBackTypes: CFOptionFlags)
</code></pre><h5 id="2-4-CFSocketEnableCallBacks"><a href="#2-4-CFSocketEnableCallBacks" class="headerlink" title="2.4   CFSocketEnableCallBacks"></a>2.4   CFSocketEnableCallBacks</h5><p>功能：重新允许先前CFSocketDisableCallBacks函数取消的某种类型的事件回调。</p>
<p>语法：（Swift）func CFSocketEnableCallBacks(_ s: CFSocket!,</p>
<pre><code>_ callBackTypes: CFOptionFlags)
</code></pre><h5 id="2-5-CFSocketGetContext"><a href="#2-5-CFSocketGetContext" class="headerlink" title="2.5 CFSocketGetContext"></a>2.5 CFSocketGetContext</h5><p>功能：返回一个CFSocket对象的上下文信息。</p>
<p>语法：（Swift）func CFSocketGetContext(_ s: CFSocket!,</p>
<pre><code>_ context: UnsafeMutablePointer&lt;CFSocketContext&gt;)
</code></pre><h5 id="2-6-CFSocketGetNative"><a href="#2-6-CFSocketGetNative" class="headerlink" title="2.6 CFSocketGetNative"></a>2.6 CFSocketGetNative</h5><p>返回与一个CFSocket对象相关的本地 BSD socket。</p>
<p>语法：（Swift）func CFSocketGetNative(_ s: CFSocket!) -&gt; CFSocketNativeHandle</p>
<h5 id="2-7-CFSocketGetSocketFlags"><a href="#2-7-CFSocketGetSocketFlags" class="headerlink" title="2.7   CFSocketGetSocketFlags"></a>2.7   CFSocketGetSocketFlags</h5><p>功能：返回控制一个CFSocket对象的确定行为的 标志。</p>
<p>语法：（Swift）func CFSocketGetSocketFlags(_ s: CFSocket!) -&gt; CFOptionFlags</p>
<h5 id="2-8-CFSocketSetSocketFlags"><a href="#2-8-CFSocketSetSocketFlags" class="headerlink" title="2.8 CFSocketSetSocketFlags"></a>2.8 CFSocketSetSocketFlags</h5><p>功能：设置控制一个CFSocket对象的确定行为的 标志。</p>
<p>语法：（Swift）func CFSocketSetSocketFlags(_ s: CFSocket!,</p>
<pre><code>_ flags: CFOptionFlags)
</code></pre><h5 id="2-9-CFSocketSetAddress"><a href="#2-9-CFSocketSetAddress" class="headerlink" title="2.9 CFSocketSetAddress"></a>2.9 CFSocketSetAddress</h5><p>功能：为一个CFSocket对象绑定一个本地地址并在本地socket支持的情况下对socket进行配置使其处于监听状态。该函数对应本地socket的 bind以及listen功能。一旦CFSocket对象绑定地址，依赖于socket的协议，其它进程和主机能连接到该CFSocket对象。</p>
<p>语法：（Swift）func CFSocketSetAddress(_ s: CFSocket!,</p>
<pre><code>_ address: CFData!) -&gt; CFSocketError
</code></pre><h4 id="3-Sockets的使用"><a href="#3-Sockets的使用" class="headerlink" title="3. Sockets的使用"></a>3. Sockets的使用</h4><h5 id="3-1-CFSocketConnectToAddress"><a href="#3-1-CFSocketConnectToAddress" class="headerlink" title="3.1 CFSocketConnectToAddress"></a>3.1 CFSocketConnectToAddress</h5><p>功能：打开与一个远程socket的一个连接。</p>
<p>语法：（Swift）func CFSocketConnectToAddress(_ s: CFSocket!,</p>
<pre><code>_ address: CFData!,

_ timeout: CFTimeInterval) -&gt; CFSocketError
</code></pre><h5 id="3-2-CFSocketCreateRunLoopSource"><a href="#3-2-CFSocketCreateRunLoopSource" class="headerlink" title="3.2 CFSocketCreateRunLoopSource"></a>3.2 CFSocketCreateRunLoopSource</h5><p>语法：（Swift）func CFSocketCreateRunLoopSource(_ allocator: CFAllocator!,</p>
<pre><code>_ s: CFSocket!,

_ order: CFIndex) -&gt; CFRunLoopSource!
</code></pre><p>功能：为一个CFSocket对象创建一个CFRunLoopSource对象。该创建的 CFRunLoopSource对象不自动添加到一个run loop。为了增加该run loop source到某个run loop，需要调用CFRunLoop对象 的CFRunLoopAddSource函数来为该CFRunLoop对象添加run loop source。</p>
<h5 id="3-3-CFSocketGetTypeID"><a href="#3-3-CFSocketGetTypeID" class="headerlink" title="3.3 CFSocketGetTypeID"></a>3.3 CFSocketGetTypeID</h5><p>功能：返回CFSocket对象的 opaque类型对应的类型标示符。</p>
<p>语法：（Swift）func CFSocketGetTypeID() -&gt; CFTypeID </p>
<h5 id="3-4-CFSocketInvalidate"><a href="#3-4-CFSocketInvalidate" class="headerlink" title="3.4  CFSocketInvalidate"></a>3.4  CFSocketInvalidate</h5><p>功能：使一个CFSocket对象无效，使其停止接收和发送任何消息。</p>
<p>语法：（Swift）func CFSocketInvalidate(_ s: CFSocket!)</p>
<h5 id="3-5-CFSocketIsValid"><a href="#3-5-CFSocketIsValid" class="headerlink" title="3.5 CFSocketIsValid"></a>3.5 CFSocketIsValid</h5><p>功能：返回一个指示一个CFSocket对象是否有效及是否能够发送和接收消息的布尔值。</p>
<p>语法：（Swift）func CFSocketIsValid(_ s: CFSocket!) -&gt; Boolean</p>
<h5 id="3-6-CFSocketSendData"><a href="#3-6-CFSocketSendData" class="headerlink" title="3.6 CFSocketSendData"></a>3.6 CFSocketSendData</h5><p>功能：该函数用来通过一个CFSocket对象发送数据。</p>
<p>语法：（Swift）func CFSocketSendData(_ s: CFSocket!,</p>
<pre><code>_ address: CFData!,

_ data: CFData!,

_ timeout: CFTimeInterval) -&gt; CFSocketError
</code></pre><blockquote>
<p>PS:上述语法摘录自网络！！！</p>
</blockquote>
<h3 id="二、stream编程模式【比如：AFNetworking】"><a href="#二、stream编程模式【比如：AFNetworking】" class="headerlink" title="二、stream编程模式【比如：AFNetworking】"></a>二、stream编程模式【比如：AFNetworking】</h3><blockquote>
<p>​    stream编程模式提供了与 unix 的文件操作类似的模式。首先创建和设置流，接着打开流，然后读写流，在流存在时还可以通过查询流的相关属性来读取流的相关信息，在流使用完毕后关闭流。</p>
<pre><code>iOS 为stream编程模式提供的api编程接口包括两大类，一类是Core Foundation框架层用[**C语言**](http://lib.csdn.net/base/c)实现的CFStream  API（包括CFStream、 CFReadStream 、CFWriteStream等）,一类是基于其上的在Foundation框架层用[**Objective-C**](http://lib.csdn.net/base/objective-c)语言实现的NSStream API（包括NSStream、NSInputStream NSOutputStream等）,两者提供相似的接口和行为，其中某些对象是toll-free bridged类型的，如CFStream 与NSStream，CFReadStream与NSInputStream，CFWriteStream与NSOutputStream之间，因此可以混合使用。
</code></pre></blockquote>
<p>开发人员可以根据自己的语言偏好选择使用。</p>
<pre><code>CFStream API的主要接口：
</code></pre><h4 id="1、CFStream-创建接口"><a href="#1、CFStream-创建接口" class="headerlink" title="1、CFStream 创建接口"></a>1、CFStream 创建接口</h4><h5 id="1-1-CFStreamCreatePairWithPeerSocketSignature"><a href="#1-1-CFStreamCreatePairWithPeerSocketSignature" class="headerlink" title="1.1  CFStreamCreatePairWithPeerSocketSignature"></a>1.1  CFStreamCreatePairWithPeerSocketSignature</h5><pre><code>功能：创建一对到一个socket的可读和可写流。
</code></pre><h5 id="1-2-CFStreamCreatePairWithSocketToHost"><a href="#1-2-CFStreamCreatePairWithSocketToHost" class="headerlink" title="1.2 CFStreamCreatePairWithSocketToHost"></a>1.2 CFStreamCreatePairWithSocketToHost</h5><p>功能：创建连接到一个特定主机的特定端口的一对可读写流。</p>
<h5 id="1-3-CFStreamCreatePairWithSocket"><a href="#1-3-CFStreamCreatePairWithSocket" class="headerlink" title="1.3 CFStreamCreatePairWithSocket"></a>1.3 CFStreamCreatePairWithSocket</h5><p>功能：创建一对连接到一个socket的可读写流</p>
<h5 id="1-4-CFStreamCreateBoundPair"><a href="#1-4-CFStreamCreateBoundPair" class="headerlink" title="1.4 CFStreamCreateBoundPair"></a>1.4 CFStreamCreateBoundPair</h5><p>功能：创建一对读写流。</p>
<p>其它可读写流创建接口：</p>
<h5 id="1-5-CFReadStreamCreateForHTTPRequest"><a href="#1-5-CFReadStreamCreateForHTTPRequest" class="headerlink" title="1.5 CFReadStreamCreateForHTTPRequest"></a>1.5 CFReadStreamCreateForHTTPRequest</h5><p>   功能：为一个CFHTTP请求创建一个可读流。</p>
<h5 id="1-6-CFReadStreamCreateForStreamedHTTPRequest"><a href="#1-6-CFReadStreamCreateForStreamedHTTPRequest" class="headerlink" title="1.6 CFReadStreamCreateForStreamedHTTPRequest"></a>1.6 CFReadStreamCreateForStreamedHTTPRequest</h5><p>功能：为一个HTTP请求的body保持在内存的CFHTTP请求创建一个可读流。</p>
<h5 id="1-7-CFReadStreamCreateWithFTPURL"><a href="#1-7-CFReadStreamCreateWithFTPURL" class="headerlink" title="1.7  CFReadStreamCreateWithFTPURL"></a>1.7  CFReadStreamCreateWithFTPURL</h5><p>功能：创建一个FTP可读流</p>
<h5 id="1-8-CFWriteStreamCreateWithFTPURL"><a href="#1-8-CFWriteStreamCreateWithFTPURL" class="headerlink" title="1.8  CFWriteStreamCreateWithFTPURL"></a>1.8  CFWriteStreamCreateWithFTPURL</h5><p>功能：创建一个FTP可读流</p>
<h4 id="2-CFReadStream接口"><a href="#2-CFReadStream接口" class="headerlink" title="2. CFReadStream接口"></a>2. CFReadStream接口</h4><h5 id="2-1-流的打开和关闭"><a href="#2-1-流的打开和关闭" class="headerlink" title="2.1     流的打开和关闭"></a>2.1     流的打开和关闭</h5><pre><code>CFReadStreamOpen

CFReadStreamClose
</code></pre><h5 id="2-2-读取数据"><a href="#2-2-读取数据" class="headerlink" title="2.2  读取数据"></a>2.2  读取数据</h5><pre><code>CFReadStreamRead
</code></pre><h5 id="2-3-调度一个可读流"><a href="#2-3-调度一个可读流" class="headerlink" title="2.3.  调度一个可读流"></a>2.3.  调度一个可读流</h5><p>​     CFReadStreamScheduleWithRunLoop(<em>:</em>:_:)     </p>
<pre><code>CFReadStreamUnscheduleFromRunLoop(_:_:_:) 
</code></pre><h5 id="2-4-检查可读流的属性"><a href="#2-4-检查可读流的属性" class="headerlink" title="2.4 检查可读流的属性"></a>2.4 检查可读流的属性</h5><p>​    CFReadStreamCopyProperty(<em>:</em>:) </p>
<p>​    CFReadStreamGetBuffer(<em>:</em>:_:)     </p>
<p>​    CFReadStreamCopyError(_:) </p>
<p>​    CFReadStreamGetError(_:) </p>
<p>​    CFReadStreamGetStatus(_:)     </p>
<p>​    CFReadStreamHasBytesAvailable(_:) </p>
<h5 id="2-5-设置可读流的属性"><a href="#2-5-设置可读流的属性" class="headerlink" title="2.5 设置可读流的属性"></a>2.5 设置可读流的属性</h5><p>​    CFReadStreamSetClient(<em>:</em>:<em>:</em>:)</p>
<p>​    CFReadStreamSetProperty(<em>:</em>:_:) </p>
<h5 id="2-6-得到-CFReadStream的-Type-ID"><a href="#2-6-得到-CFReadStream的-Type-ID" class="headerlink" title="2.6 得到 CFReadStream的 Type ID"></a>2.6 得到 CFReadStream的 Type ID</h5><pre><code>CFReadStreamGetTypeID()        
</code></pre><h4 id="3-CFWriteStream-相关接口"><a href="#3-CFWriteStream-相关接口" class="headerlink" title="3.CFWriteStream 相关接口"></a>3.CFWriteStream 相关接口</h4><pre><code>3.1 CFWriteStreamClose(_:)

3.2 CFWriteStreamOpen(_:) 

3.3 CFWriteStreamWrite(_:_:_:)
</code></pre><p>​     3.4 CFWriteStreamScheduleWithRunLoop(<em>:</em>:_:)</p>
<pre><code>3.5 CFWriteStreamUnscheduleFromRunLoop(_:_:_:)
</code></pre><p>​     3.6 CFWriteStreamCanAcceptBytes(_:)</p>
<pre><code>3.7 CFWriteStreamCopyProperty(_:_:)

3.8 CFWriteStreamCopyError(_:)

3.9 CFWriteStreamGetError(_:)

3.10 CFWriteStreamGetStatus(_:) 
</code></pre><p>​     3.11 CFWriteStreamSetClient(<em>:</em>:<em>:</em>:)</p>
<pre><code>3.12 CFWriteStreamSetProperty(_:_:_:) 

3.13 CFWriteStreamGetTypeID()
</code></pre><h4 id="CFStream-API的使用步骤："><a href="#CFStream-API的使用步骤：" class="headerlink" title="CFStream API的使用步骤："></a>CFStream API的使用步骤：</h4><p>1） 利用流创建接口创建相关流；</p>
<p>2）、调用CFReadStreamSetClient （可读流）或CFWriteStreamSetClient （可写流）来登记要接收的流相关的事件；</p>
<p>3）、调用CFReadStreamScheduleWithRunLoop（可读流）或CFWriteStreamScheduleWithRunLoop（可写流）来使在流在一个run loop上进行调度以便接收相关事件；</p>
<p>4）、调用CFReadStreamOpen 或CFWriteStreamOpen 来打开已创建的流；</p>
<p>5）、在读取流的创建时登记的回调中，在接收到kCFStreamEventHasBytesAvailable事件时来读取数据， 在可写流已登记的回调中，在接收到kCFStreamEventCanAcceptBytes 事件时开始发送数据或请求；</p>
<p>6） 数据传输完成，关闭和释放打开和创建的相关流；</p>
<h3 id="三、url-编程模式"><a href="#三、url-编程模式" class="headerlink" title="三、url 编程模式"></a>三、url 编程模式</h3><blockquote>
<pre><code>url 编程模式通过URL 的方式来实现网络编程，任何要存取的网络资源（包括局域网和广域网）都可以用一个URL来表示和存取，并支持设备间的资源共享。url 编程模式系统提供http, https, file, ftp, data等五种协议支持，并允许用户自己开发和登记相关类来支持另外的应用层网络协议，进行协议的扩展。
</code></pre></blockquote>
<p>​    url 编程模式在IOS系统可以使用两种编程接口：NSURLSession 和NSURLConnection。</p>
<p>​    对于iOS 7 以后的最新系统推荐使用NSURLSession API，对于老版本由于不支持NSURLSession，因此必须使用NSURLConnection API。</p>
<p>​    NSURLSession编程模式是对相关的连接请求通过一个会话来完成，应用通过创建一系列sessions来实现网络通讯，每一个session协调一组相关数据的传输任务。在每一个session内，应用添加一系列任务，每一个任务表现一个特定URL 请求。</p>
<pre><code>NSURLSession相比NSURLConnection的优点是支持在应用挂起、停止或crashed时能够在后台继续下载数据，即支持任务的取消、重启（恢复）、挂起，以及支持从已挂起、取消或失败的下载中重新恢复下载的能力。

 对于简单的请求，还可以直接通过一个简单的NSURL对象来发出请求，并使用一个NSData内存对象或者一个文件的方式来引出NSURL指向的内容。而NSURLConnection API只能通过构造一个NSURLRequest对象或其子类来发出URL请求来请求下载或上传URL数据。 使用一个NSURLRequest请求对象封装一个URL请求，例如HTTP协议方法，除了可以封装一些协议特定的属性外，还可以规定任意本地cached数据的使用策略。

 对于NSURLRequest请求对象的应答包括两部分：描述内容的元数据metadata及内容数据本身。两种API对于使用NSURLRequest请求接收的元数据metadata都由NSURLResponse类来封装，其中包含MIME类型、内容长度、编码及提供应答的URL等内容。NSURLResponse协议特定的子类还能提供额外的元数据，如NSHTTPURLResponse提供协议头和WEB服务器返回的状态码 等信息。

 NSURLSession API的使用：

 NSURLSession类支持三种会话类型（默认会话类型、临时会话、后台会话）以及三种类型的任务（数据任务、下载任务、上传任务）。

 数据任务使用NSData 对象来发送和接收内存数据，不存储数据到一个文件，因此不支持后台会话。

 下载任务以一个文件的形式引出数据，并支持在应用没有运行时的后台下载。

 上传任务用来上传数据（文件），也能够支持应用没有运行时的后台上传。

  默认会话和后台会话的区别是后台会话使用一个分离的进程处理所有的数据传输任务，并带有一些限制：后台会话必须使用特定应用代理来提供事件提交，并仅支持HTTP和HTTPS 协议，不支持其它定制协议，并仅支持上传和下载任务，不支持数据任务。

 临时会话不存储任何数据到磁盘，所有接收的内容都保存到与会话关联的RAM中，当会话无效时，RAM中接收的内容自动被清除。
</code></pre><p>   NSURLSession API的使用步骤：</p>
<p>   1 、创建一个NSURLSessionConfiguration配置对象</p>
<p>NSURLSessionConfiguration配置对象提供广泛的配置选项，包括：</p>
<p>1）、特定于单个会话的私有数据存储，包括caches, cookies, credentials, 和protocols；</p>
<p>2）、与一个特定请求或一个会话关联的Authentication；</p>
<p>3）、与一个主机的最大连接数；</p>
<p>4）、与一个资源关联的超时；</p>
<p>5）、最小和最大TLS版本支持；</p>
<p>6）、定制的代理词典；</p>
<p>7）、cookie策略的控制；</p>
<p>8）、HTTP pipelining行为的控制</p>
<p>2、根据配置创建相应的NSURLSession；</p>
<p>NSURLSession API通过代理来实现异步URL内容存取，代理可以是系统提供的代理，还可以是应用提供的特定代理对象。任务对象当从服务器接收到数据或传输完成时调用这些代理对象的方法。</p>
<pre><code>在创建会话指定相应的代理对象。
</code></pre><p>3、为会话添加任务；</p>
<p>使用如下方法来添加数据任务到一个会话。</p>
<p>dataTaskWithURL(_:)</p>
<p>dataTaskWithURL(_:completionHandler:)</p>
<p>dataTaskWithRequest(_:)     </p>
<p>dataTaskWithRequest(_:completionHandler:) </p>
<p>​    </p>
<p>使用如下方法来添加下载任务到一个会话。</p>
<p>downloadTaskWithURL(_:)</p>
<p>downloadTaskWithURL(_:completionHandler:) </p>
<p>downloadTaskWithRequest(_:) </p>
<p>downloadTaskWithRequest(_:completionHandler:) </p>
<p>downloadTaskWithResumeData(_:) </p>
<p>downloadTaskWithResumeData(_:completionHandler:) </p>
<p>使用如下方法来添加上传任务到一个会话</p>
<p>uploadTaskWithRequest(_:fromData:)</p>
<p>uploadTaskWithRequest(_:fromData:completionHandler:)     </p>
<p>uploadTaskWithRequest(_:fromFile:)</p>
<p>uploadTaskWithRequest(_:fromFile:completionHandler:)</p>
<p>uploadTaskWithStreamedRequest(_:) </p>
<p>4、使用代理方法接收数据及状态信息</p>
<p>会话的数据任务在使用应用特定代理接收数据时必须实现如下两个代理方法：</p>
<p>URLSession:dataTask:didReceiveData: </p>
<p>一次一片的提供请求的数据给会话任务。</p>
<p>URLSession:task:didCompleteWithError:</p>
<p>指示请求数据已经全部接收。</p>
<p>会话的下载任务在下载文件时应该实现如下代理方法：</p>
<p>URLSession:downloadTask:didFinishDownloadingToURL:</p>
<p>下载内容存储到一个URL指定的一个临时文件，在该方法返回之前，必须把临时文件的内容移到一个永久位置，而临时文件被删除。</p>
<p>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite: </p>
<p>为应用提供关于当前下载进度的状态信息</p>
<p>URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:</p>
<p>告诉应用已经从从先前的失败下载中恢复。</p>
<p>URLSession:task:didCompleteWithError: </p>
<p>告诉应用下载已经失败。</p>
<p>下载失败恢复处理：</p>
<p>在应用使用cancelByProducingResumeData: 方法取消下载任务时，可以使用downloadTaskWithResumeData: 或 downloadTaskWithResumeData:completionHandler:方法重新创建一个新下载任务并传送cancelByProducingResumeData:产生的恢复数据从而接着继续下载。</p>
<p>在传输失败时，如果任务可恢复，则调用URLSession:task:didCompleteWithError: 方法。在传送给URLSession:task:didCompleteWithError: 方法的参数NSError中的 userInfo 词典中包含键值为NSURLSessionDownloadTaskResumeData的恢复数据，因此可以使用downloadTaskWithResumeData: 或 downloadTaskWithResumeData:completionHandler:方法重新创建一个新下载任务来接着恢复数据继续下载。</p>
<p>系统代理仅能支持基本的URL资源存取任务，不支持认证和后台下载，并且还必须提供一个completion handler block来把返回的URL数据提交到应用。</p>
<p>会话的上传任务的任务创建和相关代理方法：</p>
<pre><code>会话的上传任务使用HTTP  POST方法来上传数据。可以以一个NSData对象、一个文件或使用一个流为HTTP POST请求的body提供内容。

在以NSData对象提供上传数据时，应用调用uploadTaskWithRequest:fromData: 或uploadTaskWithRequest:fromData:completionHandler: 方法来创建上传任务。
</code></pre><p>​    在以文件形式提供上传数据时，应用调用uploadTaskWithRequest:fromFile: 或 uploadTaskWithRequest:fromFile:completionHandler:方法来创建上传任务</p>
<p>​    在以流方式提供上传数据时，应用调用uploadTaskWithStreamedRequest:方法来创建上传任务。</p>
<p>应用特定代理可以通过实现URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法来获得上传进度信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/21/iOS网络编程的三种方式/" data-id="cj46tfgxz0019o3s6aub2cvvk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面试知识点总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/17/面试知识点总结/" class="article-date">
  <time datetime="2017-02-17T10:05:50.000Z" itemprop="datePublished">2017-02-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/17/面试知识点总结/">面试知识点总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="多线程相关知识点汇总"><a href="#多线程相关知识点汇总" class="headerlink" title="多线程相关知识点汇总"></a>多线程相关知识点汇总</h4><h5 id="1-请简单说明多线程技术的优点和缺点？"><a href="#1-请简单说明多线程技术的优点和缺点？" class="headerlink" title="1.请简单说明多线程技术的优点和缺点？"></a>1.请简单说明多线程技术的优点和缺点？</h5><p>优点：</p>
<ol>
<li>能够适当提高程序的执行效率；</li>
<li>能够适当的提高资源的利用率，比如CPU、内存。</li>
</ol>
<p>缺点：</p>
<ol>
<li>创建线程有额外开销</li>
<li>程序的代码更加复杂</li>
<li>线程越多，CPU在调度线程上的开销就越大</li>
<li>如果开启大量线程，反而会降低程序的性能</li>
</ol>
<h5 id="2-请简单说明线程和进程，以及他们之间的关系？"><a href="#2-请简单说明线程和进程，以及他们之间的关系？" class="headerlink" title="2.请简单说明线程和进程，以及他们之间的关系？"></a>2.请简单说明线程和进程，以及他们之间的关系？</h5><ul>
<li>进程是CPU调度和分配资源的单位。</li>
<li>线程是CPU调用的最小单位</li>
</ul>
<p>关系：</p>
<ul>
<li>进程包含线程；</li>
<li>一个程序可以对应多个进程，一个进程中可以有多个线程，但至少要有一个线程；</li>
<li>同一个进程内的线程共享进程的资源。</li>
</ul>
<h5 id="3-请简单说明在iOS开发中有哪些多线程的实现方案？"><a href="#3-请简单说明在iOS开发中有哪些多线程的实现方案？" class="headerlink" title="3.请简单说明在iOS开发中有哪些多线程的实现方案？"></a>3.请简单说明在iOS开发中有哪些多线程的实现方案？</h5><ol>
<li>PThread</li>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation</li>
</ol>
<h5 id="4-请简单说明主线程的作用，以及使用注意点？"><a href="#4-请简单说明主线程的作用，以及使用注意点？" class="headerlink" title="4.请简单说明主线程的作用，以及使用注意点？"></a>4.请简单说明主线程的作用，以及使用注意点？</h5><p>主线程:默认启动的线程</p>
<p>作用:</p>
<ol>
<li>显示和刷新UI界面</li>
<li>处理UI事件</li>
</ol>
<p>注意点:</p>
<ol>
<li>不要将耗时操作放在主线程中执行</li>
<li>UI操作必须在主线程中执行 !!!!</li>
</ol>
<h5 id="5-请简单列出NSThread线程的几种状态，并说明状态转换的逻辑？"><a href="#5-请简单列出NSThread线程的几种状态，并说明状态转换的逻辑？" class="headerlink" title="5.请简单列出NSThread线程的几种状态，并说明状态转换的逻辑？"></a>5.请简单列出NSThread线程的几种状态，并说明状态转换的逻辑？</h5><p>新建——就绪       CPU 调度当前任务——阻塞——死亡      CPU调度其他任务——就绪</p>
<h5 id="6-请简单说明如何简单的解决多线程访问同一块资源造成的线程安全的问题，以及注意点？"><a href="#6-请简单说明如何简单的解决多线程访问同一块资源造成的线程安全的问题，以及注意点？" class="headerlink" title="6.请简单说明如何简单的解决多线程访问同一块资源造成的线程安全的问题，以及注意点？"></a>6.请简单说明如何简单的解决多线程访问同一块资源造成的线程安全的问题，以及注意点？</h5><ul>
<li>加同步(互斥)锁</li>
<li>@synchronized</li>
<li>OC中的同步锁:(锁对象) + {要锁住的代码}</li>
<li>锁对象:要求是全局唯一的属性</li>
</ul>
<p>注意点:</p>
<ol>
<li>要注意加锁的位置</li>
<li>加锁需要耗费性能,因此需要注意加锁的条件(多线程访问同一块资源)</li>
<li>专业术语:线程同步</li>
</ol>
<h5 id="7-请简单介绍下什么是原子和非原子属性？"><a href="#7-请简单介绍下什么是原子和非原子属性？" class="headerlink" title="7.请简单介绍下什么是原子和非原子属性？"></a>7.请简单介绍下什么是原子和非原子属性？</h5><ul>
<li>atomic：原子属性，会为setter方法加锁，默认为atomic。线程安全，会消耗大量资源</li>
<li>nonatomic：非原子属性，不会为setter方法加锁。非线程安全，适合内存小的移动设备。</li>
</ul>
<h5 id="8-请简单介绍下GCD这门技术？"><a href="#8-请简单介绍下GCD这门技术？" class="headerlink" title="8.请简单介绍下GCD这门技术？"></a>8.请简单介绍下GCD这门技术？</h5><ul>
<li>全称 Grand Central Dispatch，中枢调度器。</li>
<li>GCD中有2个核心概念:任务和队列。</li>
<li>GCD使用:封装任务，将封装好的任务添加到队列中，遵循FIFO。</li>
</ul>
<h5 id="9-请简单介绍GCD中的几种队列？（4种）"><a href="#9-请简单介绍GCD中的几种队列？（4种）" class="headerlink" title="9.请简单介绍GCD中的几种队列？（4种）"></a>9.请简单介绍GCD中的几种队列？（4种）</h5><ul>
<li>并发队列：多个任务同时执行，会开启多个线程同时执行任务，只有在异步函数下才有效。</li>
<li>串行队列：任务只能一个接一个的去执行，不会开启多个线程，主队列属于串行队列，主队列所有的任务必须在主线程中执行。</li>
<li>全局队列</li>
<li>主队列</li>
</ul>
<h5 id="10-如果当前有多个任务，这些任务都需要开子线程执行，而多个任务之间有一定的依赖关系，如果使用GCD来实现请试着给出一些解决方案。"><a href="#10-如果当前有多个任务，这些任务都需要开子线程执行，而多个任务之间有一定的依赖关系，如果使用GCD来实现请试着给出一些解决方案。" class="headerlink" title="10.如果当前有多个任务，这些任务都需要开子线程执行，而多个任务之间有一定的依赖关系，如果使用GCD来实现请试着给出一些解决方案。"></a>10.如果当前有多个任务，这些任务都需要开子线程执行，而多个任务之间有一定的依赖关系，如果使用GCD来实现请试着给出一些解决方案。</h5><ul>
<li>使用异步函数（同步函数）+主队列</li>
</ul>
<h5 id="11-请简单说明单例模式的特点（作用）？"><a href="#11-请简单说明单例模式的特点（作用）？" class="headerlink" title="11.请简单说明单例模式的特点（作用）？"></a>11.请简单说明单例模式的特点（作用）？</h5><ul>
<li>如果一个类实现了单例，那么可以保证在程序运行过程，一个类只有一个实例</li>
<li>单例对象易于供外界访问（通常会提供一个类方法）</li>
<li>实现了单例模式后，可以方便地控制了实例个数，并节约系统资源</li>
</ul>
<h5 id="12-请简单介绍操作队列？"><a href="#12-请简单介绍操作队列？" class="headerlink" title="12.请简单介绍操作队列？"></a>12.请简单介绍操作队列？</h5><ul>
<li>操作队列本身是OC语言的，在iOS开发中可以用来实现多线程编程</li>
<li>操作队列有两大核心的概念，一个是操作（NSOperation），一个是队列(NSOperationQueue),操作用来封装任务，队列用来存放操作</li>
<li>要使用操作队列进行多线程编程，只需要把封装好的操作提交到相应的队列中即可，系统内部会视情况自动开启相应的线程来执行任务</li>
<li>在操作队列这门技术中，系统提供了两个子类可以来封装任务，一个是NSInvocationOperation，一个是NSBlockOperation,除此之外也可以直接自定义操作</li>
<li>操作队列中有两种队列，一种是通过[NSOperationQueue mainQueue]获得的主队列，一种是通过[[NSOperationQueue alloc]init]方法获得的非主队列</li>
<li>主队列是和主线程相关的串行队列，提交到主队列中的操作将被安排在主线程中执行（可以利用该特性来处理线程间通信的相关逻辑）</li>
<li>操作+队列:</li>
</ul>
<p>NSInvocationOperation</p>
<p>NSBlockOperatio</p>
<ul>
<li>NSOperationQueue</li>
</ul>
<p>自己创建 [[NSOperationQueue alloc]init];</p>
<p>主队列 [NSOperationQueue main];</p>
<h5 id="13-如果有多个操作如何来设置依赖关系，如何监听到某个操作执行完毕事件？"><a href="#13-如果有多个操作如何来设置依赖关系，如何监听到某个操作执行完毕事件？" class="headerlink" title="13.如果有多个操作如何来设置依赖关系，如何监听到某个操作执行完毕事件？"></a>13.如果有多个操作如何来设置依赖关系，如何监听到某个操作执行完毕事件？</h5><ol>
<li>设置依赖关系：假设有有两个操作分别是op1和op2，op1需要依赖于op2,那么只需要使用[op1 addDependency:op2]方法设置即可。</li>
<li>操作依赖补充：使用操作队列可以方便的指定多个操作间的依赖关系，甚至可以实现跨队列的操作依赖，但是在使用的时候需要注意操作之间不能有循环依赖关系</li>
<li>操作监听：可以使用^completionBlock来实现操作监听</li>
</ol>
<h5 id="14-请简单比较GCD中的全局并发队列和使用dispatch-queue-create函数创建的并发队列异同？"><a href="#14-请简单比较GCD中的全局并发队列和使用dispatch-queue-create函数创建的并发队列异同？" class="headerlink" title="14.请简单比较GCD中的全局并发队列和使用dispatch_queue_create函数创建的并发队列异同？"></a>14.请简单比较GCD中的全局并发队列和使用dispatch_queue_create函数创建的并发队列异同？</h5><ol>
<li>全局并发队列在整个应用程序中本身是默认存在的并且对应有高优先级、默认优先级、低优先级和后台优先级一共四个并发队列，我们只是选择其中的一个直接拿来用。而Create函数是实打实的从头开始去创建一个队列。</li>
<li>在iOS6.0之前，在GCD中凡是使用了带Create和retain的函数在最后都需要做一次release操作。而主队列和全局并发队列不需要我们手动release。当然了，在iOS6.0之后GCD已经被纳入到了ARC的内存管理范畴中，即便是使用retain或者create函数创建的对象也不再需要开发人员手动释放，我们像对待普通OC对象一样对待GCD就OK。</li>
<li>在使用栅栏函数的时候，栅栏函数只有在和使用create函数自己的创建的并发队列一起使用的时候才有效</li>
<li>其它区别涉及到XNU内核的系统级线程编程，不一一列举。</li>
</ol>
<h5 id="15-请简单说明对图片进行二级缓存的实现思路？"><a href="#15-请简单说明对图片进行二级缓存的实现思路？" class="headerlink" title="15.请简单说明对图片进行二级缓存的实现思路？"></a>15.请简单说明对图片进行二级缓存的实现思路？</h5><p>在显示图片的时候</p>
<p>1）先检查该图片对应的内存缓存</p>
<ul>
<li><p>如果存在内存缓存，则</p>
<pre><code>a.直接使用设置并显示图片；
</code></pre></li>
<li><p>如果内存缓存中没有,则</p>
<pre><code>a.继续检查该图片对应的磁盘缓存是否存在，跳转到第2步。
</code></pre></li>
</ul>
<p>2）检查该图片对应的磁盘缓存</p>
<ul>
<li><p>如果存在磁盘缓存，则</p>
<pre><code>a.先保存一份到内存缓存中（方便下次使用）

b.然后设置并显示图片
</code></pre></li>
</ul>
<p>2.如果不存在磁盘缓存，则直接下载该图片，下载完成后</p>
<ol>
<li>保存一份到内存缓存中</li>
<li>保存一份到磁盘缓存中</li>
<li>设置并显示图片</li>
</ol>
<h5 id="16-请简单对比下GCD和NSOperation两种多线程的实现方案？"><a href="#16-请简单对比下GCD和NSOperation两种多线程的实现方案？" class="headerlink" title="16.请简单对比下GCD和NSOperation两种多线程的实现方案？"></a>16.请简单对比下GCD和NSOperation两种多线程的实现方案？</h5><ul>
<li>GCD是纯C语言的API,而操作队列则是Object-C的对象。</li>
<li>在GCD中，任务用块（block）来表示，而块是个轻量级的数据结构；相反操作队列中的『操作』NSOperation则是个更加重量级的Object-C对象。</li>
<li>具体该使用GCD还是使用NSOperation需要看具体的情况，如果只是想简单开一个子线程执行任务推荐使用GCD，如果有很多任务需要开多个子线程下载推荐使用操作队列</li>
</ul>
<h5 id="17-请按照自己的理解，说一说在进行多线程编程的时候相对于GCD而言，操作队列有哪些优势？"><a href="#17-请按照自己的理解，说一说在进行多线程编程的时候相对于GCD而言，操作队列有哪些优势？" class="headerlink" title="17.请按照自己的理解，说一说在进行多线程编程的时候相对于GCD而言，操作队列有哪些优势？"></a>17.请按照自己的理解，说一说在进行多线程编程的时候相对于GCD而言，操作队列有哪些优势？</h5><p>NSOperation和NSOperationQueue的好处有：</p>
<ul>
<li>NSOperationQueue可以方便的调用cancel方法来取消某个操作，而GCD中的任务是无法被取消的（安排好任务之后就不管了）。</li>
<li>NSOperation可以方便的指定操作间的依赖关系。</li>
<li>NSOperation可以通过KVO提供对NSOperation对象的精细控制（如监听当前操作是否被取消或是否已经完成等）</li>
<li>NSOperation可以方便的指定操作优先级。操作优先级表示此操作与队列中其它操作之间的优先关系，优先级高的操作先执行，优先级低的后执行。</li>
<li>通过自定义NSOperation的子类可以实现操作重用</li>
</ul>
<h5 id="18-请谈一谈，自定义操作的好处？"><a href="#18-请谈一谈，自定义操作的好处？" class="headerlink" title="18.请谈一谈，自定义操作的好处？"></a>18.请谈一谈，自定义操作的好处？</h5><ul>
<li>自定义操作，对操作进行封装，那么以后在使用的时候只需要alloc init即可，创建该操作的人不需要关系内部的代码实现，信息隐蔽。</li>
<li>自定义操作有助于代码重用</li>
</ul>
<h5 id="19-请简单介绍GCD中的一次性代码"><a href="#19-请简单介绍GCD中的一次性代码" class="headerlink" title="19.请简单介绍GCD中的一次性代码?"></a>19.请简单介绍GCD中的一次性代码?</h5><p>一次性代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line"></div><div class="line">        NSLog(@&quot;-------&quot;);</div><div class="line"></div><div class="line">     &#125;);</div></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>在整个程序运行过程中block中的代码只会被执行一次</li>
<li>一次性代码本身是线程安全的</li>
</ul>
<p>常用于单例模式的实现中</p>
<h5 id="20-GCD中的dispatch-after是延迟把任务提交到队列还是先提交到队列再延迟执行？"><a href="#20-GCD中的dispatch-after是延迟把任务提交到队列还是先提交到队列再延迟执行？" class="headerlink" title="20.GCD中的dispatch_after是延迟把任务提交到队列还是先提交到队列再延迟执行？"></a>20.GCD中的dispatch_after是延迟把任务提交到队列还是先提交到队列再延迟执行？</h5><p>是延迟之后在把任务提交到队列执行，把任务提交到队列中在延迟执行难度较大，不容易实现.</p>
<h5 id="21-请说明NSRunloop和线程的关系"><a href="#21-请说明NSRunloop和线程的关系" class="headerlink" title="21.请说明NSRunloop和线程的关系?"></a>21.请说明NSRunloop和线程的关系?</h5><ul>
<li>线程和runloop是一一对应的关系(字典)</li>
<li>主线程对应的runloop是默认创建并启动的</li>
<li>子线程对应的runloop需要手动的创建并启动</li>
<li>如何获得子线程对应的runloop?[NSRunloop currentRunloop]该方法是懒加载的,在第一次调用该方法的时候发现该子线程对应的runloop不存在则会直接创建一个runloop保存并且返回.</li>
<li>线程销毁后runloop也要销毁</li>
</ul>
<h4 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h4><h5 id="1-什么是runloop"><a href="#1-什么是runloop" class="headerlink" title="1.什么是runloop?"></a>1.什么是runloop?</h5><ul>
<li>从字面意思看：运行循环、跑圈.其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer）</li>
<li>一个线程对应一个RunLoop，主线程的RunLoop默认已经启动，子线程的RunLoop得手动启动（调用run方法）</li>
<li>RunLoop只能选择一个Mode启动，如果当前Mode中没何Source(Sources0、Sources1)、Timer，那么就直接退出RunLoop</li>
</ul>
<h5 id="2-runloop的自动释放池什么时候创建释放？"><a href="#2-runloop的自动释放池什么时候创建释放？" class="headerlink" title="2.runloop的自动释放池什么时候创建释放？"></a>2.runloop的自动释放池什么时候创建释放？</h5><ul>
<li>当runloop进入的时候会创建一个自动释放池。</li>
<li>当runloop退出的时候会把之前的自动释放池销毁。</li>
<li>当runloop即将进入休眠的时候会把之前的自动释放池先销毁，然后创建一个新的自动释放池。</li>
</ul>
<h5 id="3-请简单说明runloop中几个类之间的相互关系（runloop-amp-source-amp-timer-amp-observer-amp-mode）"><a href="#3-请简单说明runloop中几个类之间的相互关系（runloop-amp-source-amp-timer-amp-observer-amp-mode）" class="headerlink" title="3.请简单说明runloop中几个类之间的相互关系（runloop &amp; source &amp; timer &amp;observer &amp;mode）"></a>3.请简单说明runloop中几个类之间的相互关系（runloop &amp; source &amp; timer &amp;observer &amp;mode）</h5><ul>
<li>runloop启动之后会选择一种运行模式，在执行执行会先检查运行模式内部是否有source和timers,如果一个sourc或者是一个timer都没有那么runlooop启动之后就立刻退出了。</li>
<li>runlooop的source有两种分类方法，按照以前的分类方法可以分为：①基于端口的；②自定义的；③performSelector事件；④按照函数调用栈来划分，可以分为source0和soucr1。</li>
<li>observer，可以用来监听当前runloop运行状态的改变，注意（Core foundation框架）</li>
<li>NSTimer必须添加到runloop中才会工作，且其工作收到runloop运行模式的影响。</li>
</ul>
<h5 id="4-请简单说明NSRunloop的基本作用"><a href="#4-请简单说明NSRunloop的基本作用" class="headerlink" title="4.请简单说明NSRunloop的基本作用?"></a>4.请简单说明NSRunloop的基本作用?</h5><ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（比如触摸事件、定时器事件、Selector事件）</li>
<li>节省CPU资源，提高程序性能：该做事时做事，该休息时休息</li>
</ul>
<h4 id="缓存（SDWebImage）"><a href="#缓存（SDWebImage）" class="headerlink" title="缓存（SDWebImage）"></a>缓存（SDWebImage）</h4><h5 id="1-请简单说明NSCache的特点"><a href="#1-请简单说明NSCache的特点" class="headerlink" title="1.请简单说明NSCache的特点"></a>1.请简单说明NSCache的特点</h5><ul>
<li>NSCache是苹果推出专门用来处理内存缓存的类</li>
<li>NSCache默认是线程安全的,在使用的时候可以不用考虑线程安全的问题</li>
<li>NSCache使用方法和可变字典类似,当缓存文件超过最大限度的时候会开启一个回收过程,把最老的缓存对象回收</li>
<li>NSCache可以设置缓存的const(成本)和缓存的数量</li>
</ul>
<h5 id="2-请简单介绍下SDWebImage框架？"><a href="#2-请简单介绍下SDWebImage框架？" class="headerlink" title="2.请简单介绍下SDWebImage框架？"></a>2.请简单介绍下SDWebImage框架？</h5><ul>
<li>SDWebImage框架是一款非常流行的用来处理图片下载和缓存的第三方框架</li>
<li>SDWebImage框架为我们提供了高性能异步下载图片的方案，内部使用GCD等多线程相关技术</li>
<li>使用SDWebImage框架来下载图片，它内部默认会对图片进行内存缓存和磁盘缓存的二级缓存结构</li>
<li>该框架为UIButton,UIImageView等UI控件提供了分类，能够方便的处理相关控件图片的远程下载和缓存设置</li>
<li>该框架内部还提供了GIF图片播放，判断图片类型等一般功能</li>
</ul>
<h5 id="3-请问SDWebImage框架内部在清理磁盘缓存的时候clearDisk方法和cleanDisk方法有什么区别？"><a href="#3-请问SDWebImage框架内部在清理磁盘缓存的时候clearDisk方法和cleanDisk方法有什么区别？" class="headerlink" title="3.请问SDWebImage框架内部在清理磁盘缓存的时候clearDisk方法和cleanDisk方法有什么区别？"></a>3.请问SDWebImage框架内部在清理磁盘缓存的时候clearDisk方法和cleanDisk方法有什么区别？</h5><ul>
<li>clearDisk:直接把整个缓存文件删除，删除之后创建一个新的空文件;</li>
<li>cleanDisk:先删除过期的缓存文件，然后计算当前剩余缓存文件的大小,如果该数值超过设定的最大缓存大小，那么久安全文件创建的时间从远到近依次删除，直到整个剩余缓存文件大小小于设定的最大缓存大小为止。</li>
</ul>
<h5 id="4-请问SDWebImage框架的框架结构是怎么样的？"><a href="#4-请问SDWebImage框架的框架结构是怎么样的？" class="headerlink" title="4.请问SDWebImage框架的框架结构是怎么样的？"></a>4.请问SDWebImage框架的框架结构是怎么样的？</h5><p>SDWebImage框架有几个主要的组件：</p>
<ul>
<li>管理者（SDWebImageManager)</li>
<li>缓存处理组件（SDImageCache）主要对下载的图片进行内存缓存和磁盘缓存处理</li>
<li>下载处理组件（SDWebImageDownloader|SDWebImageDownloadOperation）主要处理开子线程异步发送网络请求下载图片相关操作</li>
</ul>
<h5 id="5-请问SDWebImage框架内部怎么处理内存缓存的？"><a href="#5-请问SDWebImage框架内部怎么处理内存缓存的？" class="headerlink" title="5.请问SDWebImage框架内部怎么处理内存缓存的？"></a>5.请问SDWebImage框架内部怎么处理内存缓存的？</h5><ul>
<li>内部使用NSCache来专门处理内存缓存</li>
</ul>
<h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h4><h5 id="1-请简单说明HTTP通信的过程？"><a href="#1-请简单说明HTTP通信的过程？" class="headerlink" title="1.请简单说明HTTP通信的过程？"></a>1.请简单说明HTTP通信的过程？</h5><ol>
<li>请求：如果客户端想要获得相应的数据，那么就对着服务器发送一个请求，请求是客户端向服务器索要数据的过程。</li>
<li>响应：服务器接收到客户端的请求之后，需要对该请求作出反应，响应是服务器端把数据返回给客户端的过程。</li>
<li>请求分为两部分，一个是请求头，一个是请求体（GET请求没有请求体）。其中请求头是对客户端信息和请求本身的描述，而请求体存放要发送给服务器端的具体数据</li>
<li>响应分为两部分，一个是响应头，一个是响应体。其中响应头是对服务器端信息和响应数据本身的描述，而响应体存放要发送给客户端的具体数据。</li>
</ol>
<h5 id="2-请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤"><a href="#2-请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤" class="headerlink" title="2.请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤?"></a>2.请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤?</h5><ol>
<li>确定请求路径（URL）</li>
<li>创建可变的请求对象（NSMutableURLRequest）</li>
<li>修改请求方法为POST请求</li>
<li>把参数拼接起来转换为二进制数据，设置请求体</li>
<li>使用NSURLConnection发送异步请求([NSURLConnection sendAsync….])</li>
<li>解析服务器返回的数据，查看请求结果</li>
</ol>
<h5 id="3-请简单说明使用NSURLConnection发送网络请求的几种方法？"><a href="#3-请简单说明使用NSURLConnection发送网络请求的几种方法？" class="headerlink" title="3.请简单说明使用NSURLConnection发送网络请求的几种方法？"></a>3.请简单说明使用NSURLConnection发送网络请求的几种方法？</h5><ul>
<li>使用NSURLConnection发送同步请求（[NSURLConnection sendSync….]）</li>
<li>使用NSURLConnection发送异步请求1（[NSURLConnection sendAsync…]）</li>
<li>使用NSURLConnection发送异步请求2（设置代理，再发送网络请求）</li>
</ul>
<h5 id="4-请简单说明GET请求和POST个请求有什么区别-如何选择？"><a href="#4-请简单说明GET请求和POST个请求有什么区别-如何选择？" class="headerlink" title="4.请简单说明GET请求和POST个请求有什么区别,如何选择？"></a>4.请简单说明GET请求和POST个请求有什么区别,如何选择？</h5><ul>
<li>GET请求的参数直接用&amp;拼接并以？为分隔拼接在请求URL的后面</li>
<li>POST请求的参数是转换为二进制设置在请求体传递的</li>
<li>如果仅仅只是索取数据获得数据，那么建议使用GET请求，其他情况则建议使用POST请求，相对而言POST请求安全性更好一些。</li>
</ul>
<h5 id="5-请简单说明NSURLSession对比NSURLConnection的优势？"><a href="#5-请简单说明NSURLSession对比NSURLConnection的优势？" class="headerlink" title="5.请简单说明NSURLSession对比NSURLConnection的优势？"></a>5.请简单说明NSURLSession对比NSURLConnection的优势？</h5><ul>
<li>session支持http2.0协议(iOS 9.0 +)</li>
<li>在处理下载任务的时候可以直接把数据下载到磁盘</li>
<li>支持后台下载|上传</li>
<li>同一个session发送多个请求，只需要建立一次连接（复用了TCP）</li>
<li>提供了全局的session并且可以统一配置，使用更加方便</li>
<li>下载的时候是多线程异步处理的效率更高</li>
</ul>
<h5 id="6-请简单列出NSURLSession发送POST请求的步骤？"><a href="#6-请简单列出NSURLSession发送POST请求的步骤？" class="headerlink" title="6.请简单列出NSURLSession发送POST请求的步骤？"></a>6.请简单列出NSURLSession发送POST请求的步骤？</h5><ol>
<li>确定请求路径(NSURL)</li>
<li>创建可变的请求对象(NSMutableURLRequest)</li>
<li>修改请求方法为POST(HTTPMethod)</li>
<li>把要传递的参数拼接，转换为二进制数据，设置为请求体(HTTPBody)</li>
<li>创建会话对象（NSURLSession shareSession）</li>
<li>根据会话对象来创建一个NSURLSessionDataTask任务</li>
<li>执行请求Task (需要调用Resume方法)</li>
<li>拿到服务器返回的数据之后，解析数据</li>
</ol>
<h5 id="7-在发送网络请求的时候，如果请求路径中的参数有中文导致发送的网络请求失败，应该如何处理？"><a href="#7-在发送网络请求的时候，如果请求路径中的参数有中文导致发送的网络请求失败，应该如何处理？" class="headerlink" title="7.在发送网络请求的时候，如果请求路径中的参数有中文导致发送的网络请求失败，应该如何处理？"></a>7.在发送网络请求的时候，如果请求路径中的参数有中文导致发送的网络请求失败，应该如何处理？</h5><ul>
<li>如果URL字符串中有中文，那么在进行使用发送请求的时候应该先对URL进行中文转码</li>
<li>相关方法：</li>
</ul>
<blockquote>
<p>[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]</p>
</blockquote>
<h5 id="8-观察下面的代码，请问completionHandler在主线程还是子线程执行？"><a href="#8-观察下面的代码，请问completionHandler在主线程还是子线程执行？" class="headerlink" title="8.观察下面的代码，请问completionHandler在主线程还是子线程执行？"></a>8.观察下面的代码，请问completionHandler在主线程还是子线程执行？</h5><p>[[session dataTaskWithRequest:request completionHandler:^(NSData <em> _Nullable data, NSURLResponse </em> _Nullable response, NSError * _Nullable error) {</p>
<pre><code>//....
</code></pre><p>}] resume];</p>
<ul>
<li>completionHandler在子线程中执行。</li>
</ul>
<h5 id="9-请简单介绍下网络响应的状态码？"><a href="#9-请简单介绍下网络响应的状态码？" class="headerlink" title="9.请简单介绍下网络响应的状态码？"></a>9.请简单介绍下网络响应的状态码？</h5><ul>
<li>状态码的职责是当客户端向服务器端发送请求时,描述返回的请求结果。借助状态码,用户可以知道服务器端是正常处理了请求还是出现了错误。</li>
<li>如200 OK状态码以3位数字+原因短语组成。数字中的第一位指定了响应的类别, 后两位无分类。</li>
<li><p>状态码分为五种类别，分别是：</p>
<pre><code>①以1开头的（如100），定义范围为100~101，表示接收的请求正在处理，原因短语为Informational(信息性状 态码)。

②以2开头的（如200），定义范围为200~206，表示请求正常处理完毕，原因短语为Success(成功状态码)。

③以3开头的（如300），定义范围为300~305，表示需要进行附加的操作以完成网络请求，原因短语为Redirection(重定向状态 码)。

④以4开头的（如404），定义范围为400~415，表示客户端有错误，服务器无法处理请求，原因短语为Client error(客户端错误)。

⑤以5开头的（如500），定义范围为500~505，表示服务器端处理请求出错，原因短语为Server error(服务器错误)。
</code></pre></li>
</ul>
<h5 id="10-使用NSURLSession发送网络请求的时候，最多可以建立多少个TCP连接？"><a href="#10-使用NSURLSession发送网络请求的时候，最多可以建立多少个TCP连接？" class="headerlink" title="10.使用NSURLSession发送网络请求的时候，最多可以建立多少个TCP连接？"></a>10.使用NSURLSession发送网络请求的时候，最多可以建立多少个TCP连接？</h5><ul>
<li>在iOS中最多可以建立4个连接，在OSX中默认最多可以建立6个连接。</li>
<li>在iOS中NSURLSessionConguration内部有HTTPMaximumConnectionsPerHost属性,可以设置连接的数 量:The default value is 6 in OS X, or 4 in iOS</li>
<li><p>说明：</p>
<pre><code> ①由于HTTP/1.1 不支持多路复用,因此如果要处理多个网络请求,在处理HTTP请求的时候 多数浏览器厂商都是不假思索的就在客户端排队所有的HTTP请求,然后通过一个持久连接,一个接着一个的发送这些请求。然而这种方式性能实在太差。实际上,浏览器开发商对于对于此性能问题,尚没有任何更好的办法,因此只能允许客户端并行打开多个TCP连接会话。但是具体最多可以打开多少个TCP连接是有数量限制的, 多数现代的浏览器,包括桌面和移动浏览器,都支持打开6个连接。即客户端可以并行分派最多6个请求,服务器可以并行处理最多6个请求。

②为什么是6个连接?有什么特殊的意义吗?其实，这个数字是多方平衡后的结果:这个数字越大,便能够带来更多的请求并行能力,但是同样的客户端和服务器端所占用的资源也会越多。因此,每个主机6个连接只不过是大家都觉得比较安全,能够接受的一个数字而已。
</code></pre></li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="1-请简单介绍JSON和XML？"><a href="#1-请简单介绍JSON和XML？" class="headerlink" title="1.请简单介绍JSON和XML？"></a>1.请简单介绍JSON和XML？</h5><ul>
<li>JSON和XML都是一种用来表示数据的一种数据格式，JSON更加轻量级。</li>
<li>服务器返回的数据通常是JSON的或者是XML的两种，JSON数据格式和OC对象中字典和数组有些相似，XML又称为XML文档，XML的语法结构由三部分构成分别是文档声明，元素和属性。</li>
<li>如果服务器返回的数据是JSON，那么在开发中通常需要对JSON数据进行反序列化处理，把JSON数据转换为OC对象。</li>
<li>如果服务器返回的数据是XML格式的，那么需要对XML文档进行解析，解析XML的方式有两种，分别是SAX（从根元素开始解析）和DOM(先把整个XML文档加载进内存再解析)</li>
</ul>
<h5 id="2-JSON格式中的true和false-对应OC中的什么数据类型，值为多少？"><a href="#2-JSON格式中的true和false-对应OC中的什么数据类型，值为多少？" class="headerlink" title="2.JSON格式中的true和false,对应OC中的什么数据类型，值为多少？"></a>2.JSON格式中的true和false,对应OC中的什么数据类型，值为多少？</h5><ul>
<li>true和false对应OC中的NSNumber数据类型</li>
<li>true对应的值为1，false对应的值为0</li>
</ul>
<h5 id="3-请简单说明什么是序列化和反序列处理，用到了什么方法？"><a href="#3-请简单说明什么是序列化和反序列处理，用到了什么方法？" class="headerlink" title="3.请简单说明什么是序列化和反序列处理，用到了什么方法？"></a>3.请简单说明什么是序列化和反序列处理，用到了什么方法？</h5><ul>
<li>反序列化处理，即把JSON数据—&gt;OC对象，使用的方法为：[NSJSONSerialization JSONObjectWithData:jsonData options:kNilOptions error:nil]</li>
<li>序列化处理，即把OC对象—&gt;JSON数据，使用的方法为：[NSJSONSerialization dataWithJSONObject:jsonString options:0 error:nil],注意并不是所有的OC对象都能够序列化为JSON数据</li>
</ul>
<h4 id="文件下载与上传"><a href="#文件下载与上传" class="headerlink" title="文件下载与上传"></a>文件下载与上传</h4><h5 id="1-请简单说明输出流的使用步骤【应用于文件下载时】和注意点？"><a href="#1-请简单说明输出流的使用步骤【应用于文件下载时】和注意点？" class="headerlink" title="1.请简单说明输出流的使用步骤【应用于文件下载时】和注意点？"></a>1.请简单说明输出流的使用步骤【应用于文件下载时】和注意点？</h5><p>使用步骤：</p>
<ol>
<li>创建输出流（指定路径）</li>
<li>打开输出流（open）</li>
<li>使用输出流写数据 （write…）</li>
<li>关闭输出流 （close）</li>
</ol>
<p>注意点：数据写完之后一定要关闭输出流</p>
<h5 id="2-请简单说明文件句柄（NSFileHandle）的使用步骤【应用于文件下载时】和注意点？"><a href="#2-请简单说明文件句柄（NSFileHandle）的使用步骤【应用于文件下载时】和注意点？" class="headerlink" title="2.请简单说明文件句柄（NSFileHandle）的使用步骤【应用于文件下载时】和注意点？"></a>2.请简单说明文件句柄（NSFileHandle）的使用步骤【应用于文件下载时】和注意点？</h5><p>使用步骤：</p>
<ul>
<li>创建空的文件（路径）</li>
<li>创建文件句柄（指向文件） 默认指向开头</li>
<li>使用文件句柄来写数据（内部边写数据边移动文件句柄指针）</li>
<li>关闭文件句柄(closeFile)</li>
<li>注意点：①在写使用文件句柄指针写数据的时候，内部会自动移动文件句柄指针；②写数据的时候可以设置位置（偏移量），如设置从文件的末尾接着写数据；③使用完毕之后，应该把句柄关闭</li>
</ul>
<h5 id="3-请简单介绍下NSURLSessionTask的几个子类？"><a href="#3-请简单介绍下NSURLSessionTask的几个子类？" class="headerlink" title="3.请简单介绍下NSURLSessionTask的几个子类？"></a>3.请简单介绍下NSURLSessionTask的几个子类？</h5><ul>
<li>NSURLSessionTask是一个抽象类，如果要使用那么只能使用它的子类;</li>
<li>NSURLSessionTask有两个子类，一个是NSURLSessionDataTask,该task可以用来处理一般的网络请求，如GET|POST请求等，一个是NSURLSessionDownloadTask,该downloadTask在处理下载请求的时候有很大的优势;</li>
<li>NSURLSessionDataTask有一个子类为NSURLSessionUploadTask,该uploadTask在处理上传请求的时候有优势.</li>
</ul>
<ul>
<li>为-fno-objc-arc即可。</li>
</ul>
<h5 id="4-在使用NSURLSessionDataTask发送请求下载文件的时候，实现断点下载的技术要点是什么？"><a href="#4-在使用NSURLSessionDataTask发送请求下载文件的时候，实现断点下载的技术要点是什么？" class="headerlink" title="4.在使用NSURLSessionDataTask发送请求下载文件的时候，实现断点下载的技术要点是什么？"></a>4.在使用NSURLSessionDataTask发送请求下载文件的时候，实现断点下载的技术要点是什么？</h5><ul>
<li>所谓断点下载，即只下载完整文件中的某一部分数据，如该文件有10M，那么需要做到只请求下载这个文件中5M~10M的这部分数据</li>
<li>可以通过设置请求头信息来实现，参考代码如下：</li>
</ul>
<blockquote>
<p> NSString *header = [NSString stringWithFormat:@”bytes=%zd-“,self.currentSize];</p>
<p> [request setValue:header forHTTPHeaderField:@”Range”]</p>
</blockquote>
<h5 id="5-请简单比较使用NSURLSessionDownloadTask下载文件和使用NSURLSessionDataTask下载文件的优劣？"><a href="#5-请简单比较使用NSURLSessionDownloadTask下载文件和使用NSURLSessionDataTask下载文件的优劣？" class="headerlink" title="5.请简单比较使用NSURLSessionDownloadTask下载文件和使用NSURLSessionDataTask下载文件的优劣？"></a>5.请简单比较使用NSURLSessionDownloadTask下载文件和使用NSURLSessionDataTask下载文件的优劣？</h5><ul>
<li>NSURLSessionDataTask下载文件的</li>
</ul>
<p>优点：可以实现离线断点下载。</p>
<p>缺点：代码复杂</p>
<ul>
<li>NSURLSessionDownloadTask下载文件的</li>
</ul>
<p>优点：①内部已经完成了边接收数据边写入到沙盒中的操作（解决了下载大文件时候的内存飙升问题）；②可以方便的实现断点下载。</p>
<p>缺点：无法实现离线断点下载</p>
<h5 id="6-请列出使用NSURLSession发送请求实现文件上传的主要步骤？"><a href="#6-请列出使用NSURLSession发送请求实现文件上传的主要步骤？" class="headerlink" title="6.请列出使用NSURLSession发送请求实现文件上传的主要步骤？"></a>6.请列出使用NSURLSession发送请求实现文件上传的主要步骤？</h5><ol>
<li>确定上传请求的路径 （NSURL）</li>
<li>创建可变的请求对象（NSMutableURLRequest）</li>
<li>修改请求方法为POST</li>
<li>设置请求头信息（告知服务器端这是一个文件上传请求）</li>
<li>按照固定的格式拼接要上传的文件等参数</li>
<li>根据请求对象创建会话对象（NSURLSession对象）</li>
<li>根据session对象来创建一个uploadTask上传请求任务</li>
<li>执行该上传请求任务（调用resume方法）</li>
<li>得到服务器返回的数据，解析数据（上传成功|上传失败）</li>
</ol>
<h5 id="7-请列出你认为在进行文件上传时候需要注意的细节-注意点-？"><a href="#7-请列出你认为在进行文件上传时候需要注意的细节-注意点-？" class="headerlink" title="7.请列出你认为在进行文件上传时候需要注意的细节(注意点)？"></a>7.请列出你认为在进行文件上传时候需要注意的细节(注意点)？</h5><ol>
<li>创建可变的请求对象，因为需要修改请求方法为POST，设置请求头信息</li>
<li>设置请求头这个步骤可能会被遗漏</li>
<li>要处理上传参数的时候，一定要按照固定的格式来进行拼接</li>
<li>需要采用合适的方法来获得上传文件的二进制数据类型（MIMEType）</li>
</ol>
<h5 id="8-在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？"><a href="#8-在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？" class="headerlink" title="8.在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？"></a>8.在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？</h5><ul>
<li>创建会话对象的时候，需要设置代理，让控制器成为session的代理</li>
<li>遵守代理协议（NSURLSessionDataDelegate）</li>
<li>实现代理方法，在代理方法中计算文件的上传进度</li>
</ul>
<blockquote>
<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task

didSendBodyData:(int64_t)bytesSent

totalBytesSent:(int64_t)totalBytesSent

totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
</code></pre></blockquote>
<ul>
<li>注意：当任务执行完毕的时候应该释放对代理对象的强引用</li>
</ul>
<h4 id="网路通信安全"><a href="#网路通信安全" class="headerlink" title="网路通信安全"></a>网路通信安全</h4><h5 id="1-请简单回答网络安全的原则是什么？"><a href="#1-请简单回答网络安全的原则是什么？" class="headerlink" title="1.请简单回答网络安全的原则是什么？"></a>1.请简单回答网络安全的原则是什么？</h5><ul>
<li>在网络上”不允许”传输用户隐私数据的”明文”</li>
<li>在本地”不允许”保存用户隐私数据的”明文”</li>
</ul>
<h5 id="2-请简单介绍下Base64编码？"><a href="#2-请简单介绍下Base64编码？" class="headerlink" title="2.请简单介绍下Base64编码？"></a>2.请简单介绍下Base64编码？</h5><ul>
<li>特点：可以将任意的二进制数据进行Base64编码</li>
<li>结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。65字符：A~Z a~z 0~9 + / =</li>
<li>对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。</li>
</ul>
<p>Base64编码原理:①将所有字符转化为ASCII码；②将ASCII码转化为8位二进制；③将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位；④统一在6位二进制前补两个0凑足8位；⑤将补0后的二进制转为十进制；⑥从Base64编码表获取十进制对应的Base64编码。</p>
<h5 id="3-请简单说明单向散列函数的特点？"><a href="#3-请简单说明单向散列函数的特点？" class="headerlink" title="3.请简单说明单向散列函数的特点？"></a>3.请简单说明单向散列函数的特点？</h5><ul>
<li>加密后密文的长度是定长的</li>
<li>如果明文不一样，那么散列后的结果一定不一样</li>
<li>如果明文一样，那么加密后的密文一定一样（对相同数据加密，加密后的密文一样）</li>
<li>所有的加密算法是公开的</li>
<li>不可以逆推反算</li>
</ul>
<p>总结：</p>
<ol>
<li>不可逆</li>
<li>原文相同 散列值相同</li>
<li>原文不同 散列值不同</li>
<li>加密后密文的长度是定长的</li>
</ol>
<h5 id="4-请简单介绍下散列函数的一些应用领域？"><a href="#4-请简单介绍下散列函数的一些应用领域？" class="headerlink" title="4.请简单介绍下散列函数的一些应用领域？"></a>4.请简单介绍下散列函数的一些应用领域？</h5><ol>
<li>搜索 多个关键字，先对每个关键字进行散列，然后多个关键字进行或运算，如果值一致则搜索结果一致</li>
<li>版权 对文件进行散列判断该文件是否是正版或原版的</li>
<li>文件完整性验证 对整个文件进行散列，比较散列值判断文件是否完整或被篡改</li>
</ol>
<h5 id="5-请简单介绍下对称加密的特点和经典算法？"><a href="#5-请简单介绍下对称加密的特点和经典算法？" class="headerlink" title="5.请简单介绍下对称加密的特点和经典算法？"></a>5.请简单介绍下对称加密的特点和经典算法？</h5><p>特点:</p>
<ul>
<li>加密和解密使用相同的秘钥</li>
<li>加密和解密的过程是可逆的</li>
<li>性能好，效率高</li>
</ul>
<p>经典算法</p>
<ul>
<li>DES 数据加密标准</li>
<li>3DES 使用3个密钥，对消息进行（密钥1·加密）+（密钥2·解密）+（密钥3·加密）</li>
<li>AES 高级加密标准</li>
</ul>
<h5 id="6-请简单说明ECB和CBC两种分组加密模式？"><a href="#6-请简单说明ECB和CBC两种分组加密模式？" class="headerlink" title="6.请简单说明ECB和CBC两种分组加密模式？"></a>6.请简单说明ECB和CBC两种分组加密模式？</h5><ul>
<li>ECB模式的全称为Electronic CodeBook模式。又成为电子密码本模式。</li>
</ul>
<p>特点：①使用ECB模式加密的时候，相同的明文分组会被转换为相同的密文分组；②类似于一个巨大的明文分组——密文分组的对照表。</p>
<ul>
<li>CBC模式全称为Cipher Block Chainning模式（密文分组链接模式|电子密码链条）</li>
</ul>
<p>特点：在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。</p>
<h5 id="7-请简单介绍下非对称加密的特点和经典算法？"><a href="#7-请简单介绍下非对称加密的特点和经典算法？" class="headerlink" title="7.请简单介绍下非对称加密的特点和经典算法？"></a>7.请简单介绍下非对称加密的特点和经典算法？</h5><ul>
<li>非对称加密的特点: ①使用一个密钥对进行加密和解密，公钥加密，私钥解密；②公钥是公开的，私钥是保密的；③使用非对称加密来处理加密和解密的过程高度安全，但是效率低下，性能很差</li>
<li>经典算法：RSA</li>
</ul>
<h5 id="8-请简单介绍下数字签名这门技术？"><a href="#8-请简单介绍下数字签名这门技术？" class="headerlink" title="8.请简单介绍下数字签名这门技术？"></a>8.请简单介绍下数字签名这门技术？</h5><ul>
<li>应用场景：需要严格验证发送方身份信息情况</li>
<li><p>数字签名原理</p>
<pre><code>客户端处理

      1.对&quot;消息&quot;进行 HASH 得到 &quot;消息摘要&quot;

      2.发送方使用自己的私钥对&quot;消息摘要&quot; 加密(数字签名)

      3.把数字签名附着在&quot;报文&quot;的末尾一起发送给接收方

 服务端处理

      1.对&quot;消息&quot; HASH 得到 &quot;报文摘要&quot;

      2.使用公钥对&quot;数字签名&quot; 解密

      3.对结果进行匹配
</code></pre></li>
</ul>
<h5 id="9-数字证书和公钥什么关系？"><a href="#9-数字证书和公钥什么关系？" class="headerlink" title="9.数字证书和公钥什么关系？"></a>9.数字证书和公钥什么关系？</h5><ul>
<li>数字证书就是对公钥进行数字签名</li>
<li>证书和驾照很相似，里面记有姓名、组织、地址等个人信息，以及属于此人的公钥，并有认证机构施加数字签名,只要看到公钥证书，我们就可以知道认证机构认证该公钥的确属于此人</li>
<li>数字证书的主要内容：①公钥；②认证机构的数字签名</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/17/面试知识点总结/" data-id="cj46tfgzh0038o3s6veq7pexn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-测试添加视频" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/14/测试添加视频/" class="article-date">
  <time datetime="2017-01-14T14:58:01.000Z" itemprop="datePublished">2017-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工具/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/14/测试添加视频/">测试添加视频</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <iframe marginwidth="0" marginheight="0" src="http://player.youku.com/embed/XMTU3NTgxNjkzMg==" frameborder="0" width="900" scrolling="no" height="600" allowtransparency=""><br></iframe>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/14/测试添加视频/" data-id="cj46tfgyt0026o3s64bfe0i8o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文字/">文字</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hexo博客添加图片、音乐、视频" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/13/Hexo博客添加图片、音乐、视频/" class="article-date">
  <time datetime="2017-01-13T09:19:41.000Z" itemprop="datePublished">2017-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工具/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/13/Hexo博客添加图片、音乐、视频/">Hexo博客添加图片、音乐、视频</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hexo博客添加图片、音乐、视频  ———— “临渊羡鱼，不如退而结网”</p>
<h4 id="一、添加图片"><a href="#一、添加图片" class="headerlink" title="一、添加图片"></a>一、添加图片</h4><p>既可以是本地图片 ，也可以是添加外部链接图片</p>
<h5 id="1、本地图片"><a href="#1、本地图片" class="headerlink" title="1、本地图片"></a>1、本地图片</h5><p>在\hexo\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式：<br><img src="https://ww4.sinaimg.cn/large/006y8lVagw1fbp57cq9wqj30lo01i748.jpg" alt=""></p>
<h5 id="2、外链图片"><a href="#2、外链图片" class="headerlink" title="2、外链图片"></a>2、外链图片</h5><h5 id="可以使用-iPic-上传图片"><a href="#可以使用-iPic-上传图片" class="headerlink" title="可以使用 iPic 上传图片"></a><a href="http://blog.chaiyahang.com/2016/12/24/Markdown%E5%BC%80%E5%90%AF%E7%BC%96%E8%BE%91%E6%96%B0%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">可以使用 iPic 上传图片</a></h5><p><img src="https://ww2.sinaimg.cn/large/006y8lValy1fbp58lvdtfj30f601i745.jpg" alt=""></p>
<h4 id="二、添加音乐"><a href="#二、添加音乐" class="headerlink" title="二、添加音乐"></a>二、添加音乐</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> </span></div><div class="line">    <span class="attr">src</span>=<span class="string">"http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>    </div><div class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></div></pre></td></tr></table></figure>
<center><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" ​="" src="http://music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"><br></iframe><br></center>

<h4 id="三、添加视频"><a href="#三、添加视频" class="headerlink" title="三、添加视频"></a>三、添加视频</h4><p>视频也和音乐类似，先输入视频标题，回车换一行插入代码即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">"2017小米年会雷军跳鬼步舞视频:"</div><div class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">498</span> <span class="attr">width</span>=<span class="string">510</span> <span class="attr">src</span>=<span class="string">"http://t.cn/z8AluUz http://t.cn/RMSFvPU"</span> <span class="attr">frameborder</span>=<span class="string">0</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">"2017小米年会爆笑神曲“咋了开发”:"</div><div class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">498</span> <span class="attr">width</span>=<span class="string">510</span> <span class="attr">src</span>=<span class="string">"http://www.toutiao.com/i6374714213071323650/"</span> <span class="attr">frameborder</span>=<span class="string">0</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/13/Hexo博客添加图片、音乐、视频/" data-id="cj46tfgws0008o3s6bk3fbmbu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文字/">文字</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-《好吗-好的》随笔" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/04/《好吗-好的》随笔/" class="article-date">
  <time datetime="2017-01-04T08:14:24.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/小说/">小说</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/04/《好吗-好的》随笔/">《好吗 好的》随笔</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好吗好的 </p>
<p>书评：</p>
<p>刘敏常说，只要你对得起舞台，舞台就会对得起你。</p>
<p>你是否也有过那种错觉：</p>
<p>牵手的人不会松手，同路的人不会分开，缓缓流淌的岁月永不会改道，昨天和今天所拥有的，总会顺理成章地延续到明天，乃至永远。</p>
<p>世间最大的错觉，无外乎自以为是的永远。</p>
<p>世上大部分永远，大都是一厢情愿的错觉。</p>
<p>万事万物走的都是抛物线，并没有恒久的低谷或顶点，转折点出现时，我和她已搭档了很多年。</p>
<p>她转身，看我一眼，又移开目光。头再转过来时，双臂也轻轻展开在我面前，平静的目光注视着我，她轻声说：过来……</p>
<p>我又惊讶又好笑，上前接住那个拥抱：干吗，好好的抱我干吗？你什么时候学得这么矫情了？</p>
<p>她不说话，手轻轻拍在我背上，一下又一下，身体也轻轻地左右摇晃着，好像个哄孩子睡觉的年轻妈妈。我笑，拜托，别老把我当小朋友好吗？我眼瞅快30岁的人了。</p>
<p>她笑笑松开我，说：好了好了，走了走了。</p>
<p>没有告别，她只要走了一个拥抱，平静的目光注视着我，双臂轻轻展开在我面前，她轻声说：过来……</p>
<p>##########附录###########</p>
<p>早班地铁挤满了上班的人，座位紧张，她不善争，像个农民工一样蹲坐在地上……有观众认出了她，拍下了照片在网络上传给我，我问，为什么不给她让个座？！</p>
<p>那位观众说让了，她谢了半天，但怎么也不肯坐……她说如果一大清早就安逸了，接下来一整天的斗志也就全没了。</p>
<p>你我的旧时光，如那漫漫长路，永不消亡</p>
<p>我们俩披着雨衣，屋檐下伫立，阳光在上</p>
<p>你们长大了，我们也该谢幕了。</p>
<p>就用这篇文章，最后送你们一程吧：</p>
<p>祝你永不孤独。</p>
<p>祝你过得好。</p>
<p>祝你阳光快车道。</p>
<p>别人的经验与你的人生无关。</p>
<p>同理，我笔下的故事桥段，与你脚下的人生也无关。</p>
<p>自己去尝试，自己去选择吧，先尝试，再选择，认准方向后，作死地撑住，边撑边掌握平衡。</p>
<p>平行世界，多元生活，既可以朝九晚五，又能够浪迹天涯。</p>
<p>愿你知行合一，愿你能心安。</p>
<p>好吗好的。</p>
<p>………… 写于：2016年11月09日13:55:34</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=202373&auto=0&height=66"></iframe>



<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=436514312&auto=1&height=66"></iframe>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/04/《好吗-好的》随笔/" data-id="cj46tfgy7001ko3s62oxtumij" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文字/">文字</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读《嫌疑人X的献身》所写" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/04/读《嫌疑人X的献身》所写/" class="article-date">
  <time datetime="2017-01-04T07:59:29.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/小说/">小说</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/04/读《嫌疑人X的献身》所写/">读《嫌疑人X的献身》所写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>东野圭吾于1999年以《<a href="https://zh.wikipedia.org/wiki/%E7%A7%98%E5%AF%86_(%E5%B0%8F%E8%AF%B4" target="_blank" rel="external">秘密</a>)》获第52届<a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E6%8E%A8%E7%90%86%E4%BD%9C%E5%AE%B6%E5%8D%94%E6%9C%83%E7%8D%8E" target="_blank" rel="external">日本推理作家协会奖</a>，2006年以《<a href="https://zh.wikipedia.org/wiki/%E5%AB%8C%E7%96%91%E7%8A%AFX%E7%9A%84%E7%8D%BB%E8%BA%AB" target="_blank" rel="external">嫌疑人X的献身</a>》获第134届<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%9C%A8%E8%B3%9E" target="_blank" rel="external">直木赏</a>和<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E6%A0%BC%E6%8E%A8%E7%90%86%E5%A4%A7%E7%8D%8E" target="_blank" rel="external">本格推理大奖</a>，此书并一举拿下当年度三大推理小说排行榜——“<a href="https://zh.wikipedia.org/wiki/%E3%80%8C%E9%80%99%E6%9C%AC%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AA%AA%E4%BA%86%E4%B8%8D%E8%B5%B7%EF%BC%81%E3%80%8D%E5%A4%A7%E7%8D%8E" target="_blank" rel="external">‘这本推理小说了不起！’</a>”、《<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E6%A0%BC%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AA%AA_Best_10" target="_blank" rel="external">本格推理小说 Best 10</a>》和“<a href="https://zh.wikipedia.org/wiki/%E9%80%B1%E5%88%8A%E6%96%87%E6%98%A5%E6%8E%A8%E7%90%86%E5%B0%8F%E8%AA%AA_Best_10" target="_blank" rel="external">周刊文春推理小说 Best 10</a>”的第一名，故有三冠王之称。</p>
<p>东野圭吾《嫌疑人X的献身》感悟：</p>
<p>整个案件的起源是一对离婚夫妇之间男方纠缠不清的蛮横无理，跌宕之处在数学家出手相助于长久以来暗恋的隔壁女郎，然后情节跌宕起伏于警察和数学家的较量，最后铺垫于物理学家与数学家脑力之间的博弈……</p>
<p>“看起来是几何问题，其实是函数问题”</p>
<p>警察喜好攻心术，物理学家喜欢演绎推理，观察细致入微，洞悉人性的弱点……</p>
<p>石神说，“之前你问过我一个我问题：设计别人解不开的问题和解开那个问题，何者更难——你还记得吗?”</p>
<p>汤川学说，“我的答案是，设计问题更难。我向来认为，解答者应该对出题者心怀敬意。”</p>
<p>石神问，那“P≠NP呢？自己想出答案和确认别人的答案是否正确，何者较容易？”</p>
<p>汤川学一脸懵逼……^_^</p>
<p>石神说“你一定先自己解答，再听别人的答案”</p>
<p>为心爱之人掩饰一桩杀人案，不惜再犯下一桩命案——天底下真有这样痴情的人</p>
<p>流浪游民换上被调查对象（也就是死者，当然并非游民这个死者）也就和之前拿着肖像画询问车展人员，有关人士反映见过此人（穿着一样）但并非此人一语衔接的天衣无缝……佩服东野圭吾🙏</p>
<p>这个世上没有无用的齿轮，也只有齿轮自己才能决定自己的用途！只有高手间才能明白的对话……</p>
<p>至此，乃智力和脑力的双重博弈🔛</p>
<p>汤川学的推理确实让常人难以想象，合情合理，于细微察之言，观之色！</p>
<p>至此，考试（补考）期间和警察的对话起到了决定性的作用：看似几何问题，其实是函数问题。这句话石神把自己埋了（也唯有高手-物理学家-汤川学才能明白）看似不在场证明，核心其实在隐瞒死者身份。</p>
<p>东野的写作手法巧妙无比，人物、身份、介绍、地点等等恰如其分切入读者的心中……&amp;</p>
<p>两个天才的对决……脑海中，挥之不去…</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwgw1fbenoy93sej30k00zkjs8.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/04/读《嫌疑人X的献身》所写/" data-id="cj46tfgzf0034o3s6ii2axngf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文字/">文字</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">ios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/图片/">图片</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小说/">小说</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率/">效率</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文字/">文字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/网络/iOS/">iOS</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Authentication/">Authentication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CGRect/">CGRect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NSURLRequest/">NSURLRequest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TouchID/">TouchID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/下载插件/">下载插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/不甘示弱/">不甘示弱</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/仓央嘉措/">仓央嘉措</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/偈子/">偈子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/南工/">南工</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/屏蔽广告/">屏蔽广告</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/悔恨/">悔恨</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/我的母校/">我的母校</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/执子之手，共你一世风霜/">执子之手，共你一世风霜</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文史/">文史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文字/">文字</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文学/">文学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/梦溪湖/">梦溪湖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/湘西王/">湘西王</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生命/">生命</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网页歌曲/">网页歌曲</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网页视频/">网页视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/表单上传/">表单上传</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/西原/">西原</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/见或不见/">见或不见</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/认真的雪/">认真的雪</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/陈渠珍/">陈渠珍</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Authentication/" style="font-size: 10px;">Authentication</a> <a href="/tags/CGRect/" style="font-size: 10px;">CGRect</a> <a href="/tags/NSURLRequest/" style="font-size: 10px;">NSURLRequest</a> <a href="/tags/Objective-C/" style="font-size: 13.33px;">Objective-C</a> <a href="/tags/TouchID/" style="font-size: 10px;">TouchID</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/下载插件/" style="font-size: 10px;">下载插件</a> <a href="/tags/不甘示弱/" style="font-size: 10px;">不甘示弱</a> <a href="/tags/仓央嘉措/" style="font-size: 10px;">仓央嘉措</a> <a href="/tags/偈子/" style="font-size: 10px;">偈子</a> <a href="/tags/南工/" style="font-size: 10px;">南工</a> <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/屏蔽广告/" style="font-size: 10px;">屏蔽广告</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/悔恨/" style="font-size: 10px;">悔恨</a> <a href="/tags/我的母校/" style="font-size: 10px;">我的母校</a> <a href="/tags/执子之手，共你一世风霜/" style="font-size: 10px;">执子之手，共你一世风霜</a> <a href="/tags/文史/" style="font-size: 10px;">文史</a> <a href="/tags/文字/" style="font-size: 16.67px;">文字</a> <a href="/tags/文学/" style="font-size: 10px;">文学</a> <a href="/tags/梦溪湖/" style="font-size: 10px;">梦溪湖</a> <a href="/tags/湘西王/" style="font-size: 10px;">湘西王</a> <a href="/tags/生命/" style="font-size: 10px;">生命</a> <a href="/tags/网页歌曲/" style="font-size: 10px;">网页歌曲</a> <a href="/tags/网页视频/" style="font-size: 10px;">网页视频</a> <a href="/tags/表单上传/" style="font-size: 10px;">表单上传</a> <a href="/tags/西原/" style="font-size: 10px;">西原</a> <a href="/tags/见或不见/" style="font-size: 10px;">见或不见</a> <a href="/tags/认真的雪/" style="font-size: 10px;">认真的雪</a> <a href="/tags/陈渠珍/" style="font-size: 10px;">陈渠珍</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/25/iOS推送机制/">iOS推送机制</a>
          </li>
        
          <li>
            <a href="/2017/03/21/ios应用程序的生命周期/"> ios应用程序的生命周期</a>
          </li>
        
          <li>
            <a href="/2017/03/20/OC内存管理/">OC内存管理</a>
          </li>
        
          <li>
            <a href="/2017/03/19/3·15晚会/">3·15晚会</a>
          </li>
        
          <li>
            <a href="/2017/03/17/NSString属性什么时候用copy，什么时候用strong/">NSString属性什么时候用copy，什么时候用strong?</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 柴亚航<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>