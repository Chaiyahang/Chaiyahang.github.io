<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[项目范围管理笔记整理]]></title>
      <url>%2F2017%2F07%2F15%2F%E9%A1%B9%E7%9B%AE%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[2015 年 OSC 北京源创会年终盛典全程视频]]></title>
      <url>%2F2017%2F07%2F11%2F2015-%E5%B9%B4-OSC-%E5%8C%97%E4%BA%AC%E6%BA%90%E5%88%9B%E4%BC%9A%E5%B9%B4%E7%BB%88%E7%9B%9B%E5%85%B8%E5%85%A8%E7%A8%8B%E8%A7%86%E9%A2%91%2F</url>
      <content type="text"><![CDATA[2015 年 OSC 北京源创会年终盛典全程视频： 主会场 分会场综合分会场1 综合分会场2 运维分会场1 运维分会场2 存储分会场1 存储分会场2 移动分会场1 移动分会场2 容器和微服务分会场1 容器和微服务分会场2 转自——http://www.oschina.net/question/865233_2145334]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC经常使用的函数~总结如下]]></title>
      <url>%2F2017%2F07%2F10%2FOC%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0-%E6%80%BB%E7%BB%93%E5%A6%82%E4%B8%8B%2F</url>
      <content type="text"><![CDATA[1、 三角函数 double sin (double);正弦 double cos (double);余弦 double tan (double);正切 2 、反三角函数 double asin (double); 结果介于[-PI/2, PI/2] double acos (double); 结果介于[0, PI] double atan (double); 反正切(主值), 结果介于[-PI/2, PI/2] double atan2 (double, double); 反正切(整圆值), 结果介于[-PI, PI] 3 、双曲三角函数 double sinh (double); double cosh (double); double tanh (double); 4 、指数与对数 double exp (double);求取自然数e的幂 double sqrt (double);开平方 double log (double); 以e为底的对数 double log10 (double);以10为底的对数 double pow(double x, double y）;计算以x为底数的y次幂 float powf(float x, float y); 功能与pow一致，只是输入与输出皆为浮点数 5 、取整 （上下取整） double ceil (double); 上取整 double floor (double); 下取整 6 、绝对值 double fabs (double);求绝对值 double cabs(struct complex znum) ;求复数的绝对值 7 、标准化浮点数 double frexp (double f, int p); 标准化浮点数, f = x 2^p, 已知f求x, p ( x介于[0.5, 1] ) double ldexp (double x, int p); 与frexp相反, 已知x, p求f 8 、取整与取余 double modf (double, double*); 将参数的整数部分通过指针回传, 返回小数部分 double fmod (double, double); 返回两参数相除的余数 123456789101112RN 当中的取整 和 取余：举例说明：(九宫格布局 行和列)//1.定义相关常量(总列数,商品宽度,高度)const cols = 3,shopW = 100,shopH = 120;//2.取出下标var index = this.state.shopArray.length;//3.根据下标求出行数列数 求行是用下标数 对列 取整，求列是下标数 对列 取余。var row = parseInt(index / cols);var col = parseInt(index % cols); 9 、其他 不常用函数 double hypot(double x, double y);已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x, int exponent);计算x(2的exponent次幂) double poly(double x, int degree, double coeffs [] );计算多项式 nt matherr(struct exception e);数学错误计算处理程序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode算法题NumberOne]]></title>
      <url>%2F2017%2F07%2F05%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98NumberOne%2F</url>
      <content type="text"><![CDATA[Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 我的方案如下： 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // NSMutableArray *integerArray = [NSMutableArray arrayWithArray:@[@0,@2,@3,@4,@5,@6,@7,@9]]; NSMutableArray *integerArray = [NSMutableArray arrayWithArray:@[@2,@7,@11,@5]]; NSInteger target = 9; NSMutableArray *resultIndexArray = [NSMutableArray arrayWithCapacity:1]; TICK(resultIndexArray) for (NSInteger i = 0; i &lt; integerArray.count; i ++) &#123; NSInteger pre = [[integerArray objectAtIndex:i] integerValue]; for (NSInteger j = (i + 1); j &lt; (integerArray.count); j ++) &#123; NSInteger next = [[integerArray objectAtIndex:j] integerValue]; if ((pre + next) == target) &#123; [resultIndexArray addObject:[NSArray arrayWithObjects:@(i),@(j), nil]]; &#125; &#125; &#125; TOCK(resultIndexArray) NSLog(@&quot;resultIndexArray : %@&quot;,resultIndexArray); &#125; 暂时未在 LeedCode 验证]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用 SQL 语句]]></title>
      <url>%2F2017%2F07%2F04%2F%E5%B8%B8%E7%94%A8-SQL-%E8%AF%AD%E5%8F%A5%2F</url>
      <content type="text"><![CDATA[一、基础 说明：创建数据库 CREATE DATABASE dbname 说明：删除数据库 drop database dbname 说明：创建新表 create table tabname(col1 type1 [not null][primary key],col2 type2 [not null],..) 根据已有的表创建新表：A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… from tab_old definition only 说明：删除新表 drop table tabname 说明：增加一个列 Alter table tabname add column col type注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。 说明：添加主键： Alter table tabname add primary key(col) 说明：删除主键： Alter table tabname drop primary key(col) 说明：创建索引： create [unique] index idxname on tabname(col….) 删除索引： drop index idxname 注：索引是不可更改的，想更改必须删除重新建。 说明：创建视图：create view viewname as select statement 删除视图：drop view viewname 说明：几个简单的基本的sql语句选择：select from table1 where 范围插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!排序：select from table1 order by field1,field2 [desc]总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1*最小：select min(field1) as minvalue from table1 说明：几个高级查询运算词A： UNION 运算符 UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。B： EXCEPT 运算符 EXCEPT运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。C： INTERSECT 运算符INTERSECT运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。注：使用运算词的几个查询结果行必须是一致的。 对数据库进行操作：分离数据库：sp_detach_db;附加数据库：sp_attach_db **后接表明，附加需要完整的路径名 如何修改数据库的名称:sp_renamedb ‘old_name’, ‘new_name’]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[好句集锦（不断完善和补充）]]></title>
      <url>%2F2017%2F06%2F30%2F%E5%A5%BD%E5%8F%A5%E9%9B%86%E9%94%A6%EF%BC%88%E4%B8%8D%E6%96%AD%E5%AE%8C%E5%96%84%E5%92%8C%E8%A1%A5%E5%85%85%EF%BC%89%2F</url>
      <content type="text"><![CDATA[以下为平时所看所积累的： 缘来惜缘，缘去随缘，聚散皆是缘！即： 随缘惜缘莫攀缘！——大冰 发上等愿，结中等缘，享下等福；择高处立，寻平处住，向宽处行！——亚森 一个人只有今生今世是不够的，他还应该有诗意的世界。——王小波 立身树为模，本固任从枝叶动；处世钱作样，内方还要外边圆。——甄子丹 努力不一定成功，但不努力一定失败！——庆丽 别让这座城市留下了你的青春却留不下你。——某家地产广告语 路虽远，行则必至！—— 这一刻，全力以赴；下一刻，占尽先机！ 所谓生活，就是磨练意志，打磨灵魂。 最怕你一生碌碌无为，却安慰自己难能可贵！ 别害怕无话可谈，也别指望无话不谈！ 相恨不如潮有信，相思始觉海非深。 天涯海角有穷时，只有相思无尽处。 成功不会自燃，必须自己点火！—— 外练筋骨皮，内练一口气。——李翔 从来都没有岁月静好，只是有人，在为我们负重前行！ 始于初见，止于终老！ 始于颜值，终于才华！ 我寻遍了这天下只为带你回家！ 春风十里不如你！ 酒满茶半，酒满敬人，茶满送客。——大冰 努力了才能看到希望！ 什么时候开始都不晚，晚的是，你总是不敢开始。 我输过，我败过，但我不曾害怕过！ 既然琴瑟起，何以笙箫默！ 你要问自己，你想要的，只能你自己给；别人给的，你要问问自己，拿得起么？ 现实与理想之间，不变的是跋涉；暗淡与辉煌之间，不变的是开拓！ 你所做的事情，也许暂时看不到成功，但不要灰心，你不是没有成长，而是在扎根。 压力不是有人比你努力，而是比你牛几倍的人依然在努力。 有些事情不是看到希望才去坚持，而是坚持了才看到希望！ 耐得住寂寞才能守得住繁华，该奋斗的年龄不要选择了安逸！ 在抱怨自己赚钱少之前，先努力学着让自己值钱！ 只有先改变自己的态度，才能改变人生的高度。 一个人越懒，明天要做的事儿越多！ “我知道这个世界不完美，我的人不完美，我的音乐不完美，但有了你谁还需要完美？”——卢凯彤 我不怕黑不怕苦不怕路远马亡，只怕在最该吃苦的年纪选择了安逸。 “二十几岁时，给优秀的人工作；三十几岁时，跟优秀的人合作；四十几岁时，找优秀的人给您工作；五十几岁时，把别人变成优秀的人！——雷军 12345女人如花，气质脱俗，清香柔媚，秀外慧中千万别践踏了花的温柔，让你触目惊心地痛；千万别摧残了花的善良，让你痛心疾首地恨；千万别打击了花的爱意，让你捶胸顿足痛不欲生；千万别玷污了花的纯洁，让你悔恨交加生不如死。 曾经有一份真诚的爱情放在我面前，我没有珍惜，等我失去的时候我才后悔莫及，人世间最痛苦的事莫过于此。如果上天能够给我一个再来一次的机会，我会对那个女孩子说三个字：我爱你。如果非要在这份爱上加上一个期限，我希望是……一万年！——周星驰 时间，抓起了就是黄金，虚度了就是流水；书，看了就是知识，没看就是废纸；理想，努力了才叫梦想，放弃了那只是妄想；努力，虽然未必会收获，但放弃，就一定一无所获。 谓数可知乎，可知而不可知也。谓数不可知乎，不可知而可知也。可知者数，不可知者亦数也。可知其所不可知者数，不可知其所可知者亦数也。 傅盛把一个人的认知状态进行了有趣的划分，一共是四个境界：不知道自己不知道——以为自己什么都知道，自以为是的认知状态；知道自己不知道——有敬畏之心，开始空杯心态，准备丰富自己的认知；知道自己知道——抓住了事情的规律，提升了自己的认知；不知道自己知道——永远保持空杯的心态，认知的最高境界。 一旦开始就不要停止！ 胜利者发明规则，失败则遵守它们！ 成功者每时每刻都会分享有价值的信息，传递给身边的朋友，你在他们心目中会变得更有价值。——马云 自古真情留不住 ，唯有套路得人心。 一切的恐惧都来源于不了解。 要想人前显贵，必先人后受罪。 为天地立心，为生民立命，为往圣继绝学，为万世开太平。——张载 愿你历经世事，最终闪闪发光! 假如你不满现状，那就做好充足准备！——From Me 葡萄美酒夜光杯 欲饮琵琶马上催 获得幸福的秘诀，并不在于为了追求快乐而全力以赴，而是在全力以赴中寻出快乐。 人的一生是黑与白的变奏曲👻 谁的盛开渲染了水的存在 谁的存在改变了谁的青春 刚毕业的大学生该如何选择工作？去创业公司还是去大公司？Sailthru的人力资源副总裁娜塔莉·沃兹沃斯（Natalie Wadsworth）给出了三个建议。Sailthru是一家创办于2008年的科技公司，主营业务是为网站提供个性化内容推荐服务，客户包括美国在线等。娜塔莉说，当你在作选择时，不妨先问自己三个问题。 第一个问题是，你是否喜欢这个公司的产品，这个公司的产品是否有价值？如果这家公司是生产直接面向个人消费者的产品，你总能够买到并且使用。而且，你还可以上网去寻找其他用户对他的评论。 第二个问题是，问一问自己对风险和变化的承受能力怎样。这会帮你决定是选择创业公司还是选择成熟公司。 创业公司的工作听上去很让人激动，但是创业的风险很大。美国劳工统计局的数据说，从1994年到现在，只有50%的创业公司能活过四年；只有三分之一的能活到第十年。此外，创业公司会经常改变产品、策略和团队。你对变化要有高容忍度。 第三个问题是，目前的工作职务是否能带给你挑战。第一份工作应该能够有助于你培养沟通技巧、时间管理能力和问题解决能力。除此之外，你最好有机会能尝试不同部门的工作，以及能接触到高层领导。这有助于你找到最适合自己的职务，并且培养出很多能力。——From 李翔知识内参 The future belongs to those who prepare for it today.未来属于那些今天做准备的人的。 PC时代=&gt;移动互联网时代=&gt;AI时代，如今人工智能时代已经大踏步朝我们走来，你是拥抱还是躲避，选择权在你 学习使人进步 Learning to make progress ；学习使人快乐 Learning to be happy。 努力做好自己，散发最美的香味 走自己的路途，哪怕风雨兼程。 纵观历史，成功的总需要倔强，就是这种倔强使得他们面对困难的时候总是会迸发更大的能量。 毛泽东曾写过一首诗：孩儿立志出乡关，学不成名誓不还。埋骨何须桑梓地，人生无处不青山。 这种倔强，成就了自己，也拯救苦难的新中国。总而言之， 要想成功，首先要先不服输，也许你曾经遭受过挫折，困惑，不甘，BUT！ 坚守住自己的初心，不达梦想，誓不罢休。做最好的自己，为你自豪~ 你的未来是深渊中下坠的光 ——纯银 V 愿居兰若寺，夜闻叩门声 ——纯银 V “在这个世界上，不要太依赖别人。 因为即使是你的影子，也会在黑暗时离开你的。” ​​​ 未完待续…. ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Moov算法题]]></title>
      <url>%2F2017%2F06%2F29%2FMoov%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[给定一个数组，写出这个数组元素在前两个数组元素所组成的左闭右开区间的出现的次数， 题目如下： 我的解决方案如下： 123456789101112131415161718192021222324252627282930313233343536373839- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. /* 大致思路: 建立一个 key-value 的映射，字典中 key 值唯一 1、_startsArray 数组元素 与 _endsArray 数组元素个数相等 ，也就是题目中的 n 2、m 是所要查询的 _queryArray 的元素的个数 3、计算：[左区间：闭，右区间：开) ①以[[_endsArray objectAtIndex:i] integerValue] - [[_startsArray objectAtIndex:i] integerValue] 区间的每一个 integer 的值作为 key， ②或者说是 以[[_startsArray objectAtIndex:i] integerValue]为起始key值，[[_endsArray objectAtIndex:i] integerValue]为值为某次循环的最大次数 key 值 ③然后，每循环一次，取出 key 值对应的 value，然后++value ④setValue:forKey ⑤这样就得出一个以 query 数组中元素为 key 值，这些元素存在于那两个数组区间内的次数为 value 的映射表 ⑥最后，从这个映射表中，查询对应元素的次数 */ //PS: //计算出(左区间：闭，右区间：开) [start1,end1),....,[startn,endn) 区间值 建立一个 key-value 的映射 TICK(mapTime) for (NSInteger i = 0; i &lt; self.startsArray.count; i ++) &#123; for (NSInteger j = [self.startsArray[i] integerValue]; j &lt; [self.endsArray[i] integerValue]; j ++) &#123; NSInteger value = [[self.mapMutaleDictionary valueForKey:[NSString stringWithFormat:@&quot;%ld&quot;,j]] integerValue]; ++value; [self.mapMutaleDictionary setValue:@(value) forKey:[NSString stringWithFormat:@&quot;%ld&quot;,j]]; &#125; NSLog(@&quot;&quot;); &#125; NSLog(@&quot;mapMutaleDictionary : %@&quot;,self.mapMutaleDictionary); TOCK(mapTime) NSLog(@&quot;query : %@&quot;,self.queryArray); //通过映射 for (NSInteger i = 0; i &lt; self.queryArray.count; i ++) &#123; NSInteger query = [self.queryArray[i] integerValue]; NSInteger value = [[self.mapMutaleDictionary valueForKey:[NSString stringWithFormat:@&quot;%ld&quot;,query]] integerValue]; [self.resultArray addObject:@(value)]; &#125; NSLog(@&quot;resultArray : %@&quot;,self.resultArray);&#125; 完整代码请点击查询 然而，这不是最优解，因为没考虑时间复杂度，所以这个问题的解决方案也只是小范围内的暂时方案。。。 最优解决方案：使用数学上学习的 分段函数 的思想，然后利用 OC 链表的算法进行求解，此方案待定([尴尬])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS你需要知道这些]]></title>
      <url>%2F2017%2F06%2F27%2FiOS%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B%2F</url>
      <content type="text"><![CDATA[​ 每天说思维导图，思维导图，今天下午终于花了俩小时，画了这个思维导图，现在呈上来供大家参考一下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS响应者链]]></title>
      <url>%2F2017%2F06%2F22%2FiOS%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE%2F</url>
      <content type="text"><![CDATA[https://github.com/wz1383691/WZTouch 事件的传递是从上到下的，事件的响应是从下到上的。 iOS 响应者链Responder Chain浅析 ​ 在iOS中，当发生事件响应时，必须知道由谁来响应事件。这就是由响应者链来对事件进行响应，所有事件响应的类都是UIResponder的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。 ​ 当发生事件时，事件首先被发送给第一响应者，第一响应者往往是事件发生的视图，也就是用户触摸屏幕的地方。事件将沿着响应者链一直向下传递，直到被接受并作出处理。 ​ 一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件交由他处理，如果他不处理，事件就会被传递给它的视图控制器对象ViewController（如果存在），然后是他的父视图（superview）对象（如果存在），以此类推，直到顶层视图（top view）。接下来会沿着顶层视图（top view）到窗口（UIWindow对象），再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应链中只要有对象处理事件，事件就停止传递。 ​ 一个典型的响应路线如下： First Responder–&gt;The Window–&gt;The Application–&gt;App Delegate. ​ 有了以上的基础，我们来谈谈事件。iOS中事件分为三类，触摸屏幕、晃动设备、远程控制设备。对应的事件类型有以下三种： （1）触屏事件（Touch Event）; （2）运动事件（Motion Event）; （3）远程控制事件（Remote-Control Event）; ​ 现在我们以触摸事件为例，来深入了解一下响应者链（Responder Chain）. ​ 响应者对象(Responder Object)，指的是有响应和处理事件能力的对象。响应者链就是一系列的响应者对象构成的一个层次结构。UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication,UIViewController,UIWindow和所有继承自UIView的UIKit类都直接或者间接继承自UIResponder，所以他们的实例都是可以构成响应者链的响应者对象。如下图所示： 从上图可以看到，响应者链有以下特点： （1）响应者链通常是由视图（UIView）构成的； （2）一个视图的下一个响应者是他的视图控制器（UIViewController）（如果有的话），然后再传给它的父视图（SuperView）。 （3）视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图。 （4）单例的窗口（UiWindow）的内容视图将指向窗口本身作为它的下一个响应者。 （5）单例的应用（UIApplication）是一个响应者的终点。它的下一个响应者指向nil，以结束整个循环。 然后再来了解下事件分发(Event Delivery)：​ 第一响应者（First Responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。整个响应者链和事件分发的使命都是找出第一响应者。UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应链中的下一个响应者，看他是否能够处理。 ​ 现在我用几句话来简单说明下什么是响应者链条： （1）响应者链是由多个响应者对象链接起来的队列； （2）响应者对象是指能够处理事件的对象，也就是继承自UIResponder的对象； （3）使用响应者链条，能够让一条链上的多个对象对同一事件作出响应； （4）消息在响应者链上传递也就是想找到下一个响应的对象（nextResponder）; ​ 这里我们要注意到一个问题，对于消息事件的管理，我们使用的是队列，而不是栈，因为我们要保证先产生的事件先处理，也就是先进先出。 以上是各个 iOSDev 给出的解释…. 以下是🍎官方文档给出的解释…. Understanding Responders and the Responder ChainApps receive and handle events using responder objects. A responder object is any instance of the UIResponderclass, and common subclasses include UIView, UIViewController, and UIApplication. UIKit manages most responder-related behavior automatically, including how events are delivered from one responder to the next. However, you can modify the default behavior to change how events are delivered within your app. UIKit directs most events to the most appropriate responder object in your app. If that object does not handle the event, UIKit forwards it to the next responder in the active responder chain, which is a dynamic configuration of your app’s responder objects. Because it is dynamic, there is no single responder chain within your app. However, it is easy to determine the next responder in the chain because events always flow from specific responder objects to more general responder objects. For example, the next responder for a view is either its superview or the view controller that manages it. Events continue to flow up the responder chain until they are handled. Figure 7-1 shows the responder chains that form in an app whose interface contains a label, a text field, a button, and two background views. If the text field does not handle an event, UIKit sends the event to the text field’s parent UIView object, followed by the root view of the window. From the root view, the responder chain diverts to the owning view controller before returning to the view’s window. If the window does not handle the event, UIKit delivers the event to the UIApplication object, and possibly to the app delegate if that object is an instance of UIResponder and not already part of the responder chain. Figure 7-1An example of a responder chain 更为详细的讲解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BAT对比分析]]></title>
      <url>%2F2017%2F05%2F22%2FBAT%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[百度、阿里和腾讯内部的级别和薪资待遇是什么样的？百度：1. 百度的技术级别：百度有4万人，每年招聘应届生技术产品人员1000人左右，技术岗位级别和阿里类似，分为T序列12级，不赘述了，大概阿里的级别减1或2，就是百度的级别。•主要集中在T5/T6，升T7很困难，T7升T8更困难；T7以上一般就不做coding了•一般来说，在百度待3年能给到T5，很多人都等不到三年，原因下面说，社招过来的，一般是外面公司的技术骨干了•T10是技术总监，十个左右；T11是首席科学家；T12基本没见过。 2.再看百度薪资的大概范围： •百度薪资结构：月薪14.6（12+0.6+2）,其他岗位月薪14 •T5以上为关键岗位，另外有股票、期权•T5、T6占比最大的级别，T8、T9占比最小•级别越高，每档之间的宽幅越大 ​ 百度是一家业务定性，内部稳定，金字塔形的成熟公司。也就是说，大部分事情都是按部就班、驾轻就熟，所有人都比较轻松、稳定、舒服，尤其是对老员工而言。但是对于新员工来说，这意味着成长空间的极度压缩，机会少，上升慢。 ​ 百度工资高，福利好，但是这么多年期权已经基本发光了，只有总监以上才有，几十股几百股就算多了。问题就来了，百度新老员工的期权数量太悬殊，据说到百度楼下停车场一看，开卡宴的都是老员工，开捷达的都是新员工，其实很多新员工的贡献比老员工大得多，但是收入反而倒挂，于是很多新人等不到3年就跳了。 阿里：1、先看阿里的级别定义：P序列=技术岗 M序列=管理岗 阿里的非管理岗分为10级 其中P6、P7、P8需求量最大，也是阿里占比最大的级别 2、再看阿里的级别对应薪资： •阿里薪资结构：一般是12+1+3=16薪•年底的奖金为0-6个月薪资，90%人可拿到3个月•股票是工作满2年才能拿，第一次拿50%，4年能全部拿完说到股票，真是要普及下常识，别被忽悠了。 PS：股票是公司用来奖励员工忠诚度的，所以阿里分年限行权，想要离职套现真的是难。更不要高额的税收了，首先，归属要收高达45%的个税，然后得到的还是限制性股票，还不能马上卖呢。好不容易可以出售的时候，还得交20%股票增值部分的个人所得税哦！​ 更重要的是，你必须先缴税，才能归属，缴税还必须用现金**，不能sell to cover！So，拿的越多，先拿出的cash就越多，这里面的流动性风险你自己权衡吧。 腾讯：1.腾讯的技术级别：腾讯的分级和阿里/百度都不一样，分为T1/T2/T3/T4共4级，其中又细分为3级。 •员工仍然集中在中段，尤其是 T2.3 和 T3.1 •想从T2跨到T3，即从2.3升3.1是非常困难的 2.了解薪酬和级别的关系： • 腾讯标准薪资是14薪，但是通常能拿到16-20薪 • T3.1以上开始另外有股票值得一提的是，腾讯是有淘汰制考核的。一般一年两次考核（6月、12月），实行末尾淘汰制，0-10%优秀，必须有5%的人转组（转组也可能出现没人接收的情况）或者被开除，这点比较狠。 ​ 升级也跟考核结果很有关系，要升一个小等级，必须最近两次考核得过一次A类考核结果。升 T3.1是内部晋升的第一道槛，要求架构在领域内优秀，被追问攻击时能无漏洞应答出来–据说只有30%的通过率。同时，腾讯好的一点在于，底层普通员工如果技术真的不错，照样升级，和是不是leader关系不大。leader的带队价值在T3.3时才显现出来。 • 最后，来张BAT级别对照表 ​ 以上算是大致梳理了BAT的级别和薪资福利。无论你是向往BAT还是身居其中，把握每年的评级机会/跳槽机会，建立一条上升的职业曲线更为重要，因为，没有变化是一件很可怕的事情。 ​ 希望给你也给我自己带来了一点有用的信息和启发O(∩_∩)O~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS推送机制]]></title>
      <url>%2F2017%2F04%2F25%2FiOS%E6%8E%A8%E9%80%81%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[​ Push Notification是如何工作的？ 推送通知分为两种,一个是本地推送,一个是远程推送 本地推送：不需要联网也可以推送,是开发人员在App内设定特定的时间来提醒用户干什么 远程推送：需要联网,用户的设备会于苹果APNS服务器形成一个长连接,用户设备会发送UUID 和Bundle idenidentifier给苹果服务器,苹果服务器会加密生成一个deviceToken返回给用户设备,然后设备会将deviceToken发送给APP的服务器,服务器会将deviceToken存进他们的数据库,这时候如果有人发送消息给我,服务器端就会去查询我的deviceToken,然后将deviceToken和要发送的信息发送给苹果服务器,苹果服务器通过deviceToken找到我的设备并将消息推送到我的设备上,这里还有个情况是如果App在线,那么App服务器会于App产生一个长连接,这时候App服务器会直接通过deviceToken将消息 msg 推送到设备上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios应用程序的生命周期]]></title>
      <url>%2F2017%2F03%2F21%2Fios%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[​ 每一个程序在运行期必须有且仅有一个 UIApplication（或则其子类）的一个实例。在程序开始运行的时候，UIApplicationMain 函数是程序进入点，这个函数做了很多工作，其中一个重要的工作就是创建一个 UIApplication 的单例实例。在你的代码中你，你可以通过调用 [UIApplication sharedApplication] 来得到这个单例实例的指针。 ​ UIApplication 的一个主要工作是处理用户事件，它会起一个队列，把所有用户事件都放入队列，逐个处理，在处理的时候，它会发送当前事件 到一个合适的处理事件的目标控件。此外，UIApplication 实例还维护一个在本应用中打开的 window 列表（UIWindow 实例），这样它就 可以接触应用中的任何一个 UIView 对象。UIApplication 实例会被赋予一个代理对象，以处理应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警告）等等。 UIApplicaion 生命周期一个 UIApplication 可以有如下几种状态： Not running（未运行） Inactive（未激活） Active（激活） Background（后台） Suspended（挂起） 常见的代理方法有: -(void)applicationWillResignActive:(UIApplication *)application 说明：当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了 -(void)applicationDidBecomeActive:(UIApplication *)application 说明：当应用程序入活动状态执行，这个刚好跟上面那个方法相反 -(void)applicationDidEnterBackground:(UIApplication *)application 说明：当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可 -(void)applicationWillEnterForeground:(UIApplication *)application 说明：当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。 -(void)applicationWillTerminate:(UIApplication *)application 说明：当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要设置 UIApplicationExitsOnSuspend 的键值。 -(void)applicationDidReceiveMemoryWarning:(UIApplication *)application 说明：iPhone 设备只有有限的内存，如果为应用程序分配了太多内存操作系统会终止应用程序的运行，在终止前会执行这个方法，通常可以在这里进行内存清理工作防止程序被终止 -(void)applicationSignificantTimeChange:(UIApplication*)application 说明：当系统时间发生改变时执行 -(void)applicationDidFinishLaunching:(UIApplication*)application 说明：当程序载入后执行 下面是一个用于展示整个 App 生命周期的示意图： 这一张来自 Twitter 的图片，对于理解 iOS App 的生命周期起到了非常大的作用！ 123456789[UIApplication sharedApplication].windows在本应用中打开的UIWindow列表，这样就可以接触应用中的任何一个UIView对象(平时输入文字弹出的键盘，就处在一个新的UIWindow中)[UIApplication sharedApplication].keyWindow用来接收键盘以及非触摸类的消息事件的UIWindow，而且程序中每个时刻只能有一个UIWindow是keyWindow。如果某个UIWindow内部的文本框不能输入文字，可能是因为这个UIWindow不是keyWindowview.window获得某个UIView所在的UIWindow]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC内存管理]]></title>
      <url>%2F2017%2F03%2F20%2FOC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[Objective-C 中的内存分配在 Objective-C 中，对象通常是使用 alloc 方法在堆上创建的。 [NSObject alloc] 方法会在对堆上分配一块内存，按照NSObject的内部结构填充这块儿内存区域。 一旦对象创建完成，就不可能再移动它了。因为很可能有很多指针都指向这个对象，这些指针并没有被追踪。因此没有办法在移动对象的位置之后更新全部的这些指针。 MRC 与 ARCObjective-C中提供了两种内存管理机制：MRC（MannulReference Counting）和 ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。现在苹果推荐使用 ARC 来进行内存管理。 MRC对象操作的四个类别 对象操作 OC中对应的方法 对应的 retainCount 变化 生成并持有对象 alloc/new/copy/mutableCopy等 +1 持有对象 retain +1 释放对象 release -1 废弃对象 dealloc - 注意： 这些对象操作的方法其实并不包括在OC中，而是包含在Cocoa框架下的Foundation框架中。从 iOS 7 开始，这些方法被移动到了 Runtime 当中，可以在 objc4-680 NSObject.h 找到。 对象的 reatinCount 属性并没有实际上的参考价值，参考苹果官方文档《Practical Memory Management》. 四个法则 自己生成的对象，自己持有。 非自己生成的对象，自己也能持有。 不在需要自己持有对象的时候，释放。 非自己持有的对象无需释放。 如下是四个黄金法则对应的代码示例： 12345/* * 自己生成并持有该对象 */ id obj0 = [[NSObeject alloc] init]; id obj1 = [NSObeject new]; 12345/* * 持有非自己生成的对象 */id obj = [NSArray array]; // 非自己生成的对象，且该对象存在，但自己不持有[obj retain]; // 自己持有对象 123456789/* * 不在需要自己持有的对象的时候，释放 */id obj = [[NSObeject alloc] init]; // 此时持有对象[obj release]; // 释放对象/* * 指向对象的指针仍就被保留在obj这个变量中 * 但对象已经释放，不可访问 */ 12345/* * 非自己持有的对象无法释放 */id obj = [NSArray array]; // 非自己生成的对象，且该对象存在，但自己不持有[obj release]; // ~~~此时将运行时crash 或编译器报error~~~ 非 ARC 下，调用该方法会导致编译器报 issues。此操作的行为是未定义的，可能会导致运行时 crash 或者其它未知行为 其中 非自己生成的对象，且该对象存在，但自己不持有 这个特性是使用autorelease来实现的，示例代码如下： 12345- (id) getAObjNotRetain &#123; id obj = [[NSObject alloc] init]; // 自己持有对象 [obj autorelease]; // 取得的对象存在，但自己不持有该对象 return obj;&#125; autorelease 使得对象在超出生命周期后能正确的被释放(通过调用release方法)。在调用 release 后，对象会被立即释放，而调用 autorelease 后，对象不会被立即释放，而是注册到 autoreleasepool 中，经过一段时间后 pool结束，此时调用release方法，对象被释放。 在MRC的内存管理模式下，与对变量的管理相关的方法有：retain, release 和 autorelease。retain 和 release 方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用 NSAutoreleasePool 对象，对加入自动释放池（autorelease 调用）的变量进行管理，当 drain 时回收内存。 ARCARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化。 变量标识符在ARC中与内存管理有关的变量标识符，有下面几种： __strong __weak __unsafe_unretained __autoreleasing __strong 是默认使用的标识符。只要还有一个强指针指向某个对象，这个对象就会一直存活。 __weak 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，弱引用会被置为 nil __unsafe_unretained 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会被置为 nil。如果它引用的对象被回收掉了，该指针就变成了野指针。 __autoreleasing 用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉。 变量标识符的用法如下： 1Number* __strong num = [[Number alloc] init]; 注意 __strong 的位置应该放到 * 和变量名中间，放到其他的位置严格意义上说是不正确的，只不过编译器不会报错。 属性标识符类中的属性也可以加上标志符： 1@property (assign/retain/strong/weak/unsafe_unretained/copy) Number* num assign表明 setter 仅仅是一个简单的赋值操作，通常用于基本的数值类型，例如CGFloat和NSInteger。 strong 表明属性定义一个拥有者关系。当给属性设定一个新值的时候，首先这个值进行 retain ，旧值进行 release ，然后进行赋值操作。 weak 表明属性定义了一个非拥有者关系。当给属性设定一个新值的时候，这个值不会进行 retain，旧值也不会进行 release， 而是进行类似 assign 的操作。不过当属性指向的对象被销毁时，该属性会被置为nil。 unsafe_unretained 的语义和 assign 类似，不过是用于对象类型的，表示一个非拥有(unretained)的，同时也不会在对象被销毁时置为nil的(unsafe)关系。 copy 类似于 strong，不过在赋值时进行 copy 操作而不是 retain 操作。通常在需要保留某个不可变对象（NSString最常见），并且防止它被意外改变时使用。 错误使用属性标识符的后果如果我们给一个原始类型设置 strong\weak\copy ，编译器会直接报错： Property with ‘retain (or strong)’ attribute must be of object type 设置为 unsafe_unretained 倒是可以通过编译，只是用起来跟 assign 也没有什么区别。 反过来，我们给一个 NSObject 属性设置为 assign，编译器会报警： Assigning retained object to unsafe property; object will be released after assignment 正如警告所说的，对象在赋值之后被立即释放，对应的属性也就成了野指针，运行时跑到属性有关操作会直接崩溃掉。和设置成 unsafe_unretained 是一样的效果（设置成 weak 不会崩溃）。 unsafe_unretained 的用处unsafe_unretained 差不多是实际使用最少的一个标识符了，在使用中它的用处主要有下面几点： 兼容性考虑。iOS4 以及之前还没有引入 weak，这种情况想表达弱引用的语义只能使用 unsafe_unretained。这种情况现在已经很少见了。 性能考虑。使用 weak 对性能有一些影响，因此对性能要求高的地方可以考虑使用 unsafe_unretained 替换 weak。一个例子是 YYModel 的实现，为了追求更高的性能，其中大量使用 unsafe_unretained 作为变量标识符。 main.m 中 Autorelease Pool 的解释大家都知道在 iOS 程序的 main.m 文件中有类似这样的语句： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 然而，这里的 pool 有什么作用，能不能去掉呢？在这里我们分析一下： 根据苹果官方文档， UIApplicationMain 函数是整个 app 的入口，用来创建 application 对象（单例）和 application delegate。尽管这个函数有返回值，但是实际上却永远不会返回，当按下 Home 键时，app 只是被切换到了后台状态。 同时参考苹果关于 Lifecycle 的官方文档，UIApplication 自己会创建一个 main run loop，我们大致可以得到下面的结论： main.m 中的 UIApplicationMain 永远不会返回，只有在系统 kill 掉整个 app 时，系统会把应用占用的内存全部释放出来。 因为(1)， UIApplicationMain 永远不会返回，这里的 autorelease pool 也就永远不会进入到释放那个阶段 在 (2) 的基础上，假设有些变量真的进入了 main.m 里面这个 pool（没有被更内层的 pool 捕获），那么这些变量实际上就是被泄露的。这个 autorelease pool 等于是把这种泄露情况给隐藏起来了。 UIApplication 自己会创建 main run loop，在 Cocoa 的 runloop 中实际上也是自动包含 autorelease pool 的，因此 main.m 当中的 pool 可以认为是没有必要的。 在基于 AppKit 框架的 Mac OS 开发中， main.m 当中就是不存在 autorelease pool 的，也进一步验证了我们得到的结论。不过因为我们看不到更底层的代码，加上苹果的文档中不建议修改 main.m ，所以我们也没有理由就直接把它删掉（亲测，删掉之后不影响 App 运行，用 Instruments 也看不到泄露）。 为了进一步理解 ARC 是如何做到这一点的，我们可以参考 Clang 的文档。 众所周知，weak 不会持有对象，当给一个 weak 赋以一个自己生成的对象（即 retained return value）后，对象会立马被释放。 一个很常见的 warning 就是 Assigning retained object to weak variable, object will be released after assignment. 但是我们前面也提到了，可以持有非自己生成的对象，这通过 autorelease 实现。 那么如果一个 weak 被赋以一个非自己生成的对象（即 unretained return value）呢？代码如下： 12NSNumber __weak *number = [NSNumber numberWithInt:100];NSLog(@&quot;number = %@&quot;, number); 这种情况下是可以正确打印值的。 clang的文档 是这么说的：这种情况下，weak 并不会立即释放，而是会通过 objc_loadWeak 这个方法注册到 AutoreleasePool 中，以延长生命周期。 ARC 下的临时变量是受到 Autorelease Pool 的管理的，会自动释放。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3·15晚会]]></title>
      <url>%2F2017%2F03%2F19%2F3%C2%B715%E6%99%9A%E4%BC%9A%2F</url>
      <content type="text"><![CDATA[2017-3-15晚会播放地址：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSString属性什么时候用copy，什么时候用strong?]]></title>
      <url>%2F2017%2F03%2F17%2FNSString%E5%B1%9E%E6%80%A7%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8copy%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8strong%2F</url>
      <content type="text"><![CDATA[下边我们来做个实验： 1234567891011121314151617181920212223@property (nonatomic, strong) NSString *strongString;@property (nonatomic, copy) NSString *copyedString;- (void)test &#123; #warning 第一步 NSString *string = [NSString stringWithFormat:@&quot;Chaiyh&quot;]; #warning 第二步// NSMutableString *string = [NSMutableString stringWithFormat:@&quot;Chaiyh&quot;]; self.strongString = string; self.copyedString = string; _originLabel.text = [NSString stringWithFormat:@&quot;origin string: %p, &amp;string : %p&quot;, string, &amp;string]; _strongLabel.text = [NSString stringWithFormat:@&quot;strong string: %p, &amp;_strongString : %p&quot;, _strongString, &amp;_strongString]; _copyedLabel.text = [NSString stringWithFormat:@&quot;copy string: %p, &amp;_copyedString : %p&quot;, _copyedString, &amp;_copyedString]; NSLog(@&quot;origin string: %p, &amp;string : %p&quot;, string, &amp;string); NSLog(@&quot;strong string: %p, &amp;_strongString : %p&quot;, _strongString, &amp;_strongString); NSLog(@&quot;copy string: %p, &amp;_copyedString : %p&quot;, _copyedString, &amp;_copyedString);&#125; 第一步：ARC 下,其输出结果为⤵️： ARC 下，我们可以看到，不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string指向的地址。 如果我们换作MRC环境，打印string的引用计数的话，会看到其引用计数值是3，即strong操作和copy操作都使原字符串对象的引用计数值加了1。 第二步：我们把string由不可变改为可变对象，看看会是什么结果。即将下面这一句 NSString *string = [NSString stringWithFormat:@”Chaiyh”]; 改成： NSMutableString *string = [NSMutableString stringWithFormat:@”Chaiyh”]; 输出结果是： 可以发现，此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让_copyedString对象指向这个字符串。在MRC环境下，打印两者的引用计数，可以看到string对象的引用计数是2，而_copyedString对象的引用计数是1。 此时，我们如果去修改string字符串的话，可以看到：因为_strongString与string是指向同一对象，所以_strongString的值也会跟随着改变(需要注意的是，此时_strongString的类型实际上是NSMutableString，而不是NSString)；而_copyedString是指向另一个对象的，所以并不会改变。 结论：​ 1、由于NSMutableString是NSString的子类，所以一个NSString指针可以指向NSMutableString对象，让我们的strongString指针指向一个可变字符串是OK的。 ​ 而上面的例子可以看出，当源字符串是NSString时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。 ​ 2、当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。 ​ 这里还有一个性能问题，即在源字符串是NSMutableString时候，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是NSString时，则没有这个问题。 所以，在声明NSString属性时，到底是选择strong还是copy，可以根据实际情况来定。不过，一般我们将对象声明为NSString时，都不希望它改变，所以大多数情况下，我们建议用copy，以免因可变字符串的修改导致的一些非预期问题。 Demo下载地址 运行 Demo 后，请横屏看结果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络知识点儿]]></title>
      <url>%2F2017%2F03%2F16%2F%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%84%BF%2F</url>
      <content type="text"><![CDATA[HTTP 协议HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP特性 HTTP构建于TCP/IP协议之上，默认端口号是80 HTTP是无连接无状态的 HTTP 报文请求报文HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。 HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。 1、GET用于信息获取，而且应该是安全的 和 幂等的。 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 幂等的意味着对同一URL的多个请求应该返回同样的结果。 URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。 2、POST表示可能修改变服务器上的资源的请求。 3、注意: GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制 条件 GETHTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。 HTTP 条件 GET 使用的时机？ 客户端之前已经访问过某网站，并打算再次访问该网站。 HTTP 条件 GET 使用的方法？ 客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 下面是一个具体的发送接受报文示例： 客户端发送请求： 1234GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。 12345678HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close 如果服务器端资源已经更新的话，就返回正常的响应。 TCP 协议TCP的特性 TCP提供一种面向连接的、可靠的字节流服务 在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP TCP使用校验和，确认和重传机制来保证可靠传输 TCP使用累积确认 TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 三次握手与四次挥手 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。 TCP连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 HTTPS 协议HTTPS基础知识：HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版,是使用TLS/SSL加密的HTTP协议。 HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。 TLS/SSL全称安全传输层协议Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。 HTTPS和HTTP的区别是什么？ 一、什么是HTTPS​ HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。 HTTPS主要作用是：（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;（2）对网站服务器进行真实身份认证。二、什么是HTTP​ HTTP是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准(TCP)，用于从WWW服务器传输超文本到本地浏览器的传输协议。HTTP是采用明文形式进行数据传输，极易被不法份子窃取和篡改。三、HTTPS和HTTP的区别是什么​ 1、HTTPS是加密传输协议，HTTP是名文传输协议;​ 2、HTTPS需要用到SSL证书，而HTTP不用;​ 3、HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO；​ 4、HTTPS标准端口443，HTTP标准端口80;​ 5、HTTPS基于传输层，HTTP基于应用层;​ 6、HTTPS在浏览器显示绿色安全锁，HTTP没有显示; 【参考:（1）为保护用户隐私安全,谷歌优先索引HTTPS网页、 ​ （2）百度开放收录https站点，https全网化势不可挡】】 总的来说HTTPS比HTTP更加安全，能够有效的保护网站用户的隐私信息安全，这也是为什么现在的HTTPS网站越来越多。如果不想你的网站因为数据泄露上头条的话，就赶快去申请一张SSL证书为自己的网站实现HTTPS加密吧! TLS/SSL工作原理​ TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密。其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 散列函数Hash​ 常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性;​ 在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;对称加密​ 常见的有 AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1; 对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制;非对称加密​ 即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。​ 非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。​ 结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。 Socket 基本概念Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。 Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。 Socket 的使用场景： 这些协议之前的关系： HTTP是运行在应用层上的应用协议，而不同的层级上都有相应的协议在运行。层级的堆栈关系一般可以这么描述： 1234567Application Layer -- e.g. HTTP----Transport Layer -- e.g. TCP----Internet Layer -- e.g. IP----Link Layer -- e.g. IEEE 802.2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Release下真机测试问题及其他奇怪问题集锦]]></title>
      <url>%2F2017%2F03%2F15%2FRelease%E4%B8%8B%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E4%BB%96%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6%2F</url>
      <content type="text"><![CDATA[发件人 Apple \2. 4 PERFORMANCE: HARDWARE COMPATIBILITY Performance - 2.4.1 We noticed that your app did not run at iPhone resolution when reviewed on iPad running iOS 10.2.1. Please see attached screenshots for details. Next Steps Please revise your app to ensure it runs and displays properly at iPhone resolution on iPad. Resources For information on iOS device screen sizes and resolutions, please see the iOS Human Interface Guidelinesas well as the Points versus Pixels in the View Programming Guide for iOS. iPhone6Plus(5).jpg Screenshot-0314-121441.png 类似问题： 【Google翻译： 我们注意到，在运行iOS 10.2.1的iPad上查看时，您的应用程序未运行在iPhone分辨率。 详情请参阅附件截图。 下一步 请修改您的应用程序，以确保其运行在iPad上以iPhone分辨率正确显示。 资源 有关iOS设备屏幕大小和分辨率的信息，请参阅iOS人机界面指南以及iOS视图编程指南中的点与像素。】 真几下 Release 出现的问题如下： 解决方法如下： 意思是，缺少对应 distribution 下adhoc 的描述文件！ 谨以此记录遇到的神坑（在此，耽误了太久）！ 然审核被拒： 【iPhone程序必须不经修改就能以iPhone分辨率和2倍iPhone 3GS的分辨率在iPad上运行 】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios代码签名探析]]></title>
      <url>%2F2017%2F03%2F14%2Fios%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D%E6%8E%A2%E6%9E%90%2F</url>
      <content type="text"><![CDATA[iOS 证书申请和签名打包流程图 Xcode 团队在 Xcode 8 中移除了 fix issue 之后还需要 fix issue 但是可能还是不能 fix issue 的 Fix Issue 按钮，并完全重新设计了 code signing 的交互，流程和架构，不管对于 iOS 初学者还是有经验的程序员，都能大大简化 code signing 的流程，让我们把精力更专注于实际的业务开发上。 Xcode 8 支持两种签名方式，自动化签名 (Automatic Singing)和自定义签名(Customized Signing) 的。 关于代码签名和签名探析请戳原文：(关于代码签名的分析)[http://joeyio.com] 和 (代码签名的深度探析)[https://objccn.io/issue-17-2/] 用 security 来看看一个 .mobileprovision 文件内部是什么样子： $ security cms -D -i example.mobileprovision 当你真正理解了代码签名的过程，你会感谢他 “用户会感激代码签名带来的好处” – Apple Developer Library: Code Signing Guide 在签名的路上，发现了这一篇好文，剖析的非常透彻，简洁易懂。在此呈献给遇到同样问题的iOS Developer共勉]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIView二三事]]></title>
      <url>%2F2017%2F02%2F27%2FUIView%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[iOS 当中一些偷懒的写法，简单快捷，，其实是利用了一些底层的一些特性 1、直接在 UIView 视图上显示一个 image UIView *layerView = [[UIView alloc] initWithFrame:CGRectMake(50, 200, __MainScreen_Width - 100, 200)]; layerView.backgroundColor = [UIColor orangeColor]; [self.window addSubview:layerView]; UIImage *img = [UIImage imageNamed:@”001”]; layerView.layer.contents = (__bridge id _Nullable)(img.CGImage); //layerView.contentMode = UIViewContentModeScaleAspectFit; //和下边的语句等同 layerView.layer.contentsGravity = kCAGravityResizeAspect; 效果如下图： 苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。 视图的几何属性视图有 frame，center，bounds 等几个基本几何属性，其中: frame 使用的最多，其坐标位置都是相对于父视图的，可以用于确定本视图在父视图中的位置和其自身的大小 center 的坐标位置也是相对于父视图的，通常用于移动，旋转等动画操作 bounds 是相对于自身的，通常情况下就是（0,0,width,height)， bounds 的含义可以认为是当前 view 被允许绘制的范围 布局UIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。 frame代表了图层的外部坐标（也就是在父图层上占据的空间），bounds是内部坐标（{0, 0}通常是图层的左上角），center和position都代表了相对于父图层anchorPoint所在的位置。 视图的frame，bounds和center属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的frame，不能够独立于图层之外改变视图的frame。 对于视图或者图层来说，frame并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据bounds，position和transform计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值 记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了 动画可以以动画的形式改变视图的下面这些属性，只需要告诉系统动画开始和结束时的数值，系统会自动处理中间的过渡过程。 frame bounds center transform alpha backgroundColor contentStretch 锚点anchorPoint是锚点。视图的center属性和图层的position属性都指定了anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame的位置，你可以认为anchorPoint是用来移动图层的把柄。 默认来说，anchorPoint位于图层的中点，所以图层将会以这个点为中心放置。anchorPoint属性并没有被UIView接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的anchorPoint可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动，而不是居中了。 坐标系和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds，如果父图层发生了移动，它的所有子图层也会跟着移动。 这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的绝对位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。 CALayer给不同坐标系之间的图层转换提供了一些工具类方法： 1234- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; - (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; - (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer; 这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形 常规说来，在iOS上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的geometryFlipped属性也设为YES）。 CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：-containsPoint:和-hitTest:。 -containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。 12345678910111213141516171819202122232425- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; //get touch position relative to main view CGPoint point = [[touches anyObject] locationInView:self.view]; //convert point to the white layer&apos;s coordinates point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer]; //get layer using containsPoint: if ([self.layerView.layer containsPoint:point]) &#123; //convert point to blueLayer’s coordinates point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer]; if ([self.blueLayer containsPoint:point]) &#123; [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil] show]; &#125; else &#123; [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil] show]; &#125; &#125;&#125; -hitTest:方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用-containsPoint:那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用-hitTest:方法被点击图层的代码如下： 123456789101112131415161718192021- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; //get touch position CGPoint point = [[touches anyObject] locationInView:self.view]; //get touched layer CALayer *layer = [self.layerView.layer hitTest:point]; //get layer using hitTest if (layer == self.blueLayer) &#123; [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil] show]; &#125; else if (layer == self.layerView.layer) &#123; [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil] show]; &#125;&#125; 注意当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。 阴影iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。 给shadowOpacity属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：shadowColor，shadowOffset和shadowRadius。 显而易见，shadowColor属性控制着阴影的颜色，和borderColor和backgroundColor一样，它的类型也是CGColorRef。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。 shadowOffset属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制着阴影横向的位移，高度控制着纵向的位移。shadowOffset的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。 为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，shadowOffset的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了😁 shadowRadius属性控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给shadowRadius设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显。。 当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有从图层中突出来的内容都会被才剪掉。 shadowPath属性shadowPath是一个CGPathRef类型（一个指向CGPath的指针）。CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。 //enable layer shadows self.layerView1.layer.shadowOpacity = 0.5f; self.layerView2.layer.shadowOpacity = 0.5f; //create a square shadow CGMutablePathRef squarePath = CGPathCreateMutable(); CGPathAddRect(squarePath, NULL, self.layerView1.bounds); self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath); ￼//create a circular shadow CGMutablePathRef circlePath = CGPathCreateMutable(); CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds); self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath); 如果是一个矩形或者是圆，用CGPath会相当简单明了。但是如果是更加复杂一点的图形，UIBezierPath类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。 图层蒙板通过masksToBounds属性，我们可以沿边界裁剪图形；通过cornerRadius属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。 使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。 CALayer有一个属性叫做mask可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，mask图层定义了父图层的部分可见区域。 mask图层的Color属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃 如果mask图层比父图层要小，只有在mask图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。 //create mask layer CALayer maskLayer = [CALayer layer]; maskLayer.frame = self.layerView.bounds; UIImage maskImage = [UIImage imageNamed:@”Cone.png”]; maskLayer.contents = (__bridge id)maskImage.CGImage; //apply mask to image layer￼ self.imageView.layer.mask = maskLayer; CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为mask属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。 当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。 CATextLayer用户界面是无法从一个单独的图片里面构建的。一个设计良好的图标能够很好地表现一个按钮或控件的意图，不过你迟早都要需要一个不错的老式风格的文本标签。 如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用Core Graphics写入图层的内容（这就是UILabel的精髓）。如果越过寄宿于图层的视图，直接在图层上操作，那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类，还要逻辑上判断哪个图层需要显示哪个字符串，更别提还要记录不同的字体，颜色等一系列乱七八糟的东西。 万幸的是这些都是不必要的，Core Animation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。 同样，CATextLayer也要比UILabel渲染得快得多。很少有人知道在iOS 6及之前的版本，UILabel其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而CATextLayer使用了Core text，并且渲染得非常快。 让我们来尝试用CATextLayer来显示一些文字。【用CATextLayer来显示一个纯文本标签】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@interface ViewController ()@property (nonatomic, weak) IBOutlet UIView *labelView;@end@implementation ViewController- (void)viewDidLoad&#123;[super viewDidLoad];//create a text layerCATextLayer *textLayer = [CATextLayer layer];textLayer.frame = self.labelView.bounds;[self.labelView.layer addSublayer:textLayer];//set text attributestextLayer.foregroundColor = [UIColor blackColor].CGColor;textLayer.alignmentMode = kCAAlignmentJustified;textLayer.wrapped = YES;//choose a fontUIFont *font = [UIFont systemFontOfSize:15];//set layer fontCFStringRef fontName = (__bridge CFStringRef)font.fontName;CGFontRef fontRef = CGFontCreateWithFontName(fontName);textLayer.font = fontRef;textLayer.fontSize = font.pointSize;CGFontRelease(fontRef);//choose some textNSString *text = @&quot;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&quot;;//set layer texttextLayer.string = text;&#125;@end 如果我们想以Retina的质量来显示文字，我们就得手动地设置CATextLayer的contentsScale属性，如下： 1textLayer.contentsScale = [UIScreen mainScreen].scale; CATiledLayer有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。 能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048*2048，或4096*4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU。 CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。让我们用实验来证明一下。 图片裁剪我们将会选择一张比较大的图片入手。为了能够从CATiledLayer中获益，我们需要把这个图片裁切成许多小一些的图片。你可以通过代码来完成这件事情，但是如果你在运行时读入整个图片并裁切，那CATiledLayer这些所有的性能优点就损失殆尽了。理想情况下来说，最好能够逐个步骤来实现。 下边演示了一个简单的Mac OS命令行程序，它用CATiledLayer将一个图片裁剪成小图并存储到不同的文件中。 动画类型取决于图层行为 Core Animation是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。 事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。 事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。 任何可以做动画的图层属性都会被添加到栈顶的事务，你可以通过+setAnimationDuration:方法设置当前事务的动画时间，或者通过+animationDuration方法来获取值（默认0.25秒）。 Core Animation在每个run loop周期中自动开始一次新的事务（run loop是iOS负责收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显式的用[CATransaction begin]开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。 使用CATransaction控制动画时间 1234567891011121314- (IBAction)changeColor&#123; //begin a new transaction [CATransaction begin]; //set the animation duration to 1 second [CATransaction setAnimationDuration:1.0]; //randomize the layer background color CGFloat red = arc4random() / (CGFloat)INT_MAX; CGFloat green = arc4random() / (CGFloat)INT_MAX; CGFloat blue = arc4random() / (CGFloat)INT_MAX; self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor; ￼//commit the transaction [CATransaction commit];&#125; ================================================================================1velocity = change / time 现实生活中的任何一个物体都会在运动中加速或者减速。那么我们如何在动画中实现这种加速度呢？一种方法是使用物理引擎来对运动物体的摩擦和动量来建模，然而这会使得计算过于复杂。我们称这种类型的方程为缓冲函数，幸运的是，Core Animation内嵌了一系列标准函数提供给我们使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Best Free Apps For Mac]]></title>
      <url>%2F2017%2F02%2F23%2FBest-Free-Apps-For-Mac%2F</url>
      <content type="text"><![CDATA[​ 网络的世界犹如浩瀚的海洋一样，深不见底，亦摸不着边际，Best Free Apps For Mac ——Xclient 是屌丝逆袭的首选！ 网址如下： 需要什么请戳Best Free Apps For Mac]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cocoapods安装方式和简单使用]]></title>
      <url>%2F2017%2F02%2F23%2FCocoapods%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Cocoapods安装方式和简单使用1、常规安装方式： 在终端输入命令 : sudo gem install cocoapods 2、便捷安装方式： 通过 Homebrew 安装 CocoaPods，方便而快捷，请戳Mac安装Homebrew 3、Cocoapods使用：1.使用search命令搜索类库名 $ pod search AFNetworking 2.输入命令创建Podfile文件 $ touch Podfile 3.使用vim编辑podfile文件，使用命令 $ vim Podfile 4.i 进入编辑 platform :ios, ‘7.0’target ‘工程名’ do pod ‘pop’, ‘~&gt;1.0.9’ pod ‘AFNetworking’, ‘~&gt;3.1.0’ pod ‘MJRefresh’, ‘~&gt;3.1.12’end意思是，iOS支持的最低版本是iOS 7.0, ~&gt;后边的是当前类库下载的版本号。 5.在编辑完后按 esc,然后按”:”,这个时候输入wq保存退出。6.这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令： $ pod install 7.删除某个类库的时候，把 podfile 中对应的那一行删掉，重新执行 pod install 就行参考文献1、https://guides.cocoapods.org/syntax/podfile.html2、http://www.cnblogs.com/jys509/p/4839803.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[比Spotlight 搜索更强大的搜索]]></title>
      <url>%2F2017%2F02%2F22%2F%E6%AF%94Spotlight-%E6%90%9C%E7%B4%A2%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%90%9C%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[​ 相比Windows而言Mac自带的Spotlight搜索已经非常强大了，尤其是Mac OS Yosemite 中对Spotlight进行了比较大幅度的更新，支持了简单的单位转换、显示在地图中搜索的位置、直接显示搜索到的联系人信息和直接搜索iTunes store中的媒体信息等等。但是这一切Alfred早已做到，并且这款软件支持自定义，不管是本机内容还是网络内容，你只需要简单的输入几个字母或者汉字就可以得到你想要的。是OS X下搜索的神兵利器。最新发布的Alfred 3.3和谐版，喜欢的收下⤵️ 和谐版Alfred下载地址 插件下载地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS网络编程的三种方式]]></title>
      <url>%2F2017%2F02%2F21%2FiOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[iOS 可以采用三类api 接口进行网络编程，根据抽象层次从低到高分别为socket方式、stream方式、url 方式 一 、socket 方式【比如：ASIHttpRequest】 ​ iOS 提供的socket 方式的网络编程接口为CFSocket。CFSocket是BSD sockets的抽象和封装，CFSocket提供BSD sockets几乎所有的功能，并与run loop集成，用来实现多线程网络编程和网络事件监听。基于 CFSocket可以实现各种类型的 socket编程，包括stream-based 的sockets(如tcp)和packet-based 的sockets(如udp)。需要注意的是在iOS中CFSocket接口在需要时不自动激活设备的 cellular modem或on-demand VPN。 CFSocket包括以下编程接口，包括Socket的 创建、配置，以及根据创建和配置好的Socket 进行 远程通讯等接口。 1. Socket的 创建1 .1、CFSocketCreate创建一个特定协议和类型的 CFSocket对象 1.2、CFSocketCreateWithSocketSignature该接口根据一个包含通讯协议和地址的CFSocketSignature结构来创建一个CFSocket对象 1.3、 CFSocketCreateConnectedToSocketSignature该接口在创建一个CFSocket对象的同时还与一个远端主机进行连接。 1.4、CFSocketCreateWithNative该接口通过封装一个存在的 BSD socket来创建一个CFSocket对象。 2. Socket的配置2.1 CFSocketCopyAddress功能： 返回一个 CFSocket对象的本地地址。 语法：（Swift）func CFSocketCopyAddress(_ s: CFSocket!) -&gt; CFData! 2.2、CFSocketCopyPeerAddress功能：返回与一个 CFSocket对象连接的远端地址。 语法：（Swift）func CFSocketCopyPeerAddress(_ s: CFSocket!) -&gt; CFData! 2.3 CFSocketDisableCallBacks功能：临时取消一个CFSocket对象创建时指定的某种类型的事件回调。 语法：Swift func CFSocketDisableCallBacks(_ s: CFSocket!, _ callBackTypes: CFOptionFlags) 2.4 CFSocketEnableCallBacks功能：重新允许先前CFSocketDisableCallBacks函数取消的某种类型的事件回调。 语法：（Swift）func CFSocketEnableCallBacks(_ s: CFSocket!, _ callBackTypes: CFOptionFlags) 2.5 CFSocketGetContext功能：返回一个CFSocket对象的上下文信息。 语法：（Swift）func CFSocketGetContext(_ s: CFSocket!, _ context: UnsafeMutablePointer&lt;CFSocketContext&gt;) 2.6 CFSocketGetNative返回与一个CFSocket对象相关的本地 BSD socket。 语法：（Swift）func CFSocketGetNative(_ s: CFSocket!) -&gt; CFSocketNativeHandle 2.7 CFSocketGetSocketFlags功能：返回控制一个CFSocket对象的确定行为的 标志。 语法：（Swift）func CFSocketGetSocketFlags(_ s: CFSocket!) -&gt; CFOptionFlags 2.8 CFSocketSetSocketFlags功能：设置控制一个CFSocket对象的确定行为的 标志。 语法：（Swift）func CFSocketSetSocketFlags(_ s: CFSocket!, _ flags: CFOptionFlags) 2.9 CFSocketSetAddress功能：为一个CFSocket对象绑定一个本地地址并在本地socket支持的情况下对socket进行配置使其处于监听状态。该函数对应本地socket的 bind以及listen功能。一旦CFSocket对象绑定地址，依赖于socket的协议，其它进程和主机能连接到该CFSocket对象。 语法：（Swift）func CFSocketSetAddress(_ s: CFSocket!, _ address: CFData!) -&gt; CFSocketError 3. Sockets的使用3.1 CFSocketConnectToAddress功能：打开与一个远程socket的一个连接。 语法：（Swift）func CFSocketConnectToAddress(_ s: CFSocket!, _ address: CFData!, _ timeout: CFTimeInterval) -&gt; CFSocketError 3.2 CFSocketCreateRunLoopSource语法：（Swift）func CFSocketCreateRunLoopSource(_ allocator: CFAllocator!, _ s: CFSocket!, _ order: CFIndex) -&gt; CFRunLoopSource! 功能：为一个CFSocket对象创建一个CFRunLoopSource对象。该创建的 CFRunLoopSource对象不自动添加到一个run loop。为了增加该run loop source到某个run loop，需要调用CFRunLoop对象 的CFRunLoopAddSource函数来为该CFRunLoop对象添加run loop source。 3.3 CFSocketGetTypeID功能：返回CFSocket对象的 opaque类型对应的类型标示符。 语法：（Swift）func CFSocketGetTypeID() -&gt; CFTypeID 3.4 CFSocketInvalidate功能：使一个CFSocket对象无效，使其停止接收和发送任何消息。 语法：（Swift）func CFSocketInvalidate(_ s: CFSocket!) 3.5 CFSocketIsValid功能：返回一个指示一个CFSocket对象是否有效及是否能够发送和接收消息的布尔值。 语法：（Swift）func CFSocketIsValid(_ s: CFSocket!) -&gt; Boolean 3.6 CFSocketSendData功能：该函数用来通过一个CFSocket对象发送数据。 语法：（Swift）func CFSocketSendData(_ s: CFSocket!, _ address: CFData!, _ data: CFData!, _ timeout: CFTimeInterval) -&gt; CFSocketError PS:上述语法摘录自网络！！！ 二、stream编程模式【比如：AFNetworking】 ​ stream编程模式提供了与 unix 的文件操作类似的模式。首先创建和设置流，接着打开流，然后读写流，在流存在时还可以通过查询流的相关属性来读取流的相关信息，在流使用完毕后关闭流。 iOS 为stream编程模式提供的api编程接口包括两大类，一类是Core Foundation框架层用[**C语言**](http://lib.csdn.net/base/c)实现的CFStream API（包括CFStream、 CFReadStream 、CFWriteStream等）,一类是基于其上的在Foundation框架层用[**Objective-C**](http://lib.csdn.net/base/objective-c)语言实现的NSStream API（包括NSStream、NSInputStream NSOutputStream等）,两者提供相似的接口和行为，其中某些对象是toll-free bridged类型的，如CFStream 与NSStream，CFReadStream与NSInputStream，CFWriteStream与NSOutputStream之间，因此可以混合使用。 开发人员可以根据自己的语言偏好选择使用。 CFStream API的主要接口： 1、CFStream 创建接口1.1 CFStreamCreatePairWithPeerSocketSignature功能：创建一对到一个socket的可读和可写流。 1.2 CFStreamCreatePairWithSocketToHost功能：创建连接到一个特定主机的特定端口的一对可读写流。 1.3 CFStreamCreatePairWithSocket功能：创建一对连接到一个socket的可读写流 1.4 CFStreamCreateBoundPair功能：创建一对读写流。 其它可读写流创建接口： 1.5 CFReadStreamCreateForHTTPRequest 功能：为一个CFHTTP请求创建一个可读流。 1.6 CFReadStreamCreateForStreamedHTTPRequest功能：为一个HTTP请求的body保持在内存的CFHTTP请求创建一个可读流。 1.7 CFReadStreamCreateWithFTPURL功能：创建一个FTP可读流 1.8 CFWriteStreamCreateWithFTPURL功能：创建一个FTP可读流 2. CFReadStream接口2.1 流的打开和关闭CFReadStreamOpen CFReadStreamClose 2.2 读取数据CFReadStreamRead 2.3. 调度一个可读流​ CFReadStreamScheduleWithRunLoop(::_:) CFReadStreamUnscheduleFromRunLoop(_:_:_:) 2.4 检查可读流的属性​ CFReadStreamCopyProperty(::) ​ CFReadStreamGetBuffer(::_:) ​ CFReadStreamCopyError(_:) ​ CFReadStreamGetError(_:) ​ CFReadStreamGetStatus(_:) ​ CFReadStreamHasBytesAvailable(_:) 2.5 设置可读流的属性​ CFReadStreamSetClient(::::) ​ CFReadStreamSetProperty(::_:) 2.6 得到 CFReadStream的 Type IDCFReadStreamGetTypeID() 3.CFWriteStream 相关接口3.1 CFWriteStreamClose(_:) 3.2 CFWriteStreamOpen(_:) 3.3 CFWriteStreamWrite(_:_:_:) ​ 3.4 CFWriteStreamScheduleWithRunLoop(::_:) 3.5 CFWriteStreamUnscheduleFromRunLoop(_:_:_:) ​ 3.6 CFWriteStreamCanAcceptBytes(_:) 3.7 CFWriteStreamCopyProperty(_:_:) 3.8 CFWriteStreamCopyError(_:) 3.9 CFWriteStreamGetError(_:) 3.10 CFWriteStreamGetStatus(_:) ​ 3.11 CFWriteStreamSetClient(::::) 3.12 CFWriteStreamSetProperty(_:_:_:) 3.13 CFWriteStreamGetTypeID() CFStream API的使用步骤：1） 利用流创建接口创建相关流； 2）、调用CFReadStreamSetClient （可读流）或CFWriteStreamSetClient （可写流）来登记要接收的流相关的事件； 3）、调用CFReadStreamScheduleWithRunLoop（可读流）或CFWriteStreamScheduleWithRunLoop（可写流）来使在流在一个run loop上进行调度以便接收相关事件； 4）、调用CFReadStreamOpen 或CFWriteStreamOpen 来打开已创建的流； 5）、在读取流的创建时登记的回调中，在接收到kCFStreamEventHasBytesAvailable事件时来读取数据， 在可写流已登记的回调中，在接收到kCFStreamEventCanAcceptBytes 事件时开始发送数据或请求； 6） 数据传输完成，关闭和释放打开和创建的相关流； 三、url 编程模式 url 编程模式通过URL 的方式来实现网络编程，任何要存取的网络资源（包括局域网和广域网）都可以用一个URL来表示和存取，并支持设备间的资源共享。url 编程模式系统提供http, https, file, ftp, data等五种协议支持，并允许用户自己开发和登记相关类来支持另外的应用层网络协议，进行协议的扩展。 ​ url 编程模式在IOS系统可以使用两种编程接口：NSURLSession 和NSURLConnection。 ​ 对于iOS 7 以后的最新系统推荐使用NSURLSession API，对于老版本由于不支持NSURLSession，因此必须使用NSURLConnection API。 ​ NSURLSession编程模式是对相关的连接请求通过一个会话来完成，应用通过创建一系列sessions来实现网络通讯，每一个session协调一组相关数据的传输任务。在每一个session内，应用添加一系列任务，每一个任务表现一个特定URL 请求。 NSURLSession相比NSURLConnection的优点是支持在应用挂起、停止或crashed时能够在后台继续下载数据，即支持任务的取消、重启（恢复）、挂起，以及支持从已挂起、取消或失败的下载中重新恢复下载的能力。 对于简单的请求，还可以直接通过一个简单的NSURL对象来发出请求，并使用一个NSData内存对象或者一个文件的方式来引出NSURL指向的内容。而NSURLConnection API只能通过构造一个NSURLRequest对象或其子类来发出URL请求来请求下载或上传URL数据。 使用一个NSURLRequest请求对象封装一个URL请求，例如HTTP协议方法，除了可以封装一些协议特定的属性外，还可以规定任意本地cached数据的使用策略。 对于NSURLRequest请求对象的应答包括两部分：描述内容的元数据metadata及内容数据本身。两种API对于使用NSURLRequest请求接收的元数据metadata都由NSURLResponse类来封装，其中包含MIME类型、内容长度、编码及提供应答的URL等内容。NSURLResponse协议特定的子类还能提供额外的元数据，如NSHTTPURLResponse提供协议头和WEB服务器返回的状态码 等信息。 NSURLSession API的使用： NSURLSession类支持三种会话类型（默认会话类型、临时会话、后台会话）以及三种类型的任务（数据任务、下载任务、上传任务）。 数据任务使用NSData 对象来发送和接收内存数据，不存储数据到一个文件，因此不支持后台会话。 下载任务以一个文件的形式引出数据，并支持在应用没有运行时的后台下载。 上传任务用来上传数据（文件），也能够支持应用没有运行时的后台上传。 默认会话和后台会话的区别是后台会话使用一个分离的进程处理所有的数据传输任务，并带有一些限制：后台会话必须使用特定应用代理来提供事件提交，并仅支持HTTP和HTTPS 协议，不支持其它定制协议，并仅支持上传和下载任务，不支持数据任务。 临时会话不存储任何数据到磁盘，所有接收的内容都保存到与会话关联的RAM中，当会话无效时，RAM中接收的内容自动被清除。 NSURLSession API的使用步骤： 1 、创建一个NSURLSessionConfiguration配置对象 NSURLSessionConfiguration配置对象提供广泛的配置选项，包括： 1）、特定于单个会话的私有数据存储，包括caches, cookies, credentials, 和protocols； 2）、与一个特定请求或一个会话关联的Authentication； 3）、与一个主机的最大连接数； 4）、与一个资源关联的超时； 5）、最小和最大TLS版本支持； 6）、定制的代理词典； 7）、cookie策略的控制； 8）、HTTP pipelining行为的控制 2、根据配置创建相应的NSURLSession； NSURLSession API通过代理来实现异步URL内容存取，代理可以是系统提供的代理，还可以是应用提供的特定代理对象。任务对象当从服务器接收到数据或传输完成时调用这些代理对象的方法。 在创建会话指定相应的代理对象。 3、为会话添加任务； 使用如下方法来添加数据任务到一个会话。 dataTaskWithURL(_:) dataTaskWithURL(_:completionHandler:) dataTaskWithRequest(_:) dataTaskWithRequest(_:completionHandler:) ​ 使用如下方法来添加下载任务到一个会话。 downloadTaskWithURL(_:) downloadTaskWithURL(_:completionHandler:) downloadTaskWithRequest(_:) downloadTaskWithRequest(_:completionHandler:) downloadTaskWithResumeData(_:) downloadTaskWithResumeData(_:completionHandler:) 使用如下方法来添加上传任务到一个会话 uploadTaskWithRequest(_:fromData:) uploadTaskWithRequest(_:fromData:completionHandler:) uploadTaskWithRequest(_:fromFile:) uploadTaskWithRequest(_:fromFile:completionHandler:) uploadTaskWithStreamedRequest(_:) 4、使用代理方法接收数据及状态信息 会话的数据任务在使用应用特定代理接收数据时必须实现如下两个代理方法： URLSession:dataTask:didReceiveData: 一次一片的提供请求的数据给会话任务。 URLSession:task:didCompleteWithError: 指示请求数据已经全部接收。 会话的下载任务在下载文件时应该实现如下代理方法： URLSession:downloadTask:didFinishDownloadingToURL: 下载内容存储到一个URL指定的一个临时文件，在该方法返回之前，必须把临时文件的内容移到一个永久位置，而临时文件被删除。 URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite: 为应用提供关于当前下载进度的状态信息 URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes: 告诉应用已经从从先前的失败下载中恢复。 URLSession:task:didCompleteWithError: 告诉应用下载已经失败。 下载失败恢复处理： 在应用使用cancelByProducingResumeData: 方法取消下载任务时，可以使用downloadTaskWithResumeData: 或 downloadTaskWithResumeData:completionHandler:方法重新创建一个新下载任务并传送cancelByProducingResumeData:产生的恢复数据从而接着继续下载。 在传输失败时，如果任务可恢复，则调用URLSession:task:didCompleteWithError: 方法。在传送给URLSession:task:didCompleteWithError: 方法的参数NSError中的 userInfo 词典中包含键值为NSURLSessionDownloadTaskResumeData的恢复数据，因此可以使用downloadTaskWithResumeData: 或 downloadTaskWithResumeData:completionHandler:方法重新创建一个新下载任务来接着恢复数据继续下载。 系统代理仅能支持基本的URL资源存取任务，不支持认证和后台下载，并且还必须提供一个completion handler block来把返回的URL数据提交到应用。 会话的上传任务的任务创建和相关代理方法： 会话的上传任务使用HTTP POST方法来上传数据。可以以一个NSData对象、一个文件或使用一个流为HTTP POST请求的body提供内容。 在以NSData对象提供上传数据时，应用调用uploadTaskWithRequest:fromData: 或uploadTaskWithRequest:fromData:completionHandler: 方法来创建上传任务。 ​ 在以文件形式提供上传数据时，应用调用uploadTaskWithRequest:fromFile: 或 uploadTaskWithRequest:fromFile:completionHandler:方法来创建上传任务 ​ 在以流方式提供上传数据时，应用调用uploadTaskWithStreamedRequest:方法来创建上传任务。 应用特定代理可以通过实现URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:方法来获得上传进度信息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试知识点总结]]></title>
      <url>%2F2017%2F02%2F17%2F%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[多线程相关知识点汇总1.请简单说明多线程技术的优点和缺点？优点： 能够适当提高程序的执行效率； 能够适当的提高资源的利用率，比如CPU、内存。 缺点： 创建线程有额外开销 程序的代码更加复杂 线程越多，CPU在调度线程上的开销就越大 如果开启大量线程，反而会降低程序的性能 2.请简单说明线程和进程，以及他们之间的关系？ 进程是CPU调度和分配资源的单位。 线程是CPU调用的最小单位 关系： 进程包含线程； 一个程序可以对应多个进程，一个进程中可以有多个线程，但至少要有一个线程； 同一个进程内的线程共享进程的资源。 3.请简单说明在iOS开发中有哪些多线程的实现方案？ PThread NSThread GCD NSOperation 4.请简单说明主线程的作用，以及使用注意点？主线程:默认启动的线程 作用: 显示和刷新UI界面 处理UI事件 注意点: 不要将耗时操作放在主线程中执行 UI操作必须在主线程中执行 !!!! 5.请简单列出NSThread线程的几种状态，并说明状态转换的逻辑？新建——就绪 CPU 调度当前任务——阻塞——死亡 CPU调度其他任务——就绪 6.请简单说明如何简单的解决多线程访问同一块资源造成的线程安全的问题，以及注意点？ 加同步(互斥)锁 @synchronized OC中的同步锁:(锁对象) + {要锁住的代码} 锁对象:要求是全局唯一的属性 注意点: 要注意加锁的位置 加锁需要耗费性能,因此需要注意加锁的条件(多线程访问同一块资源) 专业术语:线程同步 7.请简单介绍下什么是原子和非原子属性？ atomic：原子属性，会为setter方法加锁，默认为atomic。线程安全，会消耗大量资源 nonatomic：非原子属性，不会为setter方法加锁。非线程安全，适合内存小的移动设备。 8.请简单介绍下GCD这门技术？ 全称 Grand Central Dispatch，中枢调度器。 GCD中有2个核心概念:任务和队列。 GCD使用:封装任务，将封装好的任务添加到队列中，遵循FIFO。 9.请简单介绍GCD中的几种队列？（4种） 并发队列：多个任务同时执行，会开启多个线程同时执行任务，只有在异步函数下才有效。 串行队列：任务只能一个接一个的去执行，不会开启多个线程，主队列属于串行队列，主队列所有的任务必须在主线程中执行。 全局队列 主队列 10.如果当前有多个任务，这些任务都需要开子线程执行，而多个任务之间有一定的依赖关系，如果使用GCD来实现请试着给出一些解决方案。 使用异步函数（同步函数）+主队列 11.请简单说明单例模式的特点（作用）？ 如果一个类实现了单例，那么可以保证在程序运行过程，一个类只有一个实例 单例对象易于供外界访问（通常会提供一个类方法） 实现了单例模式后，可以方便地控制了实例个数，并节约系统资源 12.请简单介绍操作队列？ 操作队列本身是OC语言的，在iOS开发中可以用来实现多线程编程 操作队列有两大核心的概念，一个是操作（NSOperation），一个是队列(NSOperationQueue),操作用来封装任务，队列用来存放操作 要使用操作队列进行多线程编程，只需要把封装好的操作提交到相应的队列中即可，系统内部会视情况自动开启相应的线程来执行任务 在操作队列这门技术中，系统提供了两个子类可以来封装任务，一个是NSInvocationOperation，一个是NSBlockOperation,除此之外也可以直接自定义操作 操作队列中有两种队列，一种是通过[NSOperationQueue mainQueue]获得的主队列，一种是通过[[NSOperationQueue alloc]init]方法获得的非主队列 主队列是和主线程相关的串行队列，提交到主队列中的操作将被安排在主线程中执行（可以利用该特性来处理线程间通信的相关逻辑） 操作+队列: NSInvocationOperation NSBlockOperatio NSOperationQueue 自己创建 [[NSOperationQueue alloc]init]; 主队列 [NSOperationQueue main]; 13.如果有多个操作如何来设置依赖关系，如何监听到某个操作执行完毕事件？ 设置依赖关系：假设有有两个操作分别是op1和op2，op1需要依赖于op2,那么只需要使用[op1 addDependency:op2]方法设置即可。 操作依赖补充：使用操作队列可以方便的指定多个操作间的依赖关系，甚至可以实现跨队列的操作依赖，但是在使用的时候需要注意操作之间不能有循环依赖关系 操作监听：可以使用^completionBlock来实现操作监听 14.请简单比较GCD中的全局并发队列和使用dispatch_queue_create函数创建的并发队列异同？ 全局并发队列在整个应用程序中本身是默认存在的并且对应有高优先级、默认优先级、低优先级和后台优先级一共四个并发队列，我们只是选择其中的一个直接拿来用。而Create函数是实打实的从头开始去创建一个队列。 在iOS6.0之前，在GCD中凡是使用了带Create和retain的函数在最后都需要做一次release操作。而主队列和全局并发队列不需要我们手动release。当然了，在iOS6.0之后GCD已经被纳入到了ARC的内存管理范畴中，即便是使用retain或者create函数创建的对象也不再需要开发人员手动释放，我们像对待普通OC对象一样对待GCD就OK。 在使用栅栏函数的时候，栅栏函数只有在和使用create函数自己的创建的并发队列一起使用的时候才有效 其它区别涉及到XNU内核的系统级线程编程，不一一列举。 15.请简单说明对图片进行二级缓存的实现思路？在显示图片的时候 1）先检查该图片对应的内存缓存 如果存在内存缓存，则 a.直接使用设置并显示图片； 如果内存缓存中没有,则 a.继续检查该图片对应的磁盘缓存是否存在，跳转到第2步。 2）检查该图片对应的磁盘缓存 如果存在磁盘缓存，则 a.先保存一份到内存缓存中（方便下次使用） b.然后设置并显示图片 2.如果不存在磁盘缓存，则直接下载该图片，下载完成后 保存一份到内存缓存中 保存一份到磁盘缓存中 设置并显示图片 16.请简单对比下GCD和NSOperation两种多线程的实现方案？ GCD是纯C语言的API,而操作队列则是Object-C的对象。 在GCD中，任务用块（block）来表示，而块是个轻量级的数据结构；相反操作队列中的『操作』NSOperation则是个更加重量级的Object-C对象。 具体该使用GCD还是使用NSOperation需要看具体的情况，如果只是想简单开一个子线程执行任务推荐使用GCD，如果有很多任务需要开多个子线程下载推荐使用操作队列 17.请按照自己的理解，说一说在进行多线程编程的时候相对于GCD而言，操作队列有哪些优势？NSOperation和NSOperationQueue的好处有： NSOperationQueue可以方便的调用cancel方法来取消某个操作，而GCD中的任务是无法被取消的（安排好任务之后就不管了）。 NSOperation可以方便的指定操作间的依赖关系。 NSOperation可以通过KVO提供对NSOperation对象的精细控制（如监听当前操作是否被取消或是否已经完成等） NSOperation可以方便的指定操作优先级。操作优先级表示此操作与队列中其它操作之间的优先关系，优先级高的操作先执行，优先级低的后执行。 通过自定义NSOperation的子类可以实现操作重用 18.请谈一谈，自定义操作的好处？ 自定义操作，对操作进行封装，那么以后在使用的时候只需要alloc init即可，创建该操作的人不需要关系内部的代码实现，信息隐蔽。 自定义操作有助于代码重用 19.请简单介绍GCD中的一次性代码?一次性代码： 123456static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;-------&quot;); &#125;); 特点： 在整个程序运行过程中block中的代码只会被执行一次 一次性代码本身是线程安全的 常用于单例模式的实现中 20.GCD中的dispatch_after是延迟把任务提交到队列还是先提交到队列再延迟执行？是延迟之后在把任务提交到队列执行，把任务提交到队列中在延迟执行难度较大，不容易实现. 21.请说明NSRunloop和线程的关系? 线程和runloop是一一对应的关系(字典) 主线程对应的runloop是默认创建并启动的 子线程对应的runloop需要手动的创建并启动 如何获得子线程对应的runloop?[NSRunloop currentRunloop]该方法是懒加载的,在第一次调用该方法的时候发现该子线程对应的runloop不存在则会直接创建一个runloop保存并且返回. 线程销毁后runloop也要销毁 Runloop1.什么是runloop? 从字面意思看：运行循环、跑圈.其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer） 一个线程对应一个RunLoop，主线程的RunLoop默认已经启动，子线程的RunLoop得手动启动（调用run方法） RunLoop只能选择一个Mode启动，如果当前Mode中没何Source(Sources0、Sources1)、Timer，那么就直接退出RunLoop 2.runloop的自动释放池什么时候创建释放？ 当runloop进入的时候会创建一个自动释放池。 当runloop退出的时候会把之前的自动释放池销毁。 当runloop即将进入休眠的时候会把之前的自动释放池先销毁，然后创建一个新的自动释放池。 3.请简单说明runloop中几个类之间的相互关系（runloop &amp; source &amp; timer &amp;observer &amp;mode） runloop启动之后会选择一种运行模式，在执行执行会先检查运行模式内部是否有source和timers,如果一个sourc或者是一个timer都没有那么runlooop启动之后就立刻退出了。 runlooop的source有两种分类方法，按照以前的分类方法可以分为：①基于端口的；②自定义的；③performSelector事件；④按照函数调用栈来划分，可以分为source0和soucr1。 observer，可以用来监听当前runloop运行状态的改变，注意（Core foundation框架） NSTimer必须添加到runloop中才会工作，且其工作收到runloop运行模式的影响。 4.请简单说明NSRunloop的基本作用? 保持程序的持续运行 处理App中的各种事件（比如触摸事件、定时器事件、Selector事件） 节省CPU资源，提高程序性能：该做事时做事，该休息时休息 缓存（SDWebImage）1.请简单说明NSCache的特点 NSCache是苹果推出专门用来处理内存缓存的类 NSCache默认是线程安全的,在使用的时候可以不用考虑线程安全的问题 NSCache使用方法和可变字典类似,当缓存文件超过最大限度的时候会开启一个回收过程,把最老的缓存对象回收 NSCache可以设置缓存的const(成本)和缓存的数量 2.请简单介绍下SDWebImage框架？ SDWebImage框架是一款非常流行的用来处理图片下载和缓存的第三方框架 SDWebImage框架为我们提供了高性能异步下载图片的方案，内部使用GCD等多线程相关技术 使用SDWebImage框架来下载图片，它内部默认会对图片进行内存缓存和磁盘缓存的二级缓存结构 该框架为UIButton,UIImageView等UI控件提供了分类，能够方便的处理相关控件图片的远程下载和缓存设置 该框架内部还提供了GIF图片播放，判断图片类型等一般功能 3.请问SDWebImage框架内部在清理磁盘缓存的时候clearDisk方法和cleanDisk方法有什么区别？ clearDisk:直接把整个缓存文件删除，删除之后创建一个新的空文件; cleanDisk:先删除过期的缓存文件，然后计算当前剩余缓存文件的大小,如果该数值超过设定的最大缓存大小，那么久安全文件创建的时间从远到近依次删除，直到整个剩余缓存文件大小小于设定的最大缓存大小为止。 4.请问SDWebImage框架的框架结构是怎么样的？SDWebImage框架有几个主要的组件： 管理者（SDWebImageManager) 缓存处理组件（SDImageCache）主要对下载的图片进行内存缓存和磁盘缓存处理 下载处理组件（SDWebImageDownloader|SDWebImageDownloadOperation）主要处理开子线程异步发送网络请求下载图片相关操作 5.请问SDWebImage框架内部怎么处理内存缓存的？ 内部使用NSCache来专门处理内存缓存 网络通信1.请简单说明HTTP通信的过程？ 请求：如果客户端想要获得相应的数据，那么就对着服务器发送一个请求，请求是客户端向服务器索要数据的过程。 响应：服务器接收到客户端的请求之后，需要对该请求作出反应，响应是服务器端把数据返回给客户端的过程。 请求分为两部分，一个是请求头，一个是请求体（GET请求没有请求体）。其中请求头是对客户端信息和请求本身的描述，而请求体存放要发送给服务器端的具体数据 响应分为两部分，一个是响应头，一个是响应体。其中响应头是对服务器端信息和响应数据本身的描述，而响应体存放要发送给客户端的具体数据。 2.请简单列出使用NSURLConnection发送一个异步POST网络请求的步骤? 确定请求路径（URL） 创建可变的请求对象（NSMutableURLRequest） 修改请求方法为POST请求 把参数拼接起来转换为二进制数据，设置请求体 使用NSURLConnection发送异步请求([NSURLConnection sendAsync….]) 解析服务器返回的数据，查看请求结果 3.请简单说明使用NSURLConnection发送网络请求的几种方法？ 使用NSURLConnection发送同步请求（[NSURLConnection sendSync….]） 使用NSURLConnection发送异步请求1（[NSURLConnection sendAsync…]） 使用NSURLConnection发送异步请求2（设置代理，再发送网络请求） 4.请简单说明GET请求和POST个请求有什么区别,如何选择？ GET请求的参数直接用&amp;拼接并以？为分隔拼接在请求URL的后面 POST请求的参数是转换为二进制设置在请求体传递的 如果仅仅只是索取数据获得数据，那么建议使用GET请求，其他情况则建议使用POST请求，相对而言POST请求安全性更好一些。 5.请简单说明NSURLSession对比NSURLConnection的优势？ session支持http2.0协议(iOS 9.0 +) 在处理下载任务的时候可以直接把数据下载到磁盘 支持后台下载|上传 同一个session发送多个请求，只需要建立一次连接（复用了TCP） 提供了全局的session并且可以统一配置，使用更加方便 下载的时候是多线程异步处理的效率更高 6.请简单列出NSURLSession发送POST请求的步骤？ 确定请求路径(NSURL) 创建可变的请求对象(NSMutableURLRequest) 修改请求方法为POST(HTTPMethod) 把要传递的参数拼接，转换为二进制数据，设置为请求体(HTTPBody) 创建会话对象（NSURLSession shareSession） 根据会话对象来创建一个NSURLSessionDataTask任务 执行请求Task (需要调用Resume方法) 拿到服务器返回的数据之后，解析数据 7.在发送网络请求的时候，如果请求路径中的参数有中文导致发送的网络请求失败，应该如何处理？ 如果URL字符串中有中文，那么在进行使用发送请求的时候应该先对URL进行中文转码 相关方法： [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding] 8.观察下面的代码，请问completionHandler在主线程还是子线程执行？[[session dataTaskWithRequest:request completionHandler:^(NSData _Nullable data, NSURLResponse _Nullable response, NSError * _Nullable error) { //.... }] resume]; completionHandler在子线程中执行。 9.请简单介绍下网络响应的状态码？ 状态码的职责是当客户端向服务器端发送请求时,描述返回的请求结果。借助状态码,用户可以知道服务器端是正常处理了请求还是出现了错误。 如200 OK状态码以3位数字+原因短语组成。数字中的第一位指定了响应的类别, 后两位无分类。 状态码分为五种类别，分别是： ①以1开头的（如100），定义范围为100~101，表示接收的请求正在处理，原因短语为Informational(信息性状 态码)。 ②以2开头的（如200），定义范围为200~206，表示请求正常处理完毕，原因短语为Success(成功状态码)。 ③以3开头的（如300），定义范围为300~305，表示需要进行附加的操作以完成网络请求，原因短语为Redirection(重定向状态 码)。 ④以4开头的（如404），定义范围为400~415，表示客户端有错误，服务器无法处理请求，原因短语为Client error(客户端错误)。 ⑤以5开头的（如500），定义范围为500~505，表示服务器端处理请求出错，原因短语为Server error(服务器错误)。 10.使用NSURLSession发送网络请求的时候，最多可以建立多少个TCP连接？ 在iOS中最多可以建立4个连接，在OSX中默认最多可以建立6个连接。 在iOS中NSURLSessionConguration内部有HTTPMaximumConnectionsPerHost属性,可以设置连接的数 量:The default value is 6 in OS X, or 4 in iOS 说明： ①由于HTTP/1.1 不支持多路复用,因此如果要处理多个网络请求,在处理HTTP请求的时候 多数浏览器厂商都是不假思索的就在客户端排队所有的HTTP请求,然后通过一个持久连接,一个接着一个的发送这些请求。然而这种方式性能实在太差。实际上,浏览器开发商对于对于此性能问题,尚没有任何更好的办法,因此只能允许客户端并行打开多个TCP连接会话。但是具体最多可以打开多少个TCP连接是有数量限制的, 多数现代的浏览器,包括桌面和移动浏览器,都支持打开6个连接。即客户端可以并行分派最多6个请求,服务器可以并行处理最多6个请求。 ②为什么是6个连接?有什么特殊的意义吗?其实，这个数字是多方平衡后的结果:这个数字越大,便能够带来更多的请求并行能力,但是同样的客户端和服务器端所占用的资源也会越多。因此,每个主机6个连接只不过是大家都觉得比较安全,能够接受的一个数字而已。 数据结构1.请简单介绍JSON和XML？ JSON和XML都是一种用来表示数据的一种数据格式，JSON更加轻量级。 服务器返回的数据通常是JSON的或者是XML的两种，JSON数据格式和OC对象中字典和数组有些相似，XML又称为XML文档，XML的语法结构由三部分构成分别是文档声明，元素和属性。 如果服务器返回的数据是JSON，那么在开发中通常需要对JSON数据进行反序列化处理，把JSON数据转换为OC对象。 如果服务器返回的数据是XML格式的，那么需要对XML文档进行解析，解析XML的方式有两种，分别是SAX（从根元素开始解析）和DOM(先把整个XML文档加载进内存再解析) 2.JSON格式中的true和false,对应OC中的什么数据类型，值为多少？ true和false对应OC中的NSNumber数据类型 true对应的值为1，false对应的值为0 3.请简单说明什么是序列化和反序列处理，用到了什么方法？ 反序列化处理，即把JSON数据—&gt;OC对象，使用的方法为：[NSJSONSerialization JSONObjectWithData:jsonData options:kNilOptions error:nil] 序列化处理，即把OC对象—&gt;JSON数据，使用的方法为：[NSJSONSerialization dataWithJSONObject:jsonString options:0 error:nil],注意并不是所有的OC对象都能够序列化为JSON数据 文件下载与上传1.请简单说明输出流的使用步骤【应用于文件下载时】和注意点？使用步骤： 创建输出流（指定路径） 打开输出流（open） 使用输出流写数据 （write…） 关闭输出流 （close） 注意点：数据写完之后一定要关闭输出流 2.请简单说明文件句柄（NSFileHandle）的使用步骤【应用于文件下载时】和注意点？使用步骤： 创建空的文件（路径） 创建文件句柄（指向文件） 默认指向开头 使用文件句柄来写数据（内部边写数据边移动文件句柄指针） 关闭文件句柄(closeFile) 注意点：①在写使用文件句柄指针写数据的时候，内部会自动移动文件句柄指针；②写数据的时候可以设置位置（偏移量），如设置从文件的末尾接着写数据；③使用完毕之后，应该把句柄关闭 3.请简单介绍下NSURLSessionTask的几个子类？ NSURLSessionTask是一个抽象类，如果要使用那么只能使用它的子类; NSURLSessionTask有两个子类，一个是NSURLSessionDataTask,该task可以用来处理一般的网络请求，如GET|POST请求等，一个是NSURLSessionDownloadTask,该downloadTask在处理下载请求的时候有很大的优势; NSURLSessionDataTask有一个子类为NSURLSessionUploadTask,该uploadTask在处理上传请求的时候有优势. 为-fno-objc-arc即可。 4.在使用NSURLSessionDataTask发送请求下载文件的时候，实现断点下载的技术要点是什么？ 所谓断点下载，即只下载完整文件中的某一部分数据，如该文件有10M，那么需要做到只请求下载这个文件中5M~10M的这部分数据 可以通过设置请求头信息来实现，参考代码如下： NSString *header = [NSString stringWithFormat:@”bytes=%zd-“,self.currentSize]; [request setValue:header forHTTPHeaderField:@”Range”] 5.请简单比较使用NSURLSessionDownloadTask下载文件和使用NSURLSessionDataTask下载文件的优劣？ NSURLSessionDataTask下载文件的 优点：可以实现离线断点下载。 缺点：代码复杂 NSURLSessionDownloadTask下载文件的 优点：①内部已经完成了边接收数据边写入到沙盒中的操作（解决了下载大文件时候的内存飙升问题）；②可以方便的实现断点下载。 缺点：无法实现离线断点下载 6.请列出使用NSURLSession发送请求实现文件上传的主要步骤？ 确定上传请求的路径 （NSURL） 创建可变的请求对象（NSMutableURLRequest） 修改请求方法为POST 设置请求头信息（告知服务器端这是一个文件上传请求） 按照固定的格式拼接要上传的文件等参数 根据请求对象创建会话对象（NSURLSession对象） 根据session对象来创建一个uploadTask上传请求任务 执行该上传请求任务（调用resume方法） 得到服务器返回的数据，解析数据（上传成功|上传失败） 7.请列出你认为在进行文件上传时候需要注意的细节(注意点)？ 创建可变的请求对象，因为需要修改请求方法为POST，设置请求头信息 设置请求头这个步骤可能会被遗漏 要处理上传参数的时候，一定要按照固定的格式来进行拼接 需要采用合适的方法来获得上传文件的二进制数据类型（MIMEType） 8.在使用NSURLSession进行文件上传的时候，如何监听文件上传的进度，有哪些注意点？ 创建会话对象的时候，需要设置代理，让控制器成为session的代理 遵守代理协议（NSURLSessionDataDelegate） 实现代理方法，在代理方法中计算文件的上传进度 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend 注意：当任务执行完毕的时候应该释放对代理对象的强引用 网路通信安全1.请简单回答网络安全的原则是什么？ 在网络上”不允许”传输用户隐私数据的”明文” 在本地”不允许”保存用户隐私数据的”明文” 2.请简单介绍下Base64编码？ 特点：可以将任意的二进制数据进行Base64编码 结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。65字符：A~Z a~z 0~9 + / = 对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。 Base64编码原理:①将所有字符转化为ASCII码；②将ASCII码转化为8位二进制；③将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位；④统一在6位二进制前补两个0凑足8位；⑤将补0后的二进制转为十进制；⑥从Base64编码表获取十进制对应的Base64编码。 3.请简单说明单向散列函数的特点？ 加密后密文的长度是定长的 如果明文不一样，那么散列后的结果一定不一样 如果明文一样，那么加密后的密文一定一样（对相同数据加密，加密后的密文一样） 所有的加密算法是公开的 不可以逆推反算 总结： 不可逆 原文相同 散列值相同 原文不同 散列值不同 加密后密文的长度是定长的 4.请简单介绍下散列函数的一些应用领域？ 搜索 多个关键字，先对每个关键字进行散列，然后多个关键字进行或运算，如果值一致则搜索结果一致 版权 对文件进行散列判断该文件是否是正版或原版的 文件完整性验证 对整个文件进行散列，比较散列值判断文件是否完整或被篡改 5.请简单介绍下对称加密的特点和经典算法？特点: 加密和解密使用相同的秘钥 加密和解密的过程是可逆的 性能好，效率高 经典算法 DES 数据加密标准 3DES 使用3个密钥，对消息进行（密钥1·加密）+（密钥2·解密）+（密钥3·加密） AES 高级加密标准 6.请简单说明ECB和CBC两种分组加密模式？ ECB模式的全称为Electronic CodeBook模式。又成为电子密码本模式。 特点：①使用ECB模式加密的时候，相同的明文分组会被转换为相同的密文分组；②类似于一个巨大的明文分组——密文分组的对照表。 CBC模式全称为Cipher Block Chainning模式（密文分组链接模式|电子密码链条） 特点：在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。 7.请简单介绍下非对称加密的特点和经典算法？ 非对称加密的特点: ①使用一个密钥对进行加密和解密，公钥加密，私钥解密；②公钥是公开的，私钥是保密的；③使用非对称加密来处理加密和解密的过程高度安全，但是效率低下，性能很差 经典算法：RSA 8.请简单介绍下数字签名这门技术？ 应用场景：需要严格验证发送方身份信息情况 数字签名原理 客户端处理 1.对&quot;消息&quot;进行 HASH 得到 &quot;消息摘要&quot; 2.发送方使用自己的私钥对&quot;消息摘要&quot; 加密(数字签名) 3.把数字签名附着在&quot;报文&quot;的末尾一起发送给接收方 服务端处理 1.对&quot;消息&quot; HASH 得到 &quot;报文摘要&quot; 2.使用公钥对&quot;数字签名&quot; 解密 3.对结果进行匹配 9.数字证书和公钥什么关系？ 数字证书就是对公钥进行数字签名 证书和驾照很相似，里面记有姓名、组织、地址等个人信息，以及属于此人的公钥，并有认证机构施加数字签名,只要看到公钥证书，我们就可以知道认证机构认证该公钥的确属于此人 数字证书的主要内容：①公钥；②认证机构的数字签名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试添加视频]]></title>
      <url>%2F2017%2F01%2F14%2F%E6%B5%8B%E8%AF%95%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客添加图片、音乐、视频]]></title>
      <url>%2F2017%2F01%2F13%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E3%80%81%E9%9F%B3%E4%B9%90%E3%80%81%E8%A7%86%E9%A2%91%2F</url>
      <content type="text"><![CDATA[Hexo博客添加图片、音乐、视频 ———— “临渊羡鱼，不如退而结网” 一、添加图片既可以是本地图片 ，也可以是添加外部链接图片 1、本地图片在\hexo\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式： 2、外链图片可以使用 iPic 上传图片 二、添加音乐12345&lt;center&gt;&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt; &lt;/center&gt; 三、添加视频视频也和音乐类似，先输入视频标题，回车换一行插入代码即可。 1234"2017小米年会雷军跳鬼步舞视频:"&lt;center&gt; &lt;iframe height=498 width=510 src="http://t.cn/z8AluUz http://t.cn/RMSFvPU" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt; 1234"2017小米年会爆笑神曲“咋了开发”:"&lt;center&gt; &lt;iframe height=498 width=510 src="http://www.toutiao.com/i6374714213071323650/" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《好吗 好的》随笔]]></title>
      <url>%2F2017%2F01%2F04%2F%E3%80%8A%E5%A5%BD%E5%90%97-%E5%A5%BD%E7%9A%84%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
      <content type="text"><![CDATA[好吗好的 书评： 刘敏常说，只要你对得起舞台，舞台就会对得起你。 你是否也有过那种错觉： 牵手的人不会松手，同路的人不会分开，缓缓流淌的岁月永不会改道，昨天和今天所拥有的，总会顺理成章地延续到明天，乃至永远。 世间最大的错觉，无外乎自以为是的永远。 世上大部分永远，大都是一厢情愿的错觉。 万事万物走的都是抛物线，并没有恒久的低谷或顶点，转折点出现时，我和她已搭档了很多年。 她转身，看我一眼，又移开目光。头再转过来时，双臂也轻轻展开在我面前，平静的目光注视着我，她轻声说：过来…… 我又惊讶又好笑，上前接住那个拥抱：干吗，好好的抱我干吗？你什么时候学得这么矫情了？ 她不说话，手轻轻拍在我背上，一下又一下，身体也轻轻地左右摇晃着，好像个哄孩子睡觉的年轻妈妈。我笑，拜托，别老把我当小朋友好吗？我眼瞅快30岁的人了。 她笑笑松开我，说：好了好了，走了走了。 没有告别，她只要走了一个拥抱，平静的目光注视着我，双臂轻轻展开在我面前，她轻声说：过来…… ##########附录########### 早班地铁挤满了上班的人，座位紧张，她不善争，像个农民工一样蹲坐在地上……有观众认出了她，拍下了照片在网络上传给我，我问，为什么不给她让个座？！ 那位观众说让了，她谢了半天，但怎么也不肯坐……她说如果一大清早就安逸了，接下来一整天的斗志也就全没了。 你我的旧时光，如那漫漫长路，永不消亡 我们俩披着雨衣，屋檐下伫立，阳光在上 你们长大了，我们也该谢幕了。 就用这篇文章，最后送你们一程吧： 祝你永不孤独。 祝你过得好。 祝你阳光快车道。 别人的经验与你的人生无关。 同理，我笔下的故事桥段，与你脚下的人生也无关。 自己去尝试，自己去选择吧，先尝试，再选择，认准方向后，作死地撑住，边撑边掌握平衡。 平行世界，多元生活，既可以朝九晚五，又能够浪迹天涯。 愿你知行合一，愿你能心安。 好吗好的。 ………… 写于：2016年11月09日13:55:34]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读《嫌疑人X的献身》所写]]></title>
      <url>%2F2017%2F01%2F04%2F%E8%AF%BB%E3%80%8A%E5%AB%8C%E7%96%91%E4%BA%BAX%E7%9A%84%E7%8C%AE%E8%BA%AB%E3%80%8B%E6%89%80%E5%86%99%2F</url>
      <content type="text"><![CDATA[东野圭吾于1999年以《秘密)》获第52届日本推理作家协会奖，2006年以《嫌疑人X的献身》获第134届直木赏和本格推理大奖，此书并一举拿下当年度三大推理小说排行榜——“‘这本推理小说了不起！’”、《本格推理小说 Best 10》和“周刊文春推理小说 Best 10”的第一名，故有三冠王之称。 东野圭吾《嫌疑人X的献身》感悟： 整个案件的起源是一对离婚夫妇之间男方纠缠不清的蛮横无理，跌宕之处在数学家出手相助于长久以来暗恋的隔壁女郎，然后情节跌宕起伏于警察和数学家的较量，最后铺垫于物理学家与数学家脑力之间的博弈…… “看起来是几何问题，其实是函数问题” 警察喜好攻心术，物理学家喜欢演绎推理，观察细致入微，洞悉人性的弱点…… 石神说，“之前你问过我一个我问题：设计别人解不开的问题和解开那个问题，何者更难——你还记得吗?” 汤川学说，“我的答案是，设计问题更难。我向来认为，解答者应该对出题者心怀敬意。” 石神问，那“P≠NP呢？自己想出答案和确认别人的答案是否正确，何者较容易？” 汤川学一脸懵逼……^_^ 石神说“你一定先自己解答，再听别人的答案” 为心爱之人掩饰一桩杀人案，不惜再犯下一桩命案——天底下真有这样痴情的人 流浪游民换上被调查对象（也就是死者，当然并非游民这个死者）也就和之前拿着肖像画询问车展人员，有关人士反映见过此人（穿着一样）但并非此人一语衔接的天衣无缝……佩服东野圭吾🙏 这个世上没有无用的齿轮，也只有齿轮自己才能决定自己的用途！只有高手间才能明白的对话…… 至此，乃智力和脑力的双重博弈🔛 汤川学的推理确实让常人难以想象，合情合理，于细微察之言，观之色！ 至此，考试（补考）期间和警察的对话起到了决定性的作用：看似几何问题，其实是函数问题。这句话石神把自己埋了（也唯有高手-物理学家-汤川学才能明白）看似不在场证明，核心其实在隐瞒死者身份。 东野的写作手法巧妙无比，人物、身份、介绍、地点等等恰如其分切入读者的心中……&amp; 两个天才的对决……脑海中，挥之不去…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git的简单使用命令备注]]></title>
      <url>%2F2017%2F01%2F04%2FGit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E6%B3%A8%2F</url>
      <content type="text"><![CDATA[Git是目前世界上最先进的分布式版本控制系统（没有之一）。 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ ……………………………………… 原文请戳廖雪峰老是的文章 Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！ 创建版本库$ mkdir learngit $ cd learngit $ pwd pwd命令用于显示当前目录。 通过git init命令把这个目录变成Git可以管理的仓库 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 原文请戳廖雪峰老师的文章 在提交代码到 git 仓库时候，需要时刻监控状态变化： 我的操作如下： 1、git status 主要检查那些文件作了修改 2、git add -A提交本地文件到本地仓库 3、git status检查提交状态 4、git commit -m &quot;说明最好见名之意&quot; 5、git pull origin master先拉一下其他人的代码 6、git push origin master提交代码到远程仓库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些图片收集]]></title>
      <url>%2F2017%2F01%2F02%2F%E4%B8%80%E4%BA%9B%E5%9B%BE%E7%89%87%E6%94%B6%E9%9B%86%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[覃彪喜收藏]]></title>
      <url>%2F2017%2F01%2F02%2F%E8%A6%83%E5%BD%AA%E5%96%9C%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[读大学，究竟读什么？大学生和非大学生最主要的区别绝对不在于是否掌握了一门专业技术⋯⋯一个经过独立思考而坚持错误观点比一个不假思索而接受正确观点的人更值得肯定⋯⋯草木可以在校园年复一年的生长，而我们注定要很快被另外一群人替代⋯⋯尽管每次网到鱼的不过是一个网眼，但要想捕到鱼，就必须要编织一张网⋯⋯ 人生规划：三岔路口的抉择不走弯路就是捷径⋯⋯仕途，商界，学术⋯⋯在这人生的三岔路口，你将何去何从⋯⋯与其跟一百个人去竞争五个职位，不如跟一个人去竞争一个职位⋯⋯学术精神天然的应当与尘嚣和喧哗保持足够的距离⋯⋯商场不忌讳任何神话。你也完全可能成为下一个传奇⋯⋯ 专业无冷热，学校无高低没有哪个用人单位会认为你代表了你的学校或者你的专业⋯⋯既然是概率，就不存在不止一种可能性⋯⋯如果是选择学术，冷门专业比热门专业更容易获得成就⋯⋯跨专业几乎早已成为一种流行一种时尚⋯⋯大学之间的实力之争到了考研考场和人才市场原来是那样的微不足道⋯⋯ 不可一业不专，不可只专一业千招会，不如一招熟⋯⋯十个百分之十并不是百分之百，而是零⋯⋯在这个现实的社会，真正实现个人价值才是最体面最有面子最有尊严的事情⋯⋯要想知道需要学习什么，最好的方式就是留意招聘信息⋯⋯很多专业因为不具备专长的有效性，所以成为了屠龙之术⋯⋯为什么不将“买一送一”的促销思维运用到求职应聘的过程中来呢⋯⋯ 不逃课的学生不是好学生什么课都不逃，跟什么课都逃掉没什么两样⋯⋯读大学，关键是学会思考问题的方法⋯⋯逃课没有错，但是不要逃错课⋯⋯英语角绝对不是学英语的地方⋯⋯为了英语丢了专业，那就舍本逐末了⋯⋯招聘单位是用人才的地方，而不是培养人才的地方⋯⋯既要逃课，又要让老师给高分⋯⋯ 勤工俭学的辩证法对于贫困生来说，首先要做的不是挣钱，而是省钱⋯⋯大部分女生将电脑当成了影碟机，大部分男生将电脑当成了游戏机⋯⋯在这个处女膜都可以随意伪造的时代，还有什么值得轻易相信⋯⋯态度决定一切⋯⋯将学习下降到次要的地位，大学生就只能说是兼职的学生了⋯⋯ 做事不如做人，人脉决定成败学问好不如做事好，做事好不如做人好⋯⋯会说话，就能减少奋斗三十年⋯⋯一个人有多少钱并不是指他拥有多少钱的所有权，而是指他拥有多少钱的使用权⋯⋯一个人赚的钱，12.5%是靠自身的知识，87.5%则来自人脉关系⋯⋯三十岁以前靠专业赚钱，三十岁以后拿人脉赚钱⋯⋯你和世界上的任何一个人之间只隔着四个人⋯⋯ 互联网：倚天剑与达摩克利斯之剑花两个小时就写出一篇天衣无缝的优秀毕业论文⋯⋯在互联网领域创业的技术门槛并不高，关键的是市场眼光和营销能力⋯⋯轻舞飞扬已经红颜薄命了，而痞子蔡却继续跟别的女孩发生着一次又一次的亲密接触⋯⋯很多大学生的网友遍布祖国大江南北，可他们却从未主动向周围的人说一声：你好，我们可以聊聊吗⋯⋯ 恋爱：花开堪折方须折爱情是不期而至的，可以期待，但不可以制造⋯⋯越是寂寞，越要警惕爱情⋯⋯既然单身是可耻的，那西门庆是不是应该被评为宋朝十大杰出青年⋯⋯花开堪折方须折，莫让鲜花败残枝⋯⋯一个有一万块钱的人为你花掉一百元，你只占了他的百分之一；而一个只有十块钱的人为你花掉十块，你就成了他的全部⋯⋯ 性：上帝死了，众神在堕落爱要说，爱要做⋯⋯我只有在肉体一下一下的撞击中才感到快乐。经过之后，将是更大的寂寞更大的空虚⋯⋯为何要让别人的虚荣成为对自己的伤害⋯⋯当她机械地躺在床上张开双腿，她的父母正在憧憬着女儿的未来⋯⋯一朝春尽红颜老，花落人亡两不知⋯⋯ 考研：痛苦的安乐死没有比浪费青春跟失败的事情了⋯⋯研究生扩招的速度是30%，也就意味着硕士学历贬值的速度是30%⋯⋯同样是付出三年的努力，你可以让E1的值增加1，也可以让E2的值增加2甚至增加3⋯⋯读完硕士或博士并不等于工作能力更强⋯⋯面对13.54万的成本，你还会毫不犹豫地投资读研究生吗⋯⋯努力就会有结果，但不一定是好结果⋯⋯ “海龟”变“海带”月薪2500元的工作，居然引得三个“海归”硕士争相竟聘⋯⋯对于某些专业而言，去美国留学和去埃塞俄比亚留学没什么两样⋯⋯既然全世界的公司都想到中国的市场上来瓜分蛋糕，为什么中国人还要一门心思到国外去留学然后给外国人打工⋯⋯ 非统招：养卑照样处优她在中国信息产业界创下了几项记录。她被称为中国的“打工皇后”。而她不过是一名自考大专生⋯⋯要想把曾经输掉的东西赢回来，就必须把自己比别人少付出的努力补上来⋯⋯非统招生不但要有一定的实力，而且必须掌握一定的技巧，做到扬长避短出奇制胜⋯⋯路在脚下，好走，走好⋯⋯ 毕业：十面埋伏的陷阱母校不把自己当母亲，你又何必把自己当儿女⋯⋯听辅导班不过是花钱买踏实⋯⋯人才市场就是一个地雷阵⋯⋯通过多种方式求职固然没有错，但是千万不要饥不择食⋯⋯只要用人单位一说要你交钱，你掉头就走便是了⋯⋯这年头立字据尚且不足以为据，更何况一个口头约定⋯⋯ 求职：做人不要太厚道求职简历必须突出自己的核心竞争力⋯⋯求职的时候大可不必像严守那样“有一说一”⋯⋯一个人说假话并不难，难得是把假话说到底，并且不漏一些破绽⋯⋯在填写自己的特长时，一定要尽可能详细⋯⋯一份求职简历只要用一张A4纸做个表格就足够了⋯⋯面试其实是有规律的，每次面试的时候只要被标准答案就行了⋯⋯ 骑一头能找千里马的驴美国铁路两条铁轨之间的标准距离是4英尺8.5英寸，为什么呢？因为两匹马臀部之间的宽度是4英尺8.5英寸⋯⋯垃圾是放错位置的人才⋯⋯世界上最大的悲剧莫过于有太多的年轻人从来没有发现自己真正想做什么⋯⋯中小企业或许能够让你得到更充分的锻炼⋯⋯从基层做起并不意味着可以从基层的每一个职位做起⋯⋯要“钱途”，更要前途⋯⋯ 写字楼政治：白领必修课大公司是做人，小公司是做事⋯⋯职员能否得到提升，很大程度不在于是否努力，而在于老板对你的赏识程度⋯⋯公司的事情和秘密永远比你想象的还要复杂和深奥⋯⋯在适当的时候装糊涂不但是必要的，而且是睿智的⋯⋯就把你的同事当成一群你可以叫得出名字的陌生人好了⋯⋯ 创业：29岁以前做富翁瘦死的骆驼比马大⋯⋯撑死胆大的，饿死胆小的⋯⋯不再是“大鱼吃小鱼”，而是“快鱼吃慢鱼”⋯⋯对于趋势的把握是一个创业者最重要的能力⋯⋯高科技行业留给毕业生的空间已经很小⋯⋯欲速则不达。在创业以前通过给别人打工而积累经验是非常必要的⋯市场永远比产品更重要⋯⋯钱不够花，怎么办？第一，看菜吃饭；第二，借鸡生蛋⋯⋯]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C概述（二）]]></title>
      <url>%2F2016%2F12%2F27%2FObjective-C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[先看一个坐标图： 浅析 objc_msgSend的作用​ 在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语说，这叫做”传递消息（亦或消息传递）”。消息有”名称”（name）或”选择子”（selector），可以接受参数，而且可能有返回值。 isMemberOfClass:用于判断对象是否为某个特定对象类的实例； isKindOfClass：用于判断对象是否为某类或者其派生类的实例。 Tips：Objective-C中，在比较两个对象是否相等时，经常使用 isEqual：方法。但是在 比较类对象是否相等时不能使用该方法，原因在于：类对象是单利（singleton），在应用程序范围内，每个类的 Class 仅有一个实例，也就是说，另外一种可以精确判断出对象是否为某类实例的办法是： 12345id object = /* …. */;if ([object class] == [SomeClass class])&#123; //&apos;object&apos; is an instance of SomeClass&#125; bitfield-位段、位域将方法响应能力缓存起来的最佳途径是使用”位段”(bitfield) 数据类型。（这是一项乏人问津的 C语言特性，在此处使用非常合适）我们可以把结构体中某个字段所占的二进制位个数设定为特定的值。比如： 1234567struct data&#123; unsigned int fieldA : 8; unsigned int fieldB : 4; unsigned int fieldC : 2; unsigned int fieldD : 1;&#125;;在结构体中，fieldA位段占用8个二进制位，fieldB位段占用4个二进制位，fieldC位段占用2个二进制位，fieldD位段占用1个二进制位。于是，fieldA可以表示0至255之间的值，而fieldD则可以表示0或1这两个值。我们可以像fieldD这样把委托对象是否实现了协议中的方法这一信息缓存起来。如果创建的结构体中只有大小为1的位段，那么就可以把许多值塞进这一小块数据里面了。 比如： 12345678910111213141516171819202122@interface SCNetworkFetcher()&#123; struct &#123; unsigned int didReceivedData : 1; unsigned int didReceivedWithError : 1; unsigned int didReceivedUpdateProgress : 1; &#125; _delegateFlags;&#125;@end //setFlags 和 setDelegate- (void)setDelegate:(id&lt;SCNetworkFetcher&gt;)delegate&#123; _delegate = delegate; _delegateFlags.didReceivedData = [delegate respondsToSelector:@selector(networkFetcher:didReceivedData:)]; /* ....... */&#125;//使用： if(_delegateFlags.didReceivedData)&#123; [_delegate networkFetcher:self didReceivedData:data];&#125;//总结：是否需要进行优化，则应按照具体的代码逻辑而定。首先需要分析代码性能，并找出瓶颈，若发现执行速度需要改进，则可使用此技巧。 不能使用retainCount的原因在于：它所返回的保留计数只是某个给定的时间点儿上的值。该方法并未考虑到系统会稍后把自动释放池清空，因而不会将后续的释放操作从返回值里减去，这样看来，此值就未必能真实的反映实际的保留计数了。这也就是为什么说这个方法无用的主要原因。 ARC在编译期和运行期的分别做了些什么？看下图： Grand Central Dispatch ——————GCD 块与大中枢派发1、块类型的语法结构如下：1return_type (^block_name) (parameters) 默认情况下，为块所捕获的外界变量，是不可以修改的，但是声明变量的时候使用__block 修饰符，是可以修改的。 如果通过读取或者写入操作捕获了实例变量，那么也会自动把 self 变量一并捕获了，因为实例变量与 self 所指代的实例关联在一起的。所以，要特别注意，在块内儿，访问实例变量，为避免循环引用，需在块外对 self 进行弱引用修饰 1__weak typeof(self) weakSelf = self; 块的内部结构 iOS - NSLinguisticTagger（自然语言） 自然语言筛选代码及注释: 1234567891011121314151617//1.创建语句 NSString * question = @&quot;What is the weather in San Francisco?&quot;; //2.创建筛选条件 NSLinguisticTaggerOptions options = NSLinguisticTaggerOmitWhitespace | NSLinguisticTaggerJoinNames |NSLinguisticTaggerOmitPunctuation; //3.创建自然语言标签 NSLinguisticTagger * tagger = [[NSLinguisticTagger alloc]initWithTagSchemes:[NSLinguisticTagger availableTagSchemesForLanguage:@&quot;en&quot;] options:options]; //4.给标签附字符串 tagger.string = question; //5.执行筛选 [tagger enumerateTagsInRange:NSMakeRange(0, question.length) scheme:NSLinguisticTagSchemeNameTypeOrLexicalClass options:options usingBlock:^(NSString * _Nonnull tag, NSRange tokenRange, NSRange sentenceRange, BOOL * _Nonnull stop) &#123; //6.获取结果 NSString*token = [question substringWithRange:tokenRange]; //7.打印结果 NSLog(@&quot;%@:%@&quot;,token,tag); &#125;]; 打印结果 12345672017-02-17 15:17:06.478 Demo[54116:2511652] What:Pronoun2017-02-17 15:17:06.478 Demo[54116:2511652] is:Verb2017-02-17 15:17:06.479 Demo[54116:2511652] the:Determiner2017-02-17 15:17:06.480 Demo[54116:2511652] weather:Noun2017-02-17 15:17:06.480 Demo[54116:2511652] in:Preposition2017-02-17 15:17:06.482 Demo[54116:2511652] San Francisco:PlaceName(lldb) OC 经历了多年的发展和进化，遍历collection 的方式也经历了一系列的演变，如下： 1、For 循环遍历 2、使用 Objective-C 1.0 的 NSEnumerator 来遍历 3、快速遍历（For-in） 4、基于”块”的遍历方式 （PS：若能提前得知遍历的 collection 是何种对象，则应该修改块签名，指出对象的具体类型） ​ 总体来看， 块枚举法拥有上述遍历方式的所有优势，而且还有更多好处。与快速遍历方法相比，它要多用一些代码，可是却能提供遍历时所针对的下标，在遍历字典时也能同时提供键与值，而且还有选修可以开启并发迭代功能，所以多写点儿代码还是值得的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown开启编辑新模式]]></title>
      <url>%2F2016%2F12%2F24%2FMarkdown%E5%BC%80%E5%90%AF%E7%BC%96%E8%BE%91%E6%96%B0%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[iPic + Typora，方便快捷地在 Markdown 中插图 typora 图床神器 iPic]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac 下终端常用命令汇总]]></title>
      <url>%2F2016%2F12%2F19%2FMac-%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[（1）Git：默认OS X是安装git的，我们可以通过git命令查看（2）which git：查看git的安装路径。默认一般是/usr/bin/git.（3）curl http://npmjs.org/install.sh | sh ：安装Node.js的套件管理工具；（4）sudo npm update npm -g ：更新node.js的套件管理工具nmp；（5）nmp -v :查看nmp的版本；（6）cd ~/.ssh :检查本机的SSH密钥；（7）cd :进入某个文件目录；（8）ls -a :显示当前文件夹下的所有隐藏文件；（9）open :打开当前目录下的某个文件；（10）ssh -T git@github.com :检查Github的SSH是否设置成功；（11）git config –global user.name 用户名 ：修改git的用户名。因为Git会根据用户的名字和邮箱来记录提交。Github也是用这些信息来做权限的处理。（12）git config –global user.email 邮箱 ：修改git的邮箱。因为Git会根据用户的名字和邮箱来记录提交。Github也是用这些信息来做权限的处理。（13）open -t ~/.bash_profile ：打开Mac下环境变量配置；（14）ruby -e “$(curl -fsSkL https://raw.github.com/Homebrew/homebrew/Go/install)” ：安装os x下的包管理工具homebrew；（15）brew doctor :检查homebrew是否已经安装成功；（16）echo $PATH : 查看系统PATH环境变量；（17）ls ：列出当前目录下的所有文件名；（18）node -v :查看node.js的版本号；（19）nmp -v :查看nmp的版本号；（20）which node ：查看node.js的安装路径；（21）which nmp :查看nmp的安装路径；（22）git –version: 查看git的版本；（23）sudo npm install –unsafe-perm –verbose -g hexo ：用npm命令安装hexo；（24）sudo npm install -g hexo ：用npm命令安装hexo；可以与上面的比较着用；（25）tab键 :自动补全当前目录下的文件名；（26）pwd :显示当前目录；（27）cd ：进入root根目录；（28）cd .. :进入上级目录；（29）cat 文件名 ：在终端下查看文件；（30）vim 文件名：使用vim编辑某个文件；（31）进入vim先按字母i键：对vim执行插入操作，即可以编辑文件了；（32）:q :在vim中没有对文件做任何修改的情况下退出vim可以使用该命令；（33）先按ESC键，然后 :w :保存当前写入的内容，但不退出vim；（34）先按ESC键，然后 :wq :保存修改的内容，退出vim；w：write ； q: quit（35）hexo g :生成hexo静态网页，在你本地做修改后，首先要使用这个命令， g ＝ generate;（36）hexo d :部署静态网页，在执行hexo g之后执行hexo d, d = depoly;（37）git clone https://github.com/wuchong/jacman.git themes/jacman ：从Github下载Hexo的jacman主题，存放在themes目录下，注意执行git命令和执行hexo命令必须要在Hexo文件夹下，也就是要在根目录下；（38）git clone https://github.com/A-limon/pacman.git themes/pacman ：同上；（39）hexo serve ：在本地进行开启服务器进行hexo的调试；只要在浏览器中输入http://0.0.0.0:4000/即可进行调试；（40）Ctrl ＋ C：在上一个命令之后执行，停止hexo服务器的调试；（41）hexo clean :清除缓存，网页正常情况下可以忽视该命令；（42）hexo n “博客名称”= hexo new “博客名称” ：新建文章；（43）hexo g = hexo generate :生成；（44）hexo s = hexo serve :启动服务预览；（45）hexo d = hexo deploy :部署；（46）hexo generate –deploy :作用同 分别执行 hexo generate ; hexo deploy（47）hexo deploy –generate :同上hexo generate –deploy（48）:q! :强制退出vim，并放弃所有修改；（49）:e! :vim 中放弃所有修改，并打开原来的文件；（50）JDK环境变量配置： cd :进入根目录 vim .bash_profile :使用vim编辑环境变量export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_67.jdk/Contents/Home #版本号根据自己的具体情况而定export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar按ESC键进入命令模式:wq :保存退出source .bash_profile ：更新配置文件 （51）cd /Library/Java/JavaVirtualMachines ls :可以查看当前你安装的所有JDK的版本，因为JDK默认是安装在/Library/Java/JavaVirtualMachines 路径下的； （52）xcode-select –install :终端下安装Xcode Command line tools；（53）rm 文件名 ：删除某个文件；（54）git clone *github repository url :从服务器上将代码给拉下来，注意：你要把本地库放到哪里，就要在某个文件夹下进行这个操作；（55）git diff :差异比较；（56）git show :显示某次提交的信息；（57）git init ：初始化一个版本仓库，如果想把本地的某个文件夹作为本地仓库，就在该文件夹执行这个操作。作为git clone之前的第一个操作；（58）git remote -v :查看远程仓库，在你当前文件夹下执行该命令，就会显示你的远程仓库的url；（59）Ctrl + C :强制退出某个在终端中运行的进程或者服务；（60）curl -L https://get.rvm.io | bash -s stable :安装rvm，可以理解为Ruby的虚拟机，可以和JVM一起理解；（61）rvm -v :检查rvm是否成功安装以及版本；（62）rvm install 2.0.0 :使用rvm安装Ruby环境；这样Ruby ，Ruby Gems就安装完成了；（63）ruby -v :查看Ruby版本；（64）gem -v :查看gem版本；（65）gem sources -l :查看gem来源；（66）gem sources –remove https://rubygems.org///等有反应之后再敲入以下命令gem sources -a http://ruby.taobao.org/使用Ruby环境来安装cocoapods，由于上述网站被墙，所以需要修改镜像为淘宝的镜像； （67）sudo gem install cocoapods安装cocoapods.这是开发苹果应用的一个非常方便的包管理工具；（68）which -a gitMac下查看安装了 几个版本的git； （69）ls -a查看该文件目录下的所有文件，包括隐藏文件。 （70）推荐使用zsh+iTerm 2替换Mac自带的终端Terminal和bash。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac安装Homebrew]]></title>
      <url>%2F2016%2F12%2F19%2FMac%E5%AE%89%E8%A3%85Homebrew%2F</url>
      <content type="text"><![CDATA[Homebrew安装在 terminal 中复制以下命令，跟随指引，将完成 Hombrew 安装。 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 紧接着，我们需要做一件事让通过 Hombrew 安装的程序的启动链接 (在 /usr/local/bin中）可以直接运行，无需将完整路径写出。通过以下命令将 /usr/local/bin 添加至 $PATH 环境变量中: 1echo &apos;export PATH=&quot;/usr/local/bin:$PATH&quot;&apos; &gt;&gt; ~/.bash_profile Cmd+T 打开一个新的 terminal 标签页，运行以下命令，确保 brew 运行正常。1brew doctor 命令操作安装一个包,比如widget，可以简单的运行：1brew install widget 更新 Homebrew 在服务器端上的包目录：1brew update 查看你的包是否需要更新：1brew outdated 更新包：1brew upgrade &lt;&quot;包名&quot;&gt; Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：1brew cleanup 查看你安装过的包列表（包括版本号）：1brew list --versions Homebrew CaskHomebrew Cask可以优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox。 安装运行以下命令即可完成：12brew tap caskroom/cask // 添加 Github 上的 caskroom/cask 库brew install brew-cask // 安装 brew-cask 搜索1brew cask search 下载文件预览插件有些 插件 可以让 Mac 上的文件预览更有效，比如语法高亮、markdown 渲染、json 预览等等。比如以下：12345678brew cask install qlcolorcodebrew cask install qlstephenbrew cask install qlmarkdownbrew cask install quicklook-jsonbrew cask install qlprettypatchbrew cask install quicklook-csvbrew cask install betterzipqlbrew cask install webp-quicklook 一些推荐安装的程序1234567brew cask install alfredbrew cask install appcleanerbrew cask install cheatsheetbrew cask install dropboxbrew cask install google-chromebrew cask install sublime-textbrew cask install cheatsheet Homebrew 还能做什么123456789brew cask uninstall 软件名 卸载通过 Homebrew Cask 安装的软件brew cask search 列出所有可以被安装的软件，当然你也可以直接前往上文提供的 Homebrew Cask 搜索。brew cask search google 这里是查找所有与 google 有关的软件，google 关键词可以自行替换brew cask info 软件名 查找相关软件的信息brew cask cleanup 删除 Homebrew Cask 下载的包brew cask list 列出通过 Homebrew Cask 安装的包brew cask update 更新 Homebrew CaskPS:Calling `brew cask update` is deprecated and will be disabled on 2017-07-01!Use `brew update` instead. Homebrew Cask传送门 至此，Homebrew Cask 的简单使用方法就介绍完了。😜 获取最高权限： 1sudo chown -R 'whoami' /usr/local]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC中CGGeometry几何类常用方法整理]]></title>
      <url>%2F2016%2F12%2F15%2FOC%E4%B8%ADCGGeometry%E5%87%A0%E4%BD%95%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[CGGeometry参考定义几何结构和功能,操作简单。数据结构中的一个点CGPoint代表在一个二维坐标系统。数据结构的位置和尺寸CGRect代表的一个长方形。数据结构的尺寸CGSize代表宽度和高度。 创建一个几何原始数值123CGPoint CGPointMake（CGPoint A,CGPoint B）//返回一个指定坐标点 CGRect CGRectMake（CGFloat x,CGFloat y,CGFloat width,CGFloat height）//根据指定的坐标和大小创建一个矩形CGSize CGSizeMake（CGFloat width,CGFloat height）//根据指定长宽创建一个CGSize 修改矩形1234567CGRectDivideCGRect CGRectInset（CGRect rect,CGFloat dx,CGFloat dy）//返回一个比原矩形大或小的矩形，但是中心点是相同的CGRect CGRectIntegral（CGRect A）//将矩形A的值转变成整数，得到一个最小的矩形，CGRect CGRectIntersection:（CGRect A，CGRect B）//获取两个矩形相交处所的矩形，没有相交返回NULL，用CGRectIsNull来检测CGRectOffsetCGRectStandardizeCGRectUnion 比较数值1234bool CGPointEqualToPoint(CGPoint A,CGPoint B) //返回两个点是否相等bool CGSizeEqualToSize(CGSize A，CGSize B) //CGSizeAB是否相等bool CGRectEqualToRect(CGRect A，CGRect B) //矩形AB的位置大小是否相等bool CGRectIntersectsRect(CGRect A，CGRect B) //矩形AB是否相交，可用来判断精灵是否离开了屏幕 检查12bool CGRectContainsPoint（CGRect A, CGPoint B）//检测矩形A是否包含指定的点Bbool CGRectContainsRect（CGRect A，CGRect B）//检测矩形A是否包含矩形B 获取最大值、中等职和最小值123456CGFloat CGRectGetMinX（CGRect A） //获取矩形x坐标的最小值CGFloat CGRectGetMinY（CGRect A) //获取矩形y坐标的最小值 CGFloat CGRectGetMidX（CGRect A） //获取矩形x坐标的中间值 CGFloat CGRectGetMidY（CGRect A） //获取矩形y坐标的中间值 CGFloat CGRectGetMaxX（CGRect A） //获取矩形x坐标的最大值 CGFloat CGRectGetMaxY（CGRect A） //获取矩形y坐标的最大值 获取高和宽12CGFloat CGRectGetHeight（CGRect A）//获取矩形A的高CGFloat CGRectGetWidth（CGRect A） //获取矩形A的宽 检测矩形是否存在或是无穷大123bool CGRectIsEmpty(CGRect A) //矩形A是否长和宽都是0，或者是个NULLbool CGRectIsNull(CGRect A) //矩形A是否为NULLbool CGRectIsInfinite(CGRect A) //矩形A是否无穷大，没有边界]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[插件篇]]></title>
      <url>%2F2016%2F12%2F09%2F%E6%8F%92%E4%BB%B6%E7%AF%87%2F</url>
      <content type="text"><![CDATA[FVD Downloader for Chrome 插件下载视频的插件，点它下载心仪的视频和音乐 百度网盘文件下载助手 for Chrome浏览器Aria2GUI：绕过百度网盘满速下载 Adblock Plus 畅游清爽洁净的网际防止追踪、恶意域名，过滤横幅广告、弹窗广告以及视频广告。用以支持网站的非侵入式广告将不会被屏蔽（可配置）完全免费！ Pocket 稍后阅读发现想在以后查看的内容时，先将其放入 Pocket。 safari-json-formatterA Safari extension which makes valid JSON documents human-readable.Download the extension and open it with Safari 5. Adblock Super谷歌浏览器中流行的广告屏蔽插件Adblock Super这款Chrome广告屏蔽插件可以有着比Adblock更加强大的屏蔽功能，它可以屏蔽几乎所有的社交网站和普通网站上的各种广告，用户只需要在Chrome浏览器中安装并简单地配置Adblock Super的屏蔽功能即可。【只是总是自动被 Chrome 屏蔽】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[西原，西原]]></title>
      <url>%2F2016%2F12%2F06%2F%E8%A5%BF%E5%8E%9F%EF%BC%8C%E8%A5%BF%E5%8E%9F%2F</url>
      <content type="text"><![CDATA[她是朵含苞带露的格桑花，一遇见他就绽开了，一生只为他陈渠珍一个人开。 羌塘路茫茫，无给养无得力的向导，一路上极尽苦寒，断粮长达七个月。部众接二连三饥寒暴毙，几乎每天都有人永远地仰倒在雪原上，赤面朝天，连一席裹尸的草席都没有。荒原之上，好像没什么比找死更容易的事情了。 她不是他的袍泽弟兄，不是他的属下，她只知道她是他的女人。她并不觉得自己是在付出或奉献，只把这些，当成自己应尽的本分。彼时的西原，不过是不到二十岁的一个小嫁娘。 日复一日，她对他的爱几乎浓缩成一种信仰，一种可以舍生忘死放弃一切的信仰。她是他的爱人、母亲和护法绿度母，他要走羌塘，她万里相随，她本藏女，不会不知前路意味着怎样的生死……就算有万分之一的机会安抵汉地，今生她也几乎无缘再度重返西藏。她需要为他放弃父母、语言以及故乡。她没有什么犹豫，甚至没有询问他什么，只是绷紧了弦，死地羌塘舍命相保。她只知道她是他的女人。 她自己少吃或者不吃，省下口粮给他吃，还假装自己已经吃过。她逼他吃最后一块干肉的时候说：“……可以没有我，不可以没有你。” 她用人性中最朴素纯洁的一切深爱着他，爱得就像始祖的先民一样笨拙，她以一个女人所有的一切爱着她唯一的男人……没有人比她更配得起“爱人”这个词汇。 情之所至，缘订三生，相依为命到绝境时，他们俩订下三世盟约：六道轮回中，愿永为夫妻。 情之所至，或许感动了雪域护法，艽野中的神袛网开一面，没有收走他们的命。西原悬起一口真气，终于护送陈渠珍安抵汉地。 整整七个月，梦魇一样的艽野，终于走出来了。从出发时的百二十人，死到最后只剩六七个人。彼时已是1912年的初夏。 西原一到了汉地就没了。用尽最后一丝心力的西原灯油耗干，逝去在西安城。 临终前，她遗言道：“西原万里从君，一直形影相随，不想竟然病入膏肓，不得不与君中道而别……愿君南归途中，一路珍重，西原已不能随行了。” 一切都随风逝去了，荣耀和前途，信念和希望，以及爱人。陈渠珍立在西风里，茕茕孑立。这哪里仅仅是落魄，分明是一颗心被生生剜走。人生的大悲凉，莫如斯。…… 西原，西原，你是否会涅槃在时代更迭的夹缝中，反反复复不停涅槃。时时常示人，世人常不识。 原文请戳————大冰的《西原,西原》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[菩提本无树]]></title>
      <url>%2F2016%2F12%2F05%2F%E8%8F%A9%E6%8F%90%E6%9C%AC%E6%97%A0%E6%A0%91%2F</url>
      <content type="text"><![CDATA[菩提本无树，明镜亦非台。本来无一物，何处惹尘埃。 这个是六祖慧能大师的一个四句偈 佛对我说：你的心上有尘。我用力地擦拭。佛说：你错了，尘是擦不掉的。我于是将心剥了下来.佛又说：你又错了，尘本非尘，何来有尘我领悟不透，是什么意思？我想这是从神秀和慧能那两个偈子引申出来。 神秀说：“身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。”慧能说：“菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。” 的确，要能够参透这两个偈子的确很难，就是正确的理解也不易。参悟不透…身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃众生的身体就是一棵觉悟的智慧树，众生的心灵就象一座明亮的台镜。要时时不断地将它掸拂擦试，不让它被尘垢污染障蔽了光明的本性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[河南啊河南]]></title>
      <url>%2F2016%2F12%2F05%2F%E6%B2%B3%E5%8D%97%E5%95%8A%E6%B2%B3%E5%8D%97%2F</url>
      <content type="text"><![CDATA[中国科技大学为什么没有落户河南？ 今天看到以下文章，不知道是否说的全面。 1969年，有意迁往河南的中国科技大学遭遇河南当局的冷淡，时为安徽省革委会主任的李德生（河南省信阳市新县人，曾任党中央副主席和军委副主席）却主动要去了这所名校。历史很有讽刺性，李德生的故乡就是河南。从此后，中科大成为安徽的骄傲和机会，河南则因此而后悔、痛楚，经年不绝。 一 1969年，中苏边境冲突。根据形势，中央决定进行“战备疏散”，中国科技大学被国务院科教组列入北京十三所下迁高校之中。据时为中科大革委会常委之一的蔡有智教授回忆，“九月下旬，分两组去湖北沙市和河南寻找疏散地址。沙市有科学院的干校，河南组带有国务院科教组组长刘西尧给河南省的亲笔信。预计去这两地选址会容易些，我是去河南组的成员，因为带有刘西尧同志的亲笔信，我们受到了省生产指挥组组长的接待，他让我们去南阳地区看看，在谈话中我们意识到他们对科大来河南不大积极。我们在南阳周边和邓县看了不少地方，地区的同志说：土地有的是，三千亩五千亩没问题，但我们南阳没有接收一所大学的能力。 两组选址人员回到北京，都表示这两地没有条件，不能去。接着又派两组，一组去江西，一组去安徽。我是去江西组的成员，到江西省后，省里明确表示不能接收科大。安徽选址的同志在宣城地区看了以后也觉得不行。在这两组人员还没回到北京时就接到了定点安徽省安庆市的通知。”其间，是安徽的领导人李德生迅速行动，把中科大争取到了安庆。由于安庆条件太差，中科大不愿去，李德生又腾出合肥师范学院和银行干校的校舍，来安置中科大。 另据中国科技大学校史记载，学校南迁原定在河南南阳，后改为安徽安庆。从刘西尧专函河南也可以看出，中国科技大学是想建在河南的。河南之所以拒绝中科大最权威的说法是怕大学师生挤占河南的副食口粮。 当南阳籍的建筑大师杨廷宝在主持规划中科大合肥校园时，我想，他一定别有一番滋味在心头。 后来，中科大多次想迁回北京，毕竟它要依托中科院办学，但安徽省一直极力挽留，就没有走成。安徽省还争取到了下放的中科院研究所，一跃而为科教名城。安徽现有国家同步辐射实验室、微尺度物质科学国家实验室两个国家大科学工程。而河南连更低级别的国家重点实验室都没有。 无独有偶，中国地质大学曾要落户河南平顶山，也被河南错失。 二 河南错失中国科技大学的后悔只在表层、显意识里。河南的小农思维是在骨子里，不自觉的，不那么容易改掉。 在错失中科大十年后的改革开放之初，举国凋敝，各省高教实力差距不大。但随后的河南既没有争到国家投入，也没有自己大力建设，被兄弟省份远远甩下。小省山西现有八个学校可以培养博士，黑龙江有十一个，而大省河南只有五个。我们真的重视教育了吗？ 当中科大在大力扩张建设新校区时，河南大学的2000亩老校园则被挤兑的只剩下八百亩，而人数却涨了好几倍。我们在精神上有境界吗？ 2000年，河南提出加快发展河南大学，坚决破除小农意识，却只给三校合并的新河大拨地1800亩建设新校区。以至于教育部长陈至立都说，这能容纳下几万人吗？以至于现在要跨过大马路再建新新校区。而同期的山东临沂师范学院新校区征地一万亩，人家要为一千万临沂儿女圆大学梦。我们在视野上有眼光吗？ 湖南师范大学整合医专、省人民医院、解放军医院，建设医科。南华大学整合中央科研院所，山东科技大学跨市合并，迅速做大。陕西科技大学、西南石油学院将新校区建在省会，异地办学，摆脱地理局限。这才是解放思想、不拘一格。反观自身，我们在思维上有创新吗？ 节选评论还有一所中国矿业大学也是河南不要啊， 三所“中字头”的大学在任何一个省都是稀缺资源， 河南省就轻易地拒绝了。 现在所谓的高教大省湖北，也只有一所中字头大学， 就是当年河南不要的中国地质大学。 更让人感到绝情的是， 中国矿业大学的前身就是1909年成立的焦作路矿学堂，想搬回家的游子河南也不要。 有道是：前人种树后人乘凉。 在河南，却是前人砍树后人骂娘。 文章转自&amp;天涯社区合肥晚报市场星报知乎爆料搜狐新闻更多文摘请点击]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[系统原生请求表单上传]]></title>
      <url>%2F2016%2F12%2F02%2F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E8%AF%B7%E6%B1%82%E8%A1%A8%E5%8D%95%E4%B8%8A%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[创建NSMutableURLRequest请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768- (void)setRequest:(NSMutableURLRequest *)request&#123; NSString *boundary = [NSString stringWithFormat:@&quot;Boundary+%08X%08X&quot;, arc4random(), arc4random()]; NSMutableData *body = [NSMutableData data]; // 表单数据 NSMutableDictionary *param = [[NSMutableDictionary alloc] init];// [param setValue:@&quot;254&quot; forKey:@&quot;empId&quot;];// [param setValue:@&quot;18718&quot; forKey:@&quot;shopId&quot;]; /** 遍历字典将字典中的键值对转换成请求格式: --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;empId&quot; 254 --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;shopId&quot; 18718 */ [param enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSMutableString *fieldStr = [NSMutableString string]; [fieldStr appendString:[NSString stringWithFormat:@&quot;--%@\r\n&quot;, boundary]]; [fieldStr appendString:[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;\r\n\r\n&quot;, key]]; [fieldStr appendString:[NSString stringWithFormat:@&quot;%@&quot;, obj]]; [body appendData:[fieldStr dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:[@&quot;\r\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; &#125;]; /// 图片数据部分 NSMutableString *topStr = [NSMutableString string]; NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;001.jpeg&quot; ofType:nil]; NSData *data = [NSData dataWithContentsOfFile:path]; /**拼装成格式： --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;uploadFile&quot;; filename=&quot;001.png&quot; Content-Type:image/png Content-Transfer-Encoding: binary ... contents of boris.png ... */ [topStr appendString:[NSString stringWithFormat:@&quot;--%@\r\n&quot;, boundary]]; [topStr appendString:@&quot;Content-Disposition: form-data; name=\&quot;file\&quot;; filename=\&quot;001.png\&quot;\r\n&quot;];//⚠️注意：此处的『name=\&quot;file\&quot;』这个 file 就是你后端服务器定义的文件流的字段，特此提醒 [topStr appendString:@&quot;Content-Type:image/jpg\r\n&quot;]; [topStr appendString:@&quot;Content-Transfer-Encoding: binary\r\n\r\n&quot;]; [body appendData:[topStr dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:data]; [body appendData:[@&quot;\r\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; // 结束部分 NSString *bottomStr = [NSString stringWithFormat:@&quot;--%@--&quot;, boundary]; /**拼装成格式： --Boundary+72D4CD655314C423-- */ [body appendData:[bottomStr dataUsingEncoding:NSUTF8StringEncoding]]; // 设置请求类型为post请求 request.HTTPMethod = @&quot;post&quot;; // 设置request的请求体 request.HTTPBody = body; // 设置头部数据，标明上传数据总大小，用于服务器接收校验 [request setValue:[NSString stringWithFormat:@&quot;%lu&quot;, (unsigned long)body.length] forHTTPHeaderField:@&quot;Content-Length&quot;]; // 设置头部数据，指定了http post请求的编码方式为multipart/form-data（上传文件必须用这个）。 [request setValue:[NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,boundary] forHTTPHeaderField:@&quot;Content-Type&quot;];&#125; 上传文件流12345678910111213141516- (void)upload&#123; //uploadModule - 1 im 2 app 3 other //TODO:需要修改 NSString *urlStr = [NSString stringWithFormat:@&quot;http://qp.lianxi.com/file/upload?apiCode=%@&amp;uploadType=1&amp;uploadModule=2&amp;originalFlag=1&quot;,_share_apiCode]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlStr] cachePolicy:0 timeoutInterval:30.0f]; [self setRequest:request]; NSLog(@&quot;开始上传...&quot;); [NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc] init] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; //这里就是服务器返回的图片地址 NSLog(@&quot;Result--%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); &#125;];&#125; 参考文章原文地址 我的我的简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C概述]]></title>
      <url>%2F2016%2F11%2F30%2FObjective-C%E6%A6%82%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[Objective-C的起源 Objective-C与C++、Java、C#等面向对象的语言类似，不过很多方面有所差别。若是使用过一种面向对的开发语言，那么就能理解Objective-C所用的『范式和模板』了。然而，语法上会略显陌生，因为Objective-C使用的”消息结构”而非”函数调用”。Objective-C是由Smalltalk演化而来，后者是消息型语言的鼻祖。他们之间的调用看起来就是这样： 1234567//Messaging （Objective-C）Object *obj = [Object new];[obj performWith:parameter1 and:parameter2];//Function calling (C++)Object *obj = [Object new];obj-&gt;perform(parameter1,parameter2); 关键的区别在于：使用消息结构的语言，其运行时所执行的代码是由运行时环境决定的；而使用函数调用的语言，则由编译器决定。如果上例代码中调用的函数是多态的，那么在运行时就要按照&quot;虚方法表&quot;(virture method table)来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。 Notes：virture method table是编程语言为实现&quot;动态派发&quot;（dynamic dispatch）或 &quot;运行时方法绑定&quot;（runtime method binding） 而采用的一种机制。 “对象”(object)的内存在堆(heap space)上;“指针”(pointer)的内存在栈（stack）上。 在类的头文件中尽量少引入其他头文件可以使用@class 关键字&quot;向前声明&quot;（forward declaring） 该类。引入过多的并不需要的头文件，会增加编译时间，还会导致循环引用。使用『向前声明』可以解决互相引用的问题，减少编译时间，而且还能降低彼此的依赖程度（即我们经常说的降低耦合性） 多用字面量语法（literal syntax），少用与之等价的方法字面数值1234&lt;!-- 字面数值 --&gt;NSNumber *someNumber = [NSNumber numberWithInt:1];等价于NSNumber *someNumber = @1; 字面量语法更加精简。能够以 NSNumber 实例表示的所有数据类型都可以使用这种表示方式。 字面数组123456789&lt;!-- 字面量数组 --&gt; NSArray *array = [NSArray arrayWithObjects:@&quot;Hello&quot;,@&quot;World&quot;,nil]; 等价于 NSArray *array = [@&quot;Hello&quot;,@&quot;World&quot;]; 对应的使用方法：(取下标操作subscripting) NSString *animal = [array objectAtIndex:0]; 等价于 NSString *animal = array[0]; 字面字典“字典”是一种映射型数据结构，可向其中添加键值对。123456789&lt;!-- 字面量字典 --&gt; NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Hello&quot;:@&quot;H&quot;,@&quot;World&quot;:@&quot;W&quot;,[NSNumber numberWithInt:28]:@&quot;A&quot;,nil]; 等价于 NSDictionary *dictionary = @&#123;@&quot;H&quot;:@&quot;Hello&quot;,@&quot;W&quot;:@&quot;World&quot;,@&quot;A&quot;:@28&#125;; 对应的使用方法： NSString *animal = [dictionary valueForKey:@&quot;H&quot;]; 等价于 NSString *animal = dictionary[@&quot;H&quot;]; 使用字面量语法的局限性： 1、除了字符串以外，创建出来的对象必须是 Foundation 框架下的才行。 2、定义了这些可行的子类话，则无法继续使用字面量语法创建对象。 3、使用字面量创建出来的字符串、数组、字典对象都是不可变的（immutable），若要可变，需要调用 mutableCopy。比如：NSMutableDictionary *mutable = [@{@&quot;H&quot;:@&quot;Hello&quot;,@&quot;W&quot;:@&quot;World&quot;,@&quot;A&quot;:@28} mutableCopy] 使用字面量语法的好处： 1、可以缩减代码的长度 使其更加易读 2、使用字面量语法更加安全 3、字面量语法实际上只是一种[&quot;语法糖&quot;syntactic sugar](http://zh.wikipedia.org/wiki/语法糖) 4、使用字面量语法创建数组或字典时，值中不能有 nil 对象，否则抛出异常。其实这样，更便于查错。纠错。 多用类型常量，少用『#define』 预处理指令12345678#define ANIMATION_DURATION 0.3 //没有类型信息与static const NSTimeInterval KAnimationDuration = 0.3; //包含类型信息//变量名已定要同时使用 const 和 static 来声明。//其实这些都是一些命名规范，后边细述。 有时候需要公开某个常量。比如，你可能会给代码块中某个 Event 发送通知（NSNotification）。派发通知时需要使用字符串来表示此项通知的名称，而这个名字就可以为一个外界可见的常值变量（constant variable）。这样的话，注册者无需知道实际字符串的值，只需要以常值变量来注册自己想要接收到的通知即可。此类常量需放在&quot;全局符号表&quot;（global symbol table）中，以便可以再定义该常量的编译单元之外使用。和上边的 static const 有所不同： 1234567//In the header fileextern NSString *const SCStringRefreshNotification; //常量指针//In the implementation fileNSString *const SCStringRefreshNotification = @&quot;SCStringRefreshNotification&quot;;//点 h 文件声明，点 m 文件定义 总之，不要使用预处理指令定义常量。这样定义出来的常量不仅不包含类型信息，而且有人修改了（或重新定义了）这个常量值编译器也不会产生警告⚠️信息。​在实现文件使用 static const 来定义”只在编译单元内可见的变量”(translation-unit-specific constant)。这类常量不会出现在全局符号表中，所以无需为其名称加前缀。 在头文件使用 extern 来声明全局常量，并在实现文件中定义其值。这类常量会出现在全局符号表中，所以通常用与之相关的类名做前缀。 用枚举表示状态、选项、状态吗一个字节含8个二进制位，所以至多能表示可取256种（2^8个）枚举（编号为0~255）的枚举变量。 我们总习惯在 switch 语句中加上 default 分支。然而，若是用枚举来定义状态机（state machine），最好不要有 default 分支。这样的话，如果稍后新加上一个枚举状态，那么编译器会发出警告信息，提示新加入的状态并未在 switch 分支中处理。假如写上了 default 分支，那么他就会处理这个新状态，从而导致编译器不发警告信息。用 NS_ENUM 定义其他枚举类型时候也要注意此问题。 1、应该使用枚举来表示状态机的状态，传递给方法的选项以及状态码等值，给这些起个易懂的名字。2、如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。3、用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样的做就可以确保枚举是开发者所选择的底层数据类型实现出来，而不是采用编译器所选用的类型。4、在处理枚举类型的 switch 语句中不要实现 default 分支。 对象、消息、运行期 用 Objective-C 等面向对象语言编程时，对象（object）就是”基本构造单元”(building block),开发者可以通过对象存储并传递数据。 在对象之间传递数据并执行任务的过程就叫做”消息传递”(Messaging)。 Notes： 如果你熟悉了『对象』和『消息传递』这两个特性的工作原理，就可以写出高效且易维护的代码。 当 App 运行起来后，为其提供相关支持的代码叫做”Objective-C运行期环境”（Objective-C runtime）.runtime提供了一些是的对象之间能够传递消息的重要函数。 熟悉几个术语：存取方法（access method）、点语法（dot syntax）、编译器（compile time）、偏移量（offset）、硬编码（hardcode）、不兼容对象（incompatibility）、特殊变量（special variable）、类对象（class object）、应用程序二进制接口（Application Binary Interface，ABI）、稳固的（nonfragile） 在对象接口的定义中，可以使用属性，这是一种标准的写法，能够访问封装在对象的数据。因此，也可以把属性当做一种简称，其意思就是说：编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 使用点语法和直接调用存取方法之间没有丝毫差别。 123456789SCPerson *person= [SCPerson new];person.firstName = @&quot;CYH&quot;;Same As:[person setFirstName:@&quot;CYH&quot;];NSString *name = person.firstName;Same As:NSString *name = [person firstName]; 属性拥有的特质分为四类： 原子性： 在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性（atomicity）。如果属性具备 nonatomic特质，则不使用同步锁。请注意，如果某属性不具备 nonatomic特质那它就是原子的 atomic。 读/写权限： 1、具备 readwrite 特质的属性拥有 getter 和 setter 方法。 2、具备 readonly 特质属性只有 getter 方法。 内存管理语义： 属性用于封装数据，而数据必须要有”具体的所有权语义”（concrete ownership semantic）。 assign: setter 方法只会执行针对”纯量类型”（scalar type,e.g:CGFloat和 NSInteger）的简单赋值操作 strong: 定义了一种拥有关系（ownership relationship）。为这种属性设置新值时，setter 方法会先保留新值，并释放旧值，然后再将新值设置上去。 weak: 定义了一种非拥有关系（nonowning relationship）。为这种属性设置新值时，setter 方法既不保留新值，也不释放旧值。此特质同 assign 类似，然而在属性特指的对象遭到摧毁时，属性值会清空（nil out） unsafe_unretained: 此特质的语义和 assign 相同，但是它适用于对象类型（object type），该特质表达一种非拥有关系（不保留，unretained），当目标对象遭到摧毁时，属性值不会清空（不安全，unsafe），这一点与 weak 有区别。 copy: 此特质所述的关系和 strong 类似，然而设置方法并不保留新值，而是将其复制 （copy）。当熟悉类型是 NSString* 时候，经常用此特质来保护其封装性。因为传递给 setter 方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可以修改其值的字符串，此时若不拷贝字符串，那么设置完属性之后，字符串的值可能会在对象不知情的情况下遭人更改。所以，就要拷贝一份不可变的字符串，确保对象中的字符串不会无意简变动。只要实现属性所用的对象是可变的，就应该在设置新属性值时拷贝一份。 方法名：可以通过 getter= 和 setter= 指定存取方法的方法名 注释：不应该在 init （或 dealloc） 方法中调用存取方法。 在对象内部尽量直接访问实例变量1、在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写2、在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据3、有时会使用惰性初始化技术配置某分数据，这种情况下，需要通过属性来读取数据。 理解”对象等同性”这一概念 根据”等同性”(equality)来比较对象是一个非常有用的功能。不过，按照==操作符比较出来的结果未必是我们想要的，因为该操作比较的是两个指针本身，而不是其所指的对象。应该使用NSObject协议中声明的”isEqual:”方法来判断两个对象的等同性。一般来说，两个类型不同的对象总是不相等的(unequal)。某些对象提供了特殊的”等同性判定方法”(equality-checking method),如果已经知道两个受测对象都属干同一个类，那么就可以使用这种方法。以下述代码为例： 123456NSString *foo = @&quot;Badge:23&quot;; NSString *bar = [NSString stringWithFormat: @&quot;Badge:%i&quot;, 123]; BOOL equalA = (foo == bar); //&lt; equalA = NO BOOL equalB = [foo isEqual:bar]; //&lt; equalB = YES BOOL equalC = [foo isEqualToString:bar]; //&lt; equalC = YES 大家可以看到==与等同性判断方法之间的差别。NSString类实现了一个自己独有的同性判断方法，名叫” isEqualToString:”。传递给该方法的对象必须是NSString， 否则结果未定义(undefined).调用该方法比调用”isEqual:”方法快，后者还要执行额外的步骤，因为他不知道受测对象的类型。 NSObject协议中有两个用于判断等同性的关键方法：12- (BOOL)isEqual:(id)object; - (NSUInteger)hash; NSObject类对这两个方法的默认实现是：当且仅当其”指针值” (pointer value)完全相等时，这两个对象才相等。若想在自定义的对象中正确覆写这些方法，就必须先理解其约定(contract)。 如果 “ isEqual:” 方法判定两个对象相等，那么其hash方法也必须返回同一个值。但是，如果两个对象的hash方法返回同一个值，那么”isEqual:”方法未必会认为两者相等。比如有下面这个类：12345@interface SCPerson : NSObject @property (nonatomic, copy) NSString *firstName; @property (nonatomic, copy) NSString *lastName; @property (nonatomic, assign) NSUInteger age; @ end 我们认为，如果两个SCPerson的所有字段均相等，那么这西个对象就相等。于是isEqual:”方法可以写成：123456789101112- (Bool） isEqual: (id) object &#123;//指针类型的比较if (self == object) return YES; if ([self class] != [object class]) return NO;//对象类型的比较SCPerson *otherPerson = (SCPerson*)object; if (![ firstName isEqualToString:otherPerson.firstName]) return NO; if (![_lastName isEqualToString:otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES; &#125; 首先，直接判断两个指针是否相等。若相等，则其均指向同一对象，所以受测的对象也必定相等。接下来，比较西对象所属的类。若不属于同一个类，则两对象不相等。SCPerson对象当然不可能与SCDog对象相等。不过，有时我们可能认为：一个SCPerson实例可以与其子类（比如SCFanBingBingPerson)实例相等。在继承体系（inheritance hierarchy)中判断等同性时，经常遭遇此类问题。所以实现” isEqual:”方法时要考虑到这种情况.最后，检测每个属性是否相等。只要其中有不相等的属性，就判定两对象不等，否则两对象相等。 Hash 方法，根据等同性约定：若两对象相等，则其哈希码也相等，但是两个哈希码相同的对象却未必相等。这也是能否正确重写”isEqual:”方法的关键所在。编写 hash 方法时，应该用当前对象做做实验，以便在减少碰撞频度与降低运算复杂程度之间取舍。 特定类具有特定的等同性判定方法：123NSString isEqualToString:NSArray isEqualToArray:NSDictionary isEqualToDictionary: 常用的还有NSURL类的对比方法：1234567891011121314151617181920212223- (BOOL)isEqualToURL:(NSURL *)aURL &#123; if ([self isEqual:aURL]) return YES; if ([[self scheme] caseInsensitiveCompare:[aURL scheme]] != NSOrderedSame) return NO; if ([[self host] caseInsensitiveCompare:[aURL host]] != NSOrderedSame) return NO; // NSURL path is smart about trimming trailing slashes // note case-sensitivty here if ([[self path] compare:[aURL path]] != NSOrderedSame) return NO; // at this point, we&apos;ve established that the urls are equivalent according to the rfc // insofar as scheme, host, and paths match // according to rfc2616, port&apos;s can weakly match if one is missing and the // other is default for the scheme, but for now, let&apos;s insist on an explicit match if ([[self port] compare:[aURL port]] != NSOrderedSame) return NO; if ([[self query] compare:[aURL query]] != NSOrderedSame) return NO; // for things like user/pw, fragment, etc., seems sensible to be // permissive about these. (plus, I&apos;m tired :-)) return YES; &#125; 警告⚠️:由于 Objective-C在编译期不做强类型检查（strong type checking）,这样容易不小心传入类型错误的对象，因此开发者应该保证所传对象的类型是正确的。 在编写判定方法时，应该一并 override “isEqual:”方法，目的是：如果受测类型的参数与接收该消息的对象属于同一个类，那么就调用自己写的判定方法，否则就交给超类判断。 创建等同性判定方法时，需要决定是根据整个对象来判定等同性，还是仅根据其中几个字段来判断。 用一个 NSMutableSet 与几个 NSMutableArray 对象测试一下：123456先把一个数组加入set中： NSMutableSet *set = [NSMutableSet new]; NSMutableArray *arrayA = [@[@1, @2] mutableCopy]; [set addObject:arrayA]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2))&#125; 现在set里含有一个数组对象，数组中包含两个对象。再向set中加入一个数组，此数结与前一个数组所含的对象相同，顺序也相同，于是，待加入的数组与set中已有的数组是相等的：1234NSMutableArray *arrayB = [@[@1, @2] mutableCopy]; [set addObject:arrayB];NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2))&#125; 此时set里仍然只有一个对象：因为刚才要加人的那个数组对象和set中已有的数组对象相等，所以set并不会改变。这次我们来添加一个和set中已有对象不同的数组：12345678910111213NSMutableArray *arrayC = [@[@1] mutableCopy]; [set addObject:arrayC]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1), (1,2)&#125; 正如大家所料，由于arayC与set里已有的对象不相等，所以现在set里有两个数组了:其中一个是最早加入的，另一个是刚才新添加的。最后，我们改变arrayC的内容，令其和最早加入set的那个数组相等： [arrayC add0bject:@2]; NSLog((@&quot;set = %@&quot;, set); // Output: set = &#123;((1, 2) , (1, 2)&#125; set中居然可以泡含两个彼此相等的数组！根据set的语义是不允许出现这种情况的，然而现在却无法保证这一点了， 因为我们修改了 set中已有的对象。若是拷贝此set，那就更糟糕了 : NSSet *setB = [set copy]; NSLog(@&quot;setB = %@&quot;, setB)；// Output: setB = &#123;((1,2))&#125; 把某对象放入 set 之后，就不要在修改该对象的内容了，如果非要改变就要注意其存在的隐患，并使用相应的应对方法处理可能发生的问题。 以类簇模式隐藏实现细节创建类簇：（工厂模式（Factory pattern）是创建类簇的方法之一）定义抽象基类，每个”实体子类”(concrete subclass)都从基类继承而来； 在既有类中使用关联对象存放自定义数据 所谓关联对象（Associated Object），就是给某些对象关联许多其他对象，这些对象通过”键”来区分。存储对象值得时候，可以指明”存储策略”(storage policy),用以维护相应的”内存管理语义”。 关联类型 等效的@property属性 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic,copy OBJC_ASSOCIATION_RETAIN retain OBJC_ASSOCIATION_COPY copy 下列方法可以管理关联对象： 1void objc_setAssociatedObject(id object,void *key,id value,objc_AssociationPolicy policy) 此方法以给指定的键和策略为某对象设置关联对象值。 1id objc_getAssociatedObject(id object,void *key) 此方法根据指定的键从某对象中获取对应的关联对象值。 1void objc_removeAssociatedObjects(id object) 此方法移除指定对象的全部关联对象。 ​ 我们可以把某对象想象成 NSDictionary，把关联到该对象的值理解为字典中的条目，于是，存取关联对象的值就相当于在 NSDictionary 对象上调用[object setObejct:value forKey:key] 与[object valueForKey:key]方法。然而，两者之间有个重要的差别：设置关联对象时用的键（key）是一个“不透明的指针”(opaque pointer)。 如果在两个键上调用” isEqual:”方法返回的是 YES，那么 NSDictionary 就认为二者相等；然而在设置关联对象的值时，若想令两个键匹配到同一个值，则二者必须是完全相同的指针才行。鉴于此，在设置关联对象的值时，通常使用静态的全局变量做键（key）。 Objective-C概述（二）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[忆南工]]></title>
      <url>%2F2016%2F11%2F23%2F%E5%BF%86%E5%8D%97%E5%B7%A5%2F</url>
      <content type="text"><![CDATA[忆南工 能记起刚来南工的时候，香樟林里的香樟轻轻地摇着叶子，如今，校园里已是满地的枫叶和银杏叶，风很大，但人心却很暖。 昔我往矣，杨柳依依，今我来思，雨雪霏霏。 雪使我们感受到生命的美丽和短暂，使我们感到尽管存在敌意，可是人与人之间是非常相似的，还使我们感到时空的广阔和人世的狭窄。所以雪下得越大，人与人之间的距离越小，它似乎盖住了敌意、急躁和愤怒，使人与人之间更加接近。 苍茫白雪间，群屋静立。即使正在下着雪，我们也要在我们的路上。不管过程和结果，看看陌生人群和风景，俘获一颗能装下喜欢雪的心，初雪，只有你最美。 愿初雪不渡我，恋者有来生。 查看原文，请点击 原文链接@南工]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TouchID 的集成开发说明]]></title>
      <url>%2F2016%2F11%2F21%2FTouchID-%E7%9A%84%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[说明：TouchID 指纹识别是iPhone 5s设备新增的一项重大功能，用于数据加密和安全。而在iOS8.0 以后也向第三方开放了相应功能API，我们可以利用这个API做相应的用户验证和登录的功能，省去输入密码的环节，提高登录的用户体验。 TouchID API官方文档:API官方文档仅在 iOS 8.0 之后支持 12345678canEvaluatePolicy:监测设备是否支持TouchID，返回BOOL，并且若不支持，则在NSError里面返回相应状态evaluatePolicy:TouchID验证状态，在Block里面返回验证状态BOOL和NSErroriOS 9.0以后，有更加严密的 TouchID 认证流程，方法如下：- (void)evaluateAccessControl:(SecAccessControlRef)accessControl operation:(LAAccessControlOperation)operation localizedReason:(NSString *)localizedReason reply:(void(^)(BOOL success, NSError * __nullable error))replyNS_AVAILABLE(10_11, 9_0) __WATCHOS_AVAILABLE(3.0) __TVOS_UNAVAILABLE; 逻辑流程设计：在设备第一次使用指纹登录之前，必须先登录原有的账号（app注册账号），进行设备（用户）绑定。 绑定TouchID举例说明： 1、开启指纹验证：在app登录后，比如：在“用户信息－安全”，点击开启“指纹登录”； 2、验证TouchID：检测当前设备是否支持TouchID，若支持则发起TouchID验证； 3、把账号/密码写入 KeyChain：TouchID验证通过后，根据当前已登录的账号和硬件设备Token，生成设备账号/密码（规则可自定，密码要长要复杂），并保存在keychain； 4、绑定：生成设备账号/密码后，将原账号及设备账号/密码，加密后发送到服务端进行绑定； 5、成功：验证原账号及设备账号有效后，返回相应状态，绑定成功则完成整个TouchID（设备）绑定流程。 使用已经绑定的TouchID登录： 在设备（用户）绑定之后，并且用户账号退出后，可以使用指纹登录，若当前设备未绑定，则不会出现“指纹登录” 按钮。 流程说明： 1、TouchID登录：绑定成功后，在用户登录界面，点击“指纹登录”； 2、验证TouchID：检测当前设备是否支持TouchID，若支持则发起TouchID验证； 3、验证登录：从 keychain 读取app在本机存储的设备账号/密码，调用 app 登录接口，发起登录请求； 4、成功：验证设备账号/密码后，返回相应状态，登录成功则完成整个TouchID登录流程。 需要导入LocalAuthentication.framework 特别注意：在使用的过程中，看清属性是在 iOS XX_0 几之后才支持才允许使用的，很多属性和特性都是随着机型的迭代而新增的；使用不当会崩溃哟。用TouchID进行验证登录，尤其涉及到安全和隐私问题，这方面，我们尤其要重视！！！ 几步关键性操作示例如下：验证本机是否支持 TouchID 12345678- (BOOL)isSupportTouchID&#123; //首先使用canEvaluatePolicy 判断设备支持状态 if ([self.context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:nil]) &#123; return YES; &#125; return NO;&#125; 支持,则将密码与 TouchID 进行绑定，并将密码写入 keychain.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- (void)contextBindingTouchIDWithBindString:(NSString *)bindString policy:(LAPolicy)policy complete:(LXBindingInfoCompleteBlock)complete&#123; if (![self isSupportTouchID]) &#123; complete(NO,nil,@"设备不支持 TouchID"); return; &#125; CFErrorRef error = NULL; // Should be the secret invalidated when passcode is removed? If not then use kSecAttrAccessibleWhenUnlocked SecAccessControlRef sacObject = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, kSecAccessControlTouchIDAny, &amp;error); if (sacObject == NULL || error != NULL) &#123; NSString *errorString = [NSString stringWithFormat:@"SecItemAdd can't create sacObject: %@", error]; NSLog(@"errorString : %@",errorString); complete(NO,(__bridge NSError *)(error),errorString); return; &#125; //默认iOS8.0的验证方式，验证通过，再绑定 /* LAPolicyDeviceOwnerAuthenticationWithBiometrics NS_ENUM_AVAILABLE(NA, 8_0) LAPolicyDeviceOwnerAuthentication NS_ENUM_AVAILABLE(10_11, 9_0) */ [self fingerprintAuthenticationPolicy:policy localizedFallbackTitle:@"" complete:^(BOOL isSuccess, NSError *error, LXLAError errorCode, NSString *errorReason) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (isSuccess) &#123; /* We want the operation to fail if there is an item which needs authentication so we will use `kSecUseNoAuthenticationUI`. */ NSData *secretTextData = [bindString dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary *attributes = @&#123; (id)kSecClass: (id)kSecClassGenericPassword, (id)kSecAttrService: [SCAppMonitor appName], (id)kSecValueData: secretTextData, (id)kSecUseAuthenticationUI: (id)kSecUseAuthenticationUIAllow, (id)kSecAttrAccessControl: (__bridge_transfer id)sacObject &#125;; OSStatus status = SecItemAdd((__bridge CFDictionaryRef)attributes, nil); NSString *message = [NSString stringWithFormat:@"SecItemAdd status: %@", [self keychainErrorToString:status]]; NSLog(@"message : %@",message); complete(YES,nil,@"指纹验证成功"); &#125; else&#123; complete(NO,nil,@"指纹验证失败"); &#125; &#125;); &#125;];&#125; 从 keychain 中查询与 TouchID 绑定的密码。123456789101112131415161718192021222324- (void)queryInfoFromKeyChain:(LXQueryBindInfoCompleteBlock)complete&#123; NSDictionary *query = @&#123; (id)kSecClass: (id)kSecClassGenericPassword, (id)kSecAttrService: [SCAppMonitor appName], (id)kSecReturnData: @YES, (id)kSecUseOperationPrompt: @"Authenticate to access service password", &#125;; dispatch_async(dispatch_get_main_queue(), ^&#123; NSString *message; CFTypeRef dataTypeRef = NULL; OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)(query), &amp;dataTypeRef); if (status == errSecSuccess) &#123; NSData *resultData = (__bridge_transfer NSData *)dataTypeRef; message = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding]; complete(YES,message,nil); &#125; else &#123; message = [NSString stringWithFormat:@"SecItemCopyMatching status: %@", [self keychainErrorToString:status]]; complete(NO,nil,@"指纹验证失败"); &#125; &#125;);&#125; 指纹识别概念阐述]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[站在岁月之巅放牧心灵]]></title>
      <url>%2F2016%2F11%2F18%2F%E7%AB%99%E5%9C%A8%E5%B2%81%E6%9C%88%E4%B9%8B%E5%B7%85%E6%94%BE%E7%89%A7%E5%BF%83%E7%81%B5%2F</url>
      <content type="text"><![CDATA[生命，是一树花开， 或安静或热烈，或寂寞或璀璨。 — 日子，在岁月的年轮中渐次厚重，那些天真的、跃动的、抑或沉思的灵魂，在繁华与喧嚣中，被刻上深深浅浅、或浓或淡的印痕。 很欣赏这样一句话：生命，是一场虚妄。其实，经年过往，每个人何尝不是在这场虚妄里跋涉?在真实的笑里哭着，在真实的哭里笑着，一笺烟雨，半帘幽梦，许多时候，我们不得不承认：生活，不是不寂寞，只是不想说。 于无声处倾听凡尘落素，渐渐明白：人生，总会有许多无奈，希望、失望、憧憬、彷徨，苦过了，才知甜蜜;痛过了，才懂坚强;傻过了，才会成长。生命中，总有一些令人唏嘘的空白，有些人，让你牵挂，却不能相守;有些东西，让你羡慕，却不能拥有;有些错过，让你留恋，却终生遗憾。 在这喧闹的凡尘，我们需要有适合自己的地方，用来安放灵魂。也许，是一座安静宅院;也许，是一本无字经书;也许，是一条迷津小路。只要是自己心之所往，便是驿站，为了将来起程时，不再那么迷惘。 红尘三千丈，念在山水间。生活，不总是一帆风顺。因为爱，所以放手;因为放手，所以沉默;因为一份懂得，所以安心着一个回眸。也许，有风有雨的日子，才承载了生命的厚重;风轻云淡的日子，更适于静静领悟。 深深懂得：这世界上，并不是所有的东西都符合想象。有些时候，山是水的故事，云是风的故事;有些时候，星不是夜的故事，情不是爱的故事。生命的旅途中，许多人走着、走着，就散了;许多事看着、看着，就淡了;许多梦做着、做着，就断了;许多泪流着、流着，就干了。人生，原本就是风尘中的沧海桑田，只是，回眸处，世态炎凉演绎成了苦辣酸甜。 喜欢那种淡到极致的美，不急不躁，不温不火，款步有声，舒缓有序;一弯浅笑，万千深情，尘烟几许，浅思淡行。于时光深处，静看花开花谢，虽历尽沧桑，仍含笑一腔温暖如初。其实，不是不深情，是曾经情太深;不是不懂爱，是爱过知酒浓。生活的阡陌中，没有人改变得了纵横交错的曾经，只是，在渐行渐远的回望里，那些痛过的、哭过的，都演绎成了坚强;那些不忍遗忘的、念念不忘的，都风干成了风景。 站在岁月之巅放牧心灵，山一程，水一程，红尘、沧桑、流年、清欢，一个人的夜晚，我们终于学会了：于一怀淡泊中，笑望两个人的白月光。 盈一抹领悟，收藏点点滴滴的快乐，经年流转，透过指尖的温度，期许岁月静好，这一路走来，你会发现，生活于我们，温暖，一直是一种牵引，不是吗?于生活的海洋中踏浪，云帆尽头，轻回眸，处处是别有洞天，云淡风轻。 有一种经年叫历尽沧桑，有一种远眺叫含泪微笑，有一种追求叫浅行静思，有一种美丽叫淡到极致。给生命一个微笑的理由吧，别让自己的心承载太多的负重;给自己一个取暖的方式吧，以风的执念求索，以莲的姿态恬淡，盈一抹微笑，将岁月打磨成人生枝头最美的风景。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仓央嘉措情诗]]></title>
      <url>%2F2016%2F11%2F16%2F%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E6%83%85%E8%AF%97%2F</url>
      <content type="text"><![CDATA[见与不见 你见，或者不见我 我就在那里 不悲不喜 你念，或者不念我 情就在那里 不来不去 你爱，或者不爱我 爱就在那里 不增不减 你跟，或者不跟我 我的手就在你手里 不舍不弃 来我的怀里 或者 让我住进你的心里 默然 相爱寂静 欢喜 原文链接请戳]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>%2F2016%2F11%2F16%2F%E5%85%B3%E4%BA%8E%E6%88%91%2F</url>
      <content type="text"><![CDATA[你一旦心有所向，自然会身之所往！You’ll walk when you has someplace to go!知乎@柴亚航微博@柴亚航简书@柴亚航“站在岁月之巅放牧心灵，山一程，水一程，红尘、沧桑、流年、清欢，一个人的夜晚，我们终于学会了：于一杯淡泊中，笑望两个人的白月光。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
