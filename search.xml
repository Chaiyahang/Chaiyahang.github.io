<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[系统原生请求表单上传]]></title>
      <url>%2F2016%2F12%2F02%2F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E8%AF%B7%E6%B1%82%E8%A1%A8%E5%8D%95%E4%B8%8A%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[创建NSMutableURLRequest请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768- (void)setRequest:(NSMutableURLRequest *)request&#123; NSString *boundary = [NSString stringWithFormat:@&quot;Boundary+%08X%08X&quot;, arc4random(), arc4random()]; NSMutableData *body = [NSMutableData data]; // 表单数据 NSMutableDictionary *param = [[NSMutableDictionary alloc] init];// [param setValue:@&quot;254&quot; forKey:@&quot;empId&quot;];// [param setValue:@&quot;18718&quot; forKey:@&quot;shopId&quot;]; /** 遍历字典将字典中的键值对转换成请求格式: --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;empId&quot; 254 --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;shopId&quot; 18718 */ [param enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSMutableString *fieldStr = [NSMutableString string]; [fieldStr appendString:[NSString stringWithFormat:@&quot;--%@\r\n&quot;, boundary]]; [fieldStr appendString:[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;\r\n\r\n&quot;, key]]; [fieldStr appendString:[NSString stringWithFormat:@&quot;%@&quot;, obj]]; [body appendData:[fieldStr dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:[@&quot;\r\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; &#125;]; /// 图片数据部分 NSMutableString *topStr = [NSMutableString string]; NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;001.jpeg&quot; ofType:nil]; NSData *data = [NSData dataWithContentsOfFile:path]; /**拼装成格式： --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;uploadFile&quot;; filename=&quot;001.png&quot; Content-Type:image/png Content-Transfer-Encoding: binary ... contents of boris.png ... */ [topStr appendString:[NSString stringWithFormat:@&quot;--%@\r\n&quot;, boundary]]; [topStr appendString:@&quot;Content-Disposition: form-data; name=\&quot;file\&quot;; filename=\&quot;001.png\&quot;\r\n&quot;];//⚠️注意：此处的『name=\&quot;file\&quot;』这个 file 就是你后端服务器定义的文件流的字段，特此提醒 [topStr appendString:@&quot;Content-Type:image/jpg\r\n&quot;]; [topStr appendString:@&quot;Content-Transfer-Encoding: binary\r\n\r\n&quot;]; [body appendData:[topStr dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:data]; [body appendData:[@&quot;\r\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; // 结束部分 NSString *bottomStr = [NSString stringWithFormat:@&quot;--%@--&quot;, boundary]; /**拼装成格式： --Boundary+72D4CD655314C423-- */ [body appendData:[bottomStr dataUsingEncoding:NSUTF8StringEncoding]]; // 设置请求类型为post请求 request.HTTPMethod = @&quot;post&quot;; // 设置request的请求体 request.HTTPBody = body; // 设置头部数据，标明上传数据总大小，用于服务器接收校验 [request setValue:[NSString stringWithFormat:@&quot;%lu&quot;, (unsigned long)body.length] forHTTPHeaderField:@&quot;Content-Length&quot;]; // 设置头部数据，指定了http post请求的编码方式为multipart/form-data（上传文件必须用这个）。 [request setValue:[NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,boundary] forHTTPHeaderField:@&quot;Content-Type&quot;];&#125; 上传文件流12345678910111213141516- (void)upload&#123; //uploadModule - 1 im 2 app 3 other //TODO:需要修改 NSString *urlStr = [NSString stringWithFormat:@&quot;http://qp.lianxi.com/file/upload?apiCode=%@&amp;uploadType=1&amp;uploadModule=2&amp;originalFlag=1&quot;,_share_apiCode]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlStr] cachePolicy:0 timeoutInterval:30.0f]; [self setRequest:request]; NSLog(@&quot;开始上传...&quot;); [NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc] init] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; //这里就是服务器返回的图片地址 NSLog(@&quot;Result--%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); &#125;];&#125; 参考文章原文地址 我的我的简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C概述]]></title>
      <url>%2F2016%2F11%2F30%2FObjective-C%E6%A6%82%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[Objective-C的起源Objective-C与 C++、Java、C# 等面向对象的语言类似，不过很多方面有所差别。若是使用过一种面向对象的开发语言，那么就能理解Objective-C所用的『范式和模板』了。然而，语法上会略显陌生，因为Objective-C使用的是&quot;消息结构&quot;而非&quot;函数调用&quot;。Objective-C是由 [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk) 演化而来，后者是消息型语言的鼻祖。他们之间的调用看起来就是这样： 1234567//Messaging （Objective-C）Object *obj = [Object new];[obj performWith:parameter1 and:parameter2];//Function calling (C++)Object *obj = [Object new];obj-&gt;perform(parameter1,parameter2); 关键的区别在于：使用消息结构的语言，其运行时所执行的代码是由运行时环境决定的；而使用函数调用的语言，则由编译器决定。如果上例代码中调用的函数是多态的，那么在运行时就要按照&quot;虚方法表&quot;(virture method table)来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。 Notes：virture method table是编程语言为实现&quot;动态派发&quot;（dynamic dispatch）或 &quot;运行时方法绑定&quot;（runtime method binding） 而采用的一种机制。 在类的头文件中尽量少引入其他头文件可以使用@class 关键字&quot;向前声明&quot;（forward declaring） 该类。引入过多的并不需要的头文件，会增加编译时间，还会导致循环引用。使用『向前声明』可以解决互相引用的问题，减少编译时间，而且还能降低彼此的依赖程度（即我们经常说的降低耦合性） 多用字面量语法（literal syntax），少用与之等价的方法字面数值1234&lt;!-- 字面数值 --&gt;NSNumber *someNumber = [NSNumber numberWithInt:1];等价于NSNumber *someNumber = @1; 字面量语法更加精简。能够以 NSNumber 实例表示的所有数据类型都可以使用这种表示方式。 字面数组123456789&lt;!-- 字面量数组 --&gt; NSArray *array = [NSArray arrayWithObjects:@&quot;Hello&quot;,@&quot;World&quot;,nil]; 等价于 NSArray *array = [@&quot;Hello&quot;,@&quot;World&quot;]; 对应的使用方法：(取下标操作subscripting) NSString *animal = [array objectAtIndex:0]; 等价于 NSString *animal = array[0]; 字面字典 &quot;字典&quot;是一种映射型数据结构，可向其中添加键值对。 123456789&lt;!-- 字面量字典 --&gt; NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Hello&quot;:@&quot;H&quot;,@&quot;World&quot;:@&quot;W&quot;,[NSNumber numberWithInt:28]:@&quot;A&quot;,nil]; 等价于 NSDictionary *dictionary = @&#123;@&quot;H&quot;:@&quot;Hello&quot;,@&quot;W&quot;:@&quot;World&quot;,@&quot;A&quot;:@28&#125;; 对应的使用方法： NSString *animal = [dictionary valueForKey:@&quot;H&quot;]; 等价于 NSString *animal = dictionary[@&quot;H&quot;]; 使用字面量语法的局限性： 1、除了字符串以外，创建出来的对象必须是 Foundation 框架下的才行。 2、定义了这些可行的子类话，则无法继续使用字面量语法创建对象。 3、使用字面量创建出来的字符串、数组、字典对象都是不可变的（immutable），若要可变，需要调用 mutableCopy。比如：NSMutableDictionary *mutable = [@{@&quot;H&quot;:@&quot;Hello&quot;,@&quot;W&quot;:@&quot;World&quot;,@&quot;A&quot;:@28} mutableCopy] 使用字面量语法的好处： 1、可以缩减代码的长度 使其更加易读 2、使用字面量语法更加安全 3、字面量语法实际上只是一种[&quot;语法糖&quot;syntactic sugar](http://zh.wikipedia.org/wiki/语法糖) 4、使用字面量语法创建数组或字典时，值中不能有 nil 对象，否则抛出异常。其实这样，更便于查错。纠错。 多用类型常量，少用『#define』 预处理指令123456789 #define ANIMATION_DURATION 0.3 //没有类型信息 与 static const NSTimeInterval KAnimationDuration = 0.3; //包含类型信息 //变量名已定要同时使用 const 和 static 来声明。 //其实这些都是一些命名规范，后边细述。` 有时候需要公开某个常量。比如，你可能会给代码块中某个 Event 发送通知（NSNotification）。派发通知时需要使用字符串来表示此项通知的名称，而这个名字就可以为一个外界可见的常值变量（constant variable）。这样的话，注册者无需知道实际字符串的值，只需要以常值变量来注册自己想要接收到的通知即可。此类常量需放在&quot;全局符号表&quot;（global symbol table）中，以便可以再定义该常量的编译单元之外使用。和上边的 static const 有所不同： 1234567//In the header fileextern NSString *const SCStringRefreshNotification; //常量指针//In the implementation fileNSString *const SCStringRefreshNotification = @&quot;SCStringRefreshNotification&quot;;//点 h 文件声明，点 m 文件定义 总之，不要使用预处理指令定义常量。这样定义出来的常量不仅不包含类型信息，而且有人修改了（或重新定义了）这个常量值编译器也不会产生警告⚠️信息。 在实现文件使用 static const 来定义&quot;只在编译单元内可见的变量&quot;(translation-unit-specific constant)。这类常量不会出现在全局符号表中，所以无需为其名称加前缀。 在头文件使用 extern 来声明全局常量，并在实现文件中定义其值。这类常量会出现在全局符号表中，所以通常用与之相关的类名做前缀。 用枚举表示状态、选项、状态吗一个字节含8个二进制位，所以至多能表示可取256种（2^8个）枚举（编号为0~255）的枚举变量。 动态绑定（Dynamic Binding）未完待续，持续补充…..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[忆南工]]></title>
      <url>%2F2016%2F11%2F23%2F%E5%BF%86%E5%8D%97%E5%B7%A5%2F</url>
      <content type="text"><![CDATA[忆南工 能记起刚来南工的时候，香樟林里的香樟轻轻地摇着叶子，如今，校园里已是满地的枫叶和银杏叶，风很大，但人心却很暖。 昔我往矣，杨柳依依，今我来思，雨雪霏霏。 雪使我们感受到生命的美丽和短暂，使我们感到尽管存在敌意，可是人与人之间是非常相似的，还使我们感到时空的广阔和人世的狭窄。所以雪下得越大，人与人之间的距离越小，它似乎盖住了敌意、急躁和愤怒，使人与人之间更加接近。 苍茫白雪间，群屋静立。即使正在下着雪，我们也要在我们的路上。不管过程和结果，看看陌生人群和风景，俘获一颗能装下喜欢雪的心，初雪，只有你最美。 愿初雪不渡我，恋者有来生。 查看原文，请点击 原文链接@南工]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TouchID 的集成开发说明]]></title>
      <url>%2F2016%2F11%2F21%2FTouchID-%E7%9A%84%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[说明：TouchID 指纹识别是iPhone 5s设备新增的一项重大功能，用于数据加密和安全。而在iOS8.0 以后也向第三方开放了相应功能API，我们可以利用这个API做相应的用户验证和登录的功能，省去输入密码的环节，提高登录的用户体验。 TouchID API官方文档:API官方文档仅在 iOS 8.0 之后支持 12345678canEvaluatePolicy:监测设备是否支持TouchID，返回BOOL，并且若不支持，则在NSError里面返回相应状态evaluatePolicy:TouchID验证状态，在Block里面返回验证状态BOOL和NSErroriOS 9.0以后，有更加严密的 TouchID 认证流程，方法如下：- (void)evaluateAccessControl:(SecAccessControlRef)accessControl operation:(LAAccessControlOperation)operation localizedReason:(NSString *)localizedReason reply:(void(^)(BOOL success, NSError * __nullable error))replyNS_AVAILABLE(10_11, 9_0) __WATCHOS_AVAILABLE(3.0) __TVOS_UNAVAILABLE; 逻辑流程设计：在设备第一次使用指纹登录之前，必须先登录原有的账号（app注册账号），进行设备（用户）绑定。 绑定TouchID举例说明： 1、开启指纹验证：在app登录后，比如：在“用户信息－安全”，点击开启“指纹登录”； 2、验证TouchID：检测当前设备是否支持TouchID，若支持则发起TouchID验证； 3、把账号/密码写入 KeyChain：TouchID验证通过后，根据当前已登录的账号和硬件设备Token，生成设备账号/密码（规则可自定，密码要长要复杂），并保存在keychain； 4、绑定：生成设备账号/密码后，将原账号及设备账号/密码，加密后发送到服务端进行绑定； 5、成功：验证原账号及设备账号有效后，返回相应状态，绑定成功则完成整个TouchID（设备）绑定流程。 使用已经绑定的TouchID登录： 在设备（用户）绑定之后，并且用户账号退出后，可以使用指纹登录，若当前设备未绑定，则不会出现“指纹登录” 按钮。 流程说明： 1、TouchID登录：绑定成功后，在用户登录界面，点击“指纹登录”； 2、验证TouchID：检测当前设备是否支持TouchID，若支持则发起TouchID验证； 3、验证登录：从 keychain 读取app在本机存储的设备账号/密码，调用 app 登录接口，发起登录请求； 4、成功：验证设备账号/密码后，返回相应状态，登录成功则完成整个TouchID登录流程。 需要导入LocalAuthentication.framework 特别注意：在使用的过程中，看清属性是在 iOS XX_0 几之后才支持才允许使用的，很多属性和特性都是随着机型的迭代而新增的；使用不当会崩溃哟。用TouchID进行验证登录，尤其涉及到安全和隐私问题，这方面，我们尤其要重视！！！ 几步关键性操作示例如下：验证本机是否支持 TouchID 12345678- (BOOL)isSupportTouchID&#123; //首先使用canEvaluatePolicy 判断设备支持状态 if ([self.context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:nil]) &#123; return YES; &#125; return NO;&#125; 支持,则将密码与 TouchID 进行绑定，并将密码写入 keychain.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- (void)contextBindingTouchIDWithBindString:(NSString *)bindString policy:(LAPolicy)policy complete:(LXBindingInfoCompleteBlock)complete&#123; if (![self isSupportTouchID]) &#123; complete(NO,nil,@&quot;设备不支持 TouchID&quot;); return; &#125; CFErrorRef error = NULL; // Should be the secret invalidated when passcode is removed? If not then use kSecAttrAccessibleWhenUnlocked SecAccessControlRef sacObject = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, kSecAccessControlTouchIDAny, &amp;error); if (sacObject == NULL || error != NULL) &#123; NSString *errorString = [NSString stringWithFormat:@&quot;SecItemAdd can&apos;t create sacObject: %@&quot;, error]; NSLog(@&quot;errorString : %@&quot;,errorString); complete(NO,(__bridge NSError *)(error),errorString); return; &#125; //默认iOS8.0的验证方式，验证通过，再绑定 /* LAPolicyDeviceOwnerAuthenticationWithBiometrics NS_ENUM_AVAILABLE(NA, 8_0) LAPolicyDeviceOwnerAuthentication NS_ENUM_AVAILABLE(10_11, 9_0) */ [self fingerprintAuthenticationPolicy:policy localizedFallbackTitle:@&quot;&quot; complete:^(BOOL isSuccess, NSError *error, LXLAError errorCode, NSString *errorReason) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (isSuccess) &#123; /* We want the operation to fail if there is an item which needs authentication so we will use `kSecUseNoAuthenticationUI`. */ NSData *secretTextData = [bindString dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary *attributes = @&#123; (id)kSecClass: (id)kSecClassGenericPassword, (id)kSecAttrService: [SCAppMonitor appName], (id)kSecValueData: secretTextData, (id)kSecUseAuthenticationUI: (id)kSecUseAuthenticationUIAllow, (id)kSecAttrAccessControl: (__bridge_transfer id)sacObject &#125;; OSStatus status = SecItemAdd((__bridge CFDictionaryRef)attributes, nil); NSString *message = [NSString stringWithFormat:@&quot;SecItemAdd status: %@&quot;, [self keychainErrorToString:status]]; NSLog(@&quot;message : %@&quot;,message); complete(YES,nil,@&quot;指纹验证成功&quot;); &#125; else&#123; complete(NO,nil,@&quot;指纹验证失败&quot;); &#125; &#125;); &#125;];&#125; 从 keychain 中查询与 TouchID 绑定的密码。123456789101112131415161718192021222324- (void)queryInfoFromKeyChain:(LXQueryBindInfoCompleteBlock)complete&#123; NSDictionary *query = @&#123; (id)kSecClass: (id)kSecClassGenericPassword, (id)kSecAttrService: [SCAppMonitor appName], (id)kSecReturnData: @YES, (id)kSecUseOperationPrompt: @&quot;Authenticate to access service password&quot;, &#125;; dispatch_async(dispatch_get_main_queue(), ^&#123; NSString *message; CFTypeRef dataTypeRef = NULL; OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)(query), &amp;dataTypeRef); if (status == errSecSuccess) &#123; NSData *resultData = (__bridge_transfer NSData *)dataTypeRef; message = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding]; complete(YES,message,nil); &#125; else &#123; message = [NSString stringWithFormat:@&quot;SecItemCopyMatching status: %@&quot;, [self keychainErrorToString:status]]; complete(NO,nil,@&quot;指纹验证失败&quot;); &#125; &#125;);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[站在岁月之巅放牧心灵]]></title>
      <url>%2F2016%2F11%2F18%2F%E7%AB%99%E5%9C%A8%E5%B2%81%E6%9C%88%E4%B9%8B%E5%B7%85%E6%94%BE%E7%89%A7%E5%BF%83%E7%81%B5%2F</url>
      <content type="text"><![CDATA[生命，是一树花开， 或安静或热烈，或寂寞或璀璨。 — 日子，在岁月的年轮中渐次厚重，那些天真的、跃动的、抑或沉思的灵魂，在繁华与喧嚣中，被刻上深深浅浅、或浓或淡的印痕。 很欣赏这样一句话：生命，是一场虚妄。其实，经年过往，每个人何尝不是在这场虚妄里跋涉?在真实的笑里哭着，在真实的哭里笑着，一笺烟雨，半帘幽梦，许多时候，我们不得不承认：生活，不是不寂寞，只是不想说。 于无声处倾听凡尘落素，渐渐明白：人生，总会有许多无奈，希望、失望、憧憬、彷徨，苦过了，才知甜蜜;痛过了，才懂坚强;傻过了，才会成长。生命中，总有一些令人唏嘘的空白，有些人，让你牵挂，却不能相守;有些东西，让你羡慕，却不能拥有;有些错过，让你留恋，却终生遗憾。 在这喧闹的凡尘，我们需要有适合自己的地方，用来安放灵魂。也许，是一座安静宅院;也许，是一本无字经书;也许，是一条迷津小路。只要是自己心之所往，便是驿站，为了将来起程时，不再那么迷惘。 红尘三千丈，念在山水间。生活，不总是一帆风顺。因为爱，所以放手;因为放手，所以沉默;因为一份懂得，所以安心着一个回眸。也许，有风有雨的日子，才承载了生命的厚重;风轻云淡的日子，更适于静静领悟。 深深懂得：这世界上，并不是所有的东西都符合想象。有些时候，山是水的故事，云是风的故事;有些时候，星不是夜的故事，情不是爱的故事。生命的旅途中，许多人走着、走着，就散了;许多事看着、看着，就淡了;许多梦做着、做着，就断了;许多泪流着、流着，就干了。人生，原本就是风尘中的沧海桑田，只是，回眸处，世态炎凉演绎成了苦辣酸甜。 喜欢那种淡到极致的美，不急不躁，不温不火，款步有声，舒缓有序;一弯浅笑，万千深情，尘烟几许，浅思淡行。于时光深处，静看花开花谢，虽历尽沧桑，仍含笑一腔温暖如初。其实，不是不深情，是曾经情太深;不是不懂爱，是爱过知酒浓。生活的阡陌中，没有人改变得了纵横交错的曾经，只是，在渐行渐远的回望里，那些痛过的、哭过的，都演绎成了坚强;那些不忍遗忘的、念念不忘的，都风干成了风景。 站在岁月之巅放牧心灵，山一程，水一程，红尘、沧桑、流年、清欢，一个人的夜晚，我们终于学会了：于一怀淡泊中，笑望两个人的白月光。 盈一抹领悟，收藏点点滴滴的快乐，经年流转，透过指尖的温度，期许岁月静好，这一路走来，你会发现，生活于我们，温暖，一直是一种牵引，不是吗?于生活的海洋中踏浪，云帆尽头，轻回眸，处处是别有洞天，云淡风轻。 有一种经年叫历尽沧桑，有一种远眺叫含泪微笑，有一种追求叫浅行静思，有一种美丽叫淡到极致。给生命一个微笑的理由吧，别让自己的心承载太多的负重;给自己一个取暖的方式吧，以风的执念求索，以莲的姿态恬淡，盈一抹微笑，将岁月打磨成人生枝头最美的风景。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仓央嘉措情诗]]></title>
      <url>%2F2016%2F11%2F16%2F%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E6%83%85%E8%AF%97%2F</url>
      <content type="text"><![CDATA[见与不见 你见，或者不见我 我就在那里 不悲不喜 你念，或者不念我 情就在那里 不来不去 你爱，或者不爱我 爱就在那里 不增不减 你跟，或者不跟我 我的手就在你手里 不舍不弃 来我的怀里 或者 让我住进你的心里 默然 相爱寂静 欢喜 想要查看完整版 请点击 仓央嘉措的诗集（完整版）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>%2F2016%2F11%2F16%2F%E5%85%B3%E4%BA%8E%E6%88%91%2F</url>
      <content type="text"><![CDATA[你一旦心有所向，自然会身之所往！You’ll walk when you has someplace to go!知乎@柴亚航微博@柴亚航简书@柴亚航“站在岁月之巅放牧心灵，山一程，水一程，红尘、沧桑、流年、清欢，一个人的夜晚，我们终于学会了：于一杯淡泊中，笑望两个人的白月光。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
