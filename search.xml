<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hexo博客添加图片、音乐、视频]]></title>
      <url>%2F2017%2F01%2F13%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E3%80%81%E9%9F%B3%E4%B9%90%E3%80%81%E8%A7%86%E9%A2%91%2F</url>
      <content type="text"><![CDATA[Hexo博客添加图片、音乐、视频 ———— “临渊羡鱼，不如退而结网” 一、添加图片既可以是本地图片 ，也可以是添加外部链接图片 1、本地图片在\hexo\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式： 2、外链图片可以使用 iPic 上传图片 二、添加音乐12345&lt;center&gt;&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt; &lt;/center&gt; 三、添加视频视频也和音乐类似，先输入视频标题，回车换一行插入代码即可。 1234"2017小米年会雷军跳鬼步舞视频:"&lt;center&gt; &lt;iframe height=498 width=510 src="http://t.cn/z8AluUz http://t.cn/RMSFvPU" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt; 1234"2017小米年会爆笑神曲“咋了开发”:"&lt;center&gt; &lt;iframe height=498 width=510 src="http://www.toutiao.com/i6374714213071323650/" frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《好吗 好的》随笔]]></title>
      <url>%2F2017%2F01%2F04%2F%E3%80%8A%E5%A5%BD%E5%90%97-%E5%A5%BD%E7%9A%84%E3%80%8B%E9%9A%8F%E7%AC%94%2F</url>
      <content type="text"><![CDATA[好吗好的 书评： 刘敏常说，只要你对得起舞台，舞台就会对得起你。 你是否也有过那种错觉： 牵手的人不会松手，同路的人不会分开，缓缓流淌的岁月永不会改道，昨天和今天所拥有的，总会顺理成章地延续到明天，乃至永远。 世间最大的错觉，无外乎自以为是的永远。 世上大部分永远，大都是一厢情愿的错觉。 万事万物走的都是抛物线，并没有恒久的低谷或顶点，转折点出现时，我和她已搭档了很多年。 她转身，看我一眼，又移开目光。头再转过来时，双臂也轻轻展开在我面前，平静的目光注视着我，她轻声说：过来…… 我又惊讶又好笑，上前接住那个拥抱：干吗，好好的抱我干吗？你什么时候学得这么矫情了？ 她不说话，手轻轻拍在我背上，一下又一下，身体也轻轻地左右摇晃着，好像个哄孩子睡觉的年轻妈妈。我笑，拜托，别老把我当小朋友好吗？我眼瞅快30岁的人了。 她笑笑松开我，说：好了好了，走了走了。 没有告别，她只要走了一个拥抱，平静的目光注视着我，双臂轻轻展开在我面前，她轻声说：过来…… ##########附录########### 早班地铁挤满了上班的人，座位紧张，她不善争，像个农民工一样蹲坐在地上……有观众认出了她，拍下了照片在网络上传给我，我问，为什么不给她让个座？！ 那位观众说让了，她谢了半天，但怎么也不肯坐……她说如果一大清早就安逸了，接下来一整天的斗志也就全没了。 你我的旧时光，如那漫漫长路，永不消亡 我们俩披着雨衣，屋檐下伫立，阳光在上 你们长大了，我们也该谢幕了。 就用这篇文章，最后送你们一程吧： 祝你永不孤独。 祝你过得好。 祝你阳光快车道。 别人的经验与你的人生无关。 同理，我笔下的故事桥段，与你脚下的人生也无关。 自己去尝试，自己去选择吧，先尝试，再选择，认准方向后，作死地撑住，边撑边掌握平衡。 平行世界，多元生活，既可以朝九晚五，又能够浪迹天涯。 愿你知行合一，愿你能心安。 好吗好的。 ………… 写于：2016年11月09日13:55:34]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读《嫌疑人X的献身》所写]]></title>
      <url>%2F2017%2F01%2F04%2F%E8%AF%BB%E3%80%8A%E5%AB%8C%E7%96%91%E4%BA%BAX%E7%9A%84%E7%8C%AE%E8%BA%AB%E3%80%8B%E6%89%80%E5%86%99%2F</url>
      <content type="text"><![CDATA[东野圭吾于1999年以《秘密)》获第52届日本推理作家协会奖，2006年以《嫌疑人X的献身》获第134届直木赏和本格推理大奖，此书并一举拿下当年度三大推理小说排行榜——“‘这本推理小说了不起！’”、《本格推理小说 Best 10》和“周刊文春推理小说 Best 10”的第一名，故有三冠王之称。 东野圭吾《嫌疑人X的献身》感悟： 整个案件的起源是一对离婚夫妇之间男方纠缠不清的蛮横无理，跌宕之处在数学家出手相助于长久以来暗恋的隔壁女郎，然后情节跌宕起伏于警察和数学家的较量，最后铺垫于物理学家与数学家脑力之间的博弈…… “看起来是几何问题，其实是函数问题” 警察喜好攻心术，物理学家喜欢演绎推理，观察细致入微，洞悉人性的弱点…… 石神说，“之前你问过我一个我问题：设计别人解不开的问题和解开那个问题，何者更难——你还记得吗?” 汤川学说，“我的答案是，设计问题更难。我向来认为，解答者应该对出题者心怀敬意。” 石神问，那“P≠NP呢？自己想出答案和确认别人的答案是否正确，何者较容易？” 汤川学一脸懵逼……^_^ 石神说“你一定先自己解答，再听别人的答案” 为心爱之人掩饰一桩杀人案，不惜再犯下一桩命案——天底下真有这样痴情的人 流浪游民换上被调查对象（也就是死者，当然并非游民这个死者）也就和之前拿着肖像画询问车展人员，有关人士反映见过此人（穿着一样）但并非此人一语衔接的天衣无缝……佩服东野圭吾🙏 这个世上没有无用的齿轮，也只有齿轮自己才能决定自己的用途！只有高手间才能明白的对话…… 至此，乃智力和脑力的双重博弈🔛 汤川学的推理确实让常人难以想象，合情合理，于细微察之言，观之色！ 至此，考试（补考）期间和警察的对话起到了决定性的作用：看似几何问题，其实是函数问题。这句话石神把自己埋了（也唯有高手-物理学家-汤川学才能明白）看似不在场证明，核心其实在隐瞒死者身份。 东野的写作手法巧妙无比，人物、身份、介绍、地点等等恰如其分切入读者的心中……&amp; 两个天才的对决……脑海中，挥之不去…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git的简单使用命令备注]]></title>
      <url>%2F2017%2F01%2F04%2FGit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E6%B3%A8%2F</url>
      <content type="text"><![CDATA[Git是目前世界上最先进的分布式版本控制系统（没有之一）。 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ ……………………………………… 原文请戳廖雪峰老是的文章 Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！ 创建版本库$ mkdir learngit $ cd learngit $ pwd pwd命令用于显示当前目录。 通过git init命令把这个目录变成Git可以管理的仓库 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 原文请戳廖雪峰老师的文章 在提交代码到 git 仓库时候，需要时刻监控状态变化： 我的操作如下： 1、git status 主要检查那些文件作了修改 2、git add -A提交本地文件到本地仓库 3、git status检查提交状态 4、git commit -m &quot;说明最好见名之意&quot; 5、git pull origin master先拉一下其他人的代码 6、git push origin master提交代码到远程仓库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些图片收集]]></title>
      <url>%2F2017%2F01%2F02%2F%E4%B8%80%E4%BA%9B%E5%9B%BE%E7%89%87%E6%94%B6%E9%9B%86%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[覃彪喜收藏]]></title>
      <url>%2F2017%2F01%2F02%2F%E8%A6%83%E5%BD%AA%E5%96%9C%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[读大学，究竟读什么？大学生和非大学生最主要的区别绝对不在于是否掌握了一门专业技术⋯⋯一个经过独立思考而坚持错误观点比一个不假思索而接受正确观点的人更值得肯定⋯⋯草木可以在校园年复一年的生长，而我们注定要很快被另外一群人替代⋯⋯尽管每次网到鱼的不过是一个网眼，但要想捕到鱼，就必须要编织一张网⋯⋯ 人生规划：三岔路口的抉择不走弯路就是捷径⋯⋯仕途，商界，学术⋯⋯在这人生的三岔路口，你将何去何从⋯⋯与其跟一百个人去竞争五个职位，不如跟一个人去竞争一个职位⋯⋯学术精神天然的应当与尘嚣和喧哗保持足够的距离⋯⋯商场不忌讳任何神话。你也完全可能成为下一个传奇⋯⋯ 专业无冷热，学校无高低没有哪个用人单位会认为你代表了你的学校或者你的专业⋯⋯既然是概率，就不存在不止一种可能性⋯⋯如果是选择学术，冷门专业比热门专业更容易获得成就⋯⋯跨专业几乎早已成为一种流行一种时尚⋯⋯大学之间的实力之争到了考研考场和人才市场原来是那样的微不足道⋯⋯ 不可一业不专，不可只专一业千招会，不如一招熟⋯⋯十个百分之十并不是百分之百，而是零⋯⋯在这个现实的社会，真正实现个人价值才是最体面最有面子最有尊严的事情⋯⋯要想知道需要学习什么，最好的方式就是留意招聘信息⋯⋯很多专业因为不具备专长的有效性，所以成为了屠龙之术⋯⋯为什么不将“买一送一”的促销思维运用到求职应聘的过程中来呢⋯⋯ 不逃课的学生不是好学生什么课都不逃，跟什么课都逃掉没什么两样⋯⋯读大学，关键是学会思考问题的方法⋯⋯逃课没有错，但是不要逃错课⋯⋯英语角绝对不是学英语的地方⋯⋯为了英语丢了专业，那就舍本逐末了⋯⋯招聘单位是用人才的地方，而不是培养人才的地方⋯⋯既要逃课，又要让老师给高分⋯⋯ 勤工俭学的辩证法对于贫困生来说，首先要做的不是挣钱，而是省钱⋯⋯大部分女生将电脑当成了影碟机，大部分男生将电脑当成了游戏机⋯⋯在这个处女膜都可以随意伪造的时代，还有什么值得轻易相信⋯⋯态度决定一切⋯⋯将学习下降到次要的地位，大学生就只能说是兼职的学生了⋯⋯ 做事不如做人，人脉决定成败学问好不如做事好，做事好不如做人好⋯⋯会说话，就能减少奋斗三十年⋯⋯一个人有多少钱并不是指他拥有多少钱的所有权，而是指他拥有多少钱的使用权⋯⋯一个人赚的钱，12.5%是靠自身的知识，87.5%则来自人脉关系⋯⋯三十岁以前靠专业赚钱，三十岁以后拿人脉赚钱⋯⋯你和世界上的任何一个人之间只隔着四个人⋯⋯ 互联网：倚天剑与达摩克利斯之剑花两个小时就写出一篇天衣无缝的优秀毕业论文⋯⋯在互联网领域创业的技术门槛并不高，关键的是市场眼光和营销能力⋯⋯轻舞飞扬已经红颜薄命了，而痞子蔡却继续跟别的女孩发生着一次又一次的亲密接触⋯⋯很多大学生的网友遍布祖国大江南北，可他们却从未主动向周围的人说一声：你好，我们可以聊聊吗⋯⋯ 恋爱：花开堪折方须折爱情是不期而至的，可以期待，但不可以制造⋯⋯越是寂寞，越要警惕爱情⋯⋯既然单身是可耻的，那西门庆是不是应该被评为宋朝十大杰出青年⋯⋯花开堪折方须折，莫让鲜花败残枝⋯⋯一个有一万块钱的人为你花掉一百元，你只占了他的百分之一；而一个只有十块钱的人为你花掉十块，你就成了他的全部⋯⋯ 性：上帝死了，众神在堕落爱要说，爱要做⋯⋯我只有在肉体一下一下的撞击中才感到快乐。经过之后，将是更大的寂寞更大的空虚⋯⋯为何要让别人的虚荣成为对自己的伤害⋯⋯当她机械地躺在床上张开双腿，她的父母正在憧憬着女儿的未来⋯⋯一朝春尽红颜老，花落人亡两不知⋯⋯ 考研：痛苦的安乐死没有比浪费青春跟失败的事情了⋯⋯研究生扩招的速度是30%，也就意味着硕士学历贬值的速度是30%⋯⋯同样是付出三年的努力，你可以让E1的值增加1，也可以让E2的值增加2甚至增加3⋯⋯读完硕士或博士并不等于工作能力更强⋯⋯面对13.54万的成本，你还会毫不犹豫地投资读研究生吗⋯⋯努力就会有结果，但不一定是好结果⋯⋯ “海龟”变“海带”月薪2500元的工作，居然引得三个“海归”硕士争相竟聘⋯⋯对于某些专业而言，去美国留学和去埃塞俄比亚留学没什么两样⋯⋯既然全世界的公司都想到中国的市场上来瓜分蛋糕，为什么中国人还要一门心思到国外去留学然后给外国人打工⋯⋯ 非统招：养卑照样处优她在中国信息产业界创下了几项记录。她被称为中国的“打工皇后”。而她不过是一名自考大专生⋯⋯要想把曾经输掉的东西赢回来，就必须把自己比别人少付出的努力补上来⋯⋯非统招生不但要有一定的实力，而且必须掌握一定的技巧，做到扬长避短出奇制胜⋯⋯路在脚下，好走，走好⋯⋯ 毕业：十面埋伏的陷阱母校不把自己当母亲，你又何必把自己当儿女⋯⋯听辅导班不过是花钱买踏实⋯⋯人才市场就是一个地雷阵⋯⋯通过多种方式求职固然没有错，但是千万不要饥不择食⋯⋯只要用人单位一说要你交钱，你掉头就走便是了⋯⋯这年头立字据尚且不足以为据，更何况一个口头约定⋯⋯ 求职：做人不要太厚道求职简历必须突出自己的核心竞争力⋯⋯求职的时候大可不必像严守那样“有一说一”⋯⋯一个人说假话并不难，难得是把假话说到底，并且不漏一些破绽⋯⋯在填写自己的特长时，一定要尽可能详细⋯⋯一份求职简历只要用一张A4纸做个表格就足够了⋯⋯面试其实是有规律的，每次面试的时候只要被标准答案就行了⋯⋯ 骑一头能找千里马的驴美国铁路两条铁轨之间的标准距离是4英尺8.5英寸，为什么呢？因为两匹马臀部之间的宽度是4英尺8.5英寸⋯⋯垃圾是放错位置的人才⋯⋯世界上最大的悲剧莫过于有太多的年轻人从来没有发现自己真正想做什么⋯⋯中小企业或许能够让你得到更充分的锻炼⋯⋯从基层做起并不意味着可以从基层的每一个职位做起⋯⋯要“钱途”，更要前途⋯⋯ 写字楼政治：白领必修课大公司是做人，小公司是做事⋯⋯职员能否得到提升，很大程度不在于是否努力，而在于老板对你的赏识程度⋯⋯公司的事情和秘密永远比你想象的还要复杂和深奥⋯⋯在适当的时候装糊涂不但是必要的，而且是睿智的⋯⋯就把你的同事当成一群你可以叫得出名字的陌生人好了⋯⋯ 创业：29岁以前做富翁瘦死的骆驼比马大⋯⋯撑死胆大的，饿死胆小的⋯⋯不再是“大鱼吃小鱼”，而是“快鱼吃慢鱼”⋯⋯对于趋势的把握是一个创业者最重要的能力⋯⋯高科技行业留给毕业生的空间已经很小⋯⋯欲速则不达。在创业以前通过给别人打工而积累经验是非常必要的⋯市场永远比产品更重要⋯⋯钱不够花，怎么办？第一，看菜吃饭；第二，借鸡生蛋⋯⋯]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C概述（二）]]></title>
      <url>%2F2016%2F12%2F27%2FObjective-C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[先看一个坐标图： 浅析 objc_msgSend的作用​ 在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语说，这叫做”传递消息（亦或消息传递）”。消息有”名称”（name）或”选择子”（selector），可以接受参数，而且可能有返回值。 isMemberOfClass:用于判断对象是否为某个特定对象类的实例； isKindOfClass：用于判断对象是否为某类或者其派生类的实例。 Tips：Objective-C中，在比较两个对象是否相等时，经常使用 isEqual：方法。但是在 比较类对象是否相等时不能使用该方法，原因在于：类对象是单利（singleton），在应用程序范围内，每个类的 Class 仅有一个实例，也就是说，另外一种可以精确判断出对象是否为某类实例的办法是： 12345id object = /* …. */;if ([object class] == [SomeClass class])&#123; //&apos;object&apos; is an instance of SomeClass&#125; bitfield-位段、位域将方法响应能力缓存起来的最佳途径是使用”位段”(bitfield) 数据类型。（这是一项乏人问津的 C语言特性，在此处使用非常合适）我们可以把结构体中某个字段所占的二进制位个数设定为特定的值。比如： 1234567struct data&#123; unsigned int fieldA : 8; unsigned int fieldB : 4; unsigned int fieldC : 2; unsigned int fieldD : 1;&#125;;在结构体中，fieldA位段占用8个二进制位，fieldB位段占用4个二进制位，fieldC位段占用2个二进制位，fieldD位段占用1个二进制位。于是，fieldA可以表示0至255之间的值，而fieldD则可以表示0或1这两个值。我们可以像fieldD这样把委托对象是否实现了协议中的方法这一信息缓存起来。如果创建的结构体中只有大小为1的位段，那么就可以把许多值塞进这一小块数据里面了。 比如： 12345678910111213141516171819202122@interface SCNetworkFetcher()&#123; struct &#123; unsigned int didReceivedData : 1; unsigned int didReceivedWithError : 1; unsigned int didReceivedUpdateProgress : 1; &#125; _delegateFlags;&#125;@end //setFlags 和 setDelegate- (void)setDelegate:(id&lt;SCNetworkFetcher&gt;)delegate&#123; _delegate = delegate; _delegateFlags.didReceivedData = [delegate respondsToSelector:@selector(networkFetcher:didReceivedData:)]; /* ....... */&#125;//使用： if(_delegateFlags.didReceivedData)&#123; [_delegate networkFetcher:self didReceivedData:data];&#125;//总结：是否需要进行优化，则应按照具体的代码逻辑而定。首先需要分析代码性能，并找出瓶颈，若发现执行速度需要改进，则可使用此技巧。 不能使用retainCount的原因在于：它所返回的保留计数只是某个给定的时间点儿上的值。该方法并未考虑到系统会稍后把自动释放池清空，因而不会将后续的释放操作从返回值里减去，这样看来，此值就未必能真实的反映实际的保留计数了。这也就是为什么说这个方法无用的主要原因。 ARC在编译期和运行期的分别做了些什么？看下图： Grand Central Dispatch ——————GCD 块与大中枢派发1、块类型的语法结构如下：1return_type (^block_name) (parameters) 默认情况下，为块所捕获的外界变量，是不可以修改的，但是声明变量的时候使用__block 修饰符，是可以修改的。 如果通过读取或者写入操作捕获了实例变量，那么也会自动把 self 变量一并捕获了，因为实例变量与 self 所指代的实例关联在一起的。所以，要特别注意，在块内儿，访问实例变量，为避免循环引用，需在块外对 self 进行弱引用修饰 12&gt; __weak typeof(self) weakSelf = self;&gt; &gt; 块的内部结构 iOS - NSLinguisticTagger（自然语言） 自然语言筛选代码及注释: 123456789101112131415161718&gt; //1.创建语句&gt; NSString * question = @&quot;What is the weather in San Francisco?&quot;;&gt; //2.创建筛选条件&gt; NSLinguisticTaggerOptions options = NSLinguisticTaggerOmitWhitespace | NSLinguisticTaggerJoinNames |NSLinguisticTaggerOmitPunctuation;&gt; //3.创建自然语言标签&gt; NSLinguisticTagger * tagger = [[NSLinguisticTagger alloc]initWithTagSchemes:[NSLinguisticTagger availableTagSchemesForLanguage:@&quot;en&quot;] options:options];&gt; //4.给标签附字符串&gt; tagger.string = question;&gt; //5.执行筛选&gt; [tagger enumerateTagsInRange:NSMakeRange(0, question.length) scheme:NSLinguisticTagSchemeNameTypeOrLexicalClass options:options usingBlock:^(NSString * _Nonnull tag, NSRange tokenRange, NSRange sentenceRange, BOOL * _Nonnull stop) &#123;&gt;&gt; //6.获取结果&gt; NSString*token = [question substringWithRange:tokenRange];&gt;&gt; //7.打印结果&gt; NSLog(@&quot;%@:%@&quot;,token,tag);&gt; &#125;];&gt; 打印结果 12345678&gt; 2017-02-17 15:17:06.478 Demo[54116:2511652] What:Pronoun&gt; 2017-02-17 15:17:06.478 Demo[54116:2511652] is:Verb&gt; 2017-02-17 15:17:06.479 Demo[54116:2511652] the:Determiner&gt; 2017-02-17 15:17:06.480 Demo[54116:2511652] weather:Noun&gt; 2017-02-17 15:17:06.480 Demo[54116:2511652] in:Preposition&gt; 2017-02-17 15:17:06.482 Demo[54116:2511652] San Francisco:PlaceName&gt; (lldb) &gt; OC 经历了多年的发展和进化，遍历collection 的方式也经历了一系列的演变，如下： 1、For 循环遍历 2、使用 Objective-C 1.0 的 NSEnumerator 来遍历 3、快速遍历（For-in） 4、基于”块”的遍历方式 （PS：若能提前得知遍历的 collection 是何种对象，则应该修改块签名，指出对象的具体类型） ​ 总体来看， 块枚举法拥有上述遍历方式的所有优势，而且还有更多好处。与快速遍历方法相比，它要多用一些代码，可是却能提供遍历时所针对的下标，在遍历字典时也能同时提供键与值，而且还有选修可以开启并发迭代功能，所以多写点儿代码还是值得的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown开启编辑新模式]]></title>
      <url>%2F2016%2F12%2F24%2FMarkdown%E5%BC%80%E5%90%AF%E7%BC%96%E8%BE%91%E6%96%B0%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[iPic + Typora，方便快捷地在 Markdown 中插图 typora 图床神器 iPic]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac 下终端常用命令汇总]]></title>
      <url>%2F2016%2F12%2F19%2FMac-%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[（1）Git：默认OS X是安装git的，我们可以通过git命令查看（2）which git：查看git的安装路径。默认一般是/usr/bin/git.（3）curl http://npmjs.org/install.sh | sh ：安装Node.js的套件管理工具；（4）sudo npm update npm -g ：更新node.js的套件管理工具nmp；（5）nmp -v :查看nmp的版本；（6）cd ~/.ssh :检查本机的SSH密钥；（7）cd :进入某个文件目录；（8）ls -a :显示当前文件夹下的所有隐藏文件；（9）open :打开当前目录下的某个文件；（10）ssh -T git@github.com :检查Github的SSH是否设置成功；（11）git config –global user.name 用户名 ：修改git的用户名。因为Git会根据用户的名字和邮箱来记录提交。Github也是用这些信息来做权限的处理。（12）git config –global user.email 邮箱 ：修改git的邮箱。因为Git会根据用户的名字和邮箱来记录提交。Github也是用这些信息来做权限的处理。（13）open -t ~/.bash_profile ：打开Mac下环境变量配置；（14）ruby -e “$(curl -fsSkL https://raw.github.com/Homebrew/homebrew/Go/install)” ：安装os x下的包管理工具homebrew；（15）brew doctor :检查homebrew是否已经安装成功；（16）echo $PATH : 查看系统PATH环境变量；（17）ls ：列出当前目录下的所有文件名；（18）node -v :查看node.js的版本号；（19）nmp -v :查看nmp的版本号；（20）which node ：查看node.js的安装路径；（21）which nmp :查看nmp的安装路径；（22）git –version: 查看git的版本；（23）sudo npm install –unsafe-perm –verbose -g hexo ：用npm命令安装hexo；（24）sudo npm install -g hexo ：用npm命令安装hexo；可以与上面的比较着用；（25）tab键 :自动补全当前目录下的文件名；（26）pwd :显示当前目录；（27）cd ：进入root根目录；（28）cd .. :进入上级目录；（29）cat 文件名 ：在终端下查看文件；（30）vim 文件名：使用vim编辑某个文件；（31）进入vim先按字母i键：对vim执行插入操作，即可以编辑文件了；（32）:q :在vim中没有对文件做任何修改的情况下退出vim可以使用该命令；（33）先按ESC键，然后 :w :保存当前写入的内容，但不退出vim；（34）先按ESC键，然后 :wq :保存修改的内容，退出vim；w：write ； q: quit（35）hexo g :生成hexo静态网页，在你本地做修改后，首先要使用这个命令， g ＝ generate;（36）hexo d :部署静态网页，在执行hexo g之后执行hexo d, d = depoly;（37）git clone https://github.com/wuchong/jacman.git themes/jacman ：从Github下载Hexo的jacman主题，存放在themes目录下，注意执行git命令和执行hexo命令必须要在Hexo文件夹下，也就是要在根目录下；（38）git clone https://github.com/A-limon/pacman.git themes/pacman ：同上；（39）hexo serve ：在本地进行开启服务器进行hexo的调试；只要在浏览器中输入http://0.0.0.0:4000/即可进行调试；（40）Ctrl ＋ C：在上一个命令之后执行，停止hexo服务器的调试；（41）hexo clean :清除缓存，网页正常情况下可以忽视该命令；（42）hexo n “博客名称”= hexo new “博客名称” ：新建文章；（43）hexo g = hexo generate :生成；（44）hexo s = hexo serve :启动服务预览；（45）hexo d = hexo deploy :部署；（46）hexo generate –deploy :作用同 分别执行 hexo generate ; hexo deploy（47）hexo deploy –generate :同上hexo generate –deploy（48）:q! :强制退出vim，并放弃所有修改；（49）:e! :vim 中放弃所有修改，并打开原来的文件；（50）JDK环境变量配置： cd :进入根目录 vim .bash_profile :使用vim编辑环境变量export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_67.jdk/Contents/Home #版本号根据自己的具体情况而定export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar按ESC键进入命令模式:wq :保存退出source .bash_profile ：更新配置文件 （51）cd /Library/Java/JavaVirtualMachines ls :可以查看当前你安装的所有JDK的版本，因为JDK默认是安装在/Library/Java/JavaVirtualMachines 路径下的； （52）xcode-select –install :终端下安装Xcode Command line tools；（53）rm 文件名 ：删除某个文件；（54）git clone *github repository url :从服务器上将代码给拉下来，注意：你要把本地库放到哪里，就要在某个文件夹下进行这个操作；（55）git diff :差异比较；（56）git show :显示某次提交的信息；（57）git init ：初始化一个版本仓库，如果想把本地的某个文件夹作为本地仓库，就在该文件夹执行这个操作。作为git clone之前的第一个操作；（58）git remote -v :查看远程仓库，在你当前文件夹下执行该命令，就会显示你的远程仓库的url；（59）Ctrl + C :强制退出某个在终端中运行的进程或者服务；（60）curl -L https://get.rvm.io | bash -s stable :安装rvm，可以理解为Ruby的虚拟机，可以和JVM一起理解；（61）rvm -v :检查rvm是否成功安装以及版本；（62）rvm install 2.0.0 :使用rvm安装Ruby环境；这样Ruby ，Ruby Gems就安装完成了；（63）ruby -v :查看Ruby版本；（64）gem -v :查看gem版本；（65）gem sources -l :查看gem来源；（66）gem sources –remove https://rubygems.org///等有反应之后再敲入以下命令gem sources -a http://ruby.taobao.org/使用Ruby环境来安装cocoapods，由于上述网站被墙，所以需要修改镜像为淘宝的镜像； （67）sudo gem install cocoapods安装cocoapods.这是开发苹果应用的一个非常方便的包管理工具；（68）which -a gitMac下查看安装了 几个版本的git； （69）ls -a查看该文件目录下的所有文件，包括隐藏文件。 （70）推荐使用zsh+iTerm 2替换Mac自带的终端Terminal和bash。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac安装Homebrew]]></title>
      <url>%2F2016%2F12%2F19%2FMac%E5%AE%89%E8%A3%85Homebrew%2F</url>
      <content type="text"><![CDATA[Homebrew安装在 terminal 中复制以下命令，跟随指引，将完成 Hombrew 安装。 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 紧接着，我们需要做一件事让通过 Hombrew 安装的程序的启动链接 (在 /usr/local/bin中）可以直接运行，无需将完整路径写出。通过以下命令将 /usr/local/bin 添加至 $PATH 环境变量中: 1echo &apos;export PATH=&quot;/usr/local/bin:$PATH&quot;&apos; &gt;&gt; ~/.bash_profile Cmd+T 打开一个新的 terminal 标签页，运行以下命令，确保 brew 运行正常。1brew doctor 命令操作安装一个包,比如widget，可以简单的运行：1brew install widget 更新 Homebrew 在服务器端上的包目录：1brew update 查看你的包是否需要更新：1brew outdated 更新包：1brew upgrade &lt;&quot;包名&quot;&gt; Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：1brew cleanup 查看你安装过的包列表（包括版本号）：1brew list --versions Homebrew CaskHomebrew Cask可以优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox。 安装运行以下命令即可完成：12brew tap caskroom/cask // 添加 Github 上的 caskroom/cask 库brew install brew-cask // 安装 brew-cask 搜索1brew cask search 下载文件预览插件有些 插件 可以让 Mac 上的文件预览更有效，比如语法高亮、markdown 渲染、json 预览等等。比如以下：12345678brew cask install qlcolorcodebrew cask install qlstephenbrew cask install qlmarkdownbrew cask install quicklook-jsonbrew cask install qlprettypatchbrew cask install quicklook-csvbrew cask install betterzipqlbrew cask install webp-quicklook 一些推荐安装的程序1234567brew cask install alfredbrew cask install appcleanerbrew cask install cheatsheetbrew cask install dropboxbrew cask install google-chromebrew cask install sublime-textbrew cask install cheatsheet Homebrew 还能做什么1234567brew cask uninstall 软件名 卸载通过 Homebrew Cask 安装的软件brew cask search 列出所有可以被安装的软件，当然你也可以直接前往上文提供的 Homebrew Cask 搜索。brew cask search google 这里是查找所有与 google 有关的软件，google 关键词可以自行替换brew cask info 软件名 查找相关软件的信息brew cask cleanup 删除 Homebrew Cask 下载的包brew cask list 列出通过 Homebrew Cask 安装的包brew cask update 更新 Homebrew Cask Homebrew Cask传送门 至此，Homebrew Cask 的简单使用方法就介绍完了。😜]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC中CGGeometry几何类常用方法整理]]></title>
      <url>%2F2016%2F12%2F15%2FOC%E4%B8%ADCGGeometry%E5%87%A0%E4%BD%95%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[CGGeometry参考定义几何结构和功能,操作简单。数据结构中的一个点CGPoint代表在一个二维坐标系统。数据结构的位置和尺寸CGRect代表的一个长方形。数据结构的尺寸CGSize代表宽度和高度。 创建一个几何原始数值123CGPoint CGPointMake（CGPoint A,CGPoint B）//返回一个指定坐标点 CGRect CGRectMake（CGFloat x,CGFloat y,CGFloat width,CGFloat height）//根据指定的坐标和大小创建一个矩形CGSize CGSizeMake（CGFloat width,CGFloat height）//根据指定长宽创建一个CGSize 修改矩形1234567CGRectDivideCGRect CGRectInset（CGRect rect,CGFloat dx,CGFloat dy）//返回一个比原矩形大或小的矩形，但是中心点是相同的CGRect CGRectIntegral（CGRect A）//将矩形A的值转变成整数，得到一个最小的矩形，CGRect CGRectIntersection:（CGRect A，CGRect B）//获取两个矩形相交处所的矩形，没有相交返回NULL，用CGRectIsNull来检测CGRectOffsetCGRectStandardizeCGRectUnion 比较数值1234bool CGPointEqualToPoint(CGPoint A,CGPoint B) //返回两个点是否相等bool CGSizeEqualToSize(CGSize A，CGSize B) //CGSizeAB是否相等bool CGRectEqualToRect(CGRect A，CGRect B) //矩形AB的位置大小是否相等bool CGRectIntersectsRect(CGRect A，CGRect B) //矩形AB是否相交，可用来判断精灵是否离开了屏幕 检查12bool CGRectContainsPoint（CGRect A, CGPoint B）//检测矩形A是否包含指定的点Bbool CGRectContainsRect（CGRect A，CGRect B）//检测矩形A是否包含矩形B 获取最大值、中等职和最小值123456CGFloat CGRectGetMinX（CGRect A） //获取矩形x坐标的最小值CGFloat CGRectGetMinY（CGRect A) //获取矩形y坐标的最小值 CGFloat CGRectGetMidX（CGRect A） //获取矩形x坐标的中间值 CGFloat CGRectGetMidY（CGRect A） //获取矩形y坐标的中间值 CGFloat CGRectGetMaxX（CGRect A） //获取矩形x坐标的最大值 CGFloat CGRectGetMaxY（CGRect A） //获取矩形y坐标的最大值 获取高和宽12CGFloat CGRectGetHeight（CGRect A）//获取矩形A的高CGFloat CGRectGetWidth（CGRect A） //获取矩形A的宽 检测矩形是否存在或是无穷大123bool CGRectIsEmpty(CGRect A) //矩形A是否长和宽都是0，或者是个NULLbool CGRectIsNull(CGRect A) //矩形A是否为NULLbool CGRectIsInfinite(CGRect A) //矩形A是否无穷大，没有边界]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[插件篇]]></title>
      <url>%2F2016%2F12%2F09%2F%E6%8F%92%E4%BB%B6%E7%AF%87%2F</url>
      <content type="text"><![CDATA[FVD Downloader for Chrome 插件下载视频的插件，点它下载心仪的视频和音乐 百度网盘文件下载助手 for Chrome浏览器Aria2GUI：绕过百度网盘满速下载 Adblock Plus 畅游清爽洁净的网际防止追踪、恶意域名，过滤横幅广告、弹窗广告以及视频广告。用以支持网站的非侵入式广告将不会被屏蔽（可配置）完全免费！ Pocket 稍后阅读发现想在以后查看的内容时，先将其放入 Pocket。 safari-json-formatterA Safari extension which makes valid JSON documents human-readable.Download the extension and open it with Safari 5. Adblock Super谷歌浏览器中流行的广告屏蔽插件Adblock Super这款Chrome广告屏蔽插件可以有着比Adblock更加强大的屏蔽功能，它可以屏蔽几乎所有的社交网站和普通网站上的各种广告，用户只需要在Chrome浏览器中安装并简单地配置Adblock Super的屏蔽功能即可。【只是总是自动被 Chrome 屏蔽】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[西原，西原]]></title>
      <url>%2F2016%2F12%2F06%2F%E8%A5%BF%E5%8E%9F%EF%BC%8C%E8%A5%BF%E5%8E%9F%2F</url>
      <content type="text"><![CDATA[她是朵含苞带露的格桑花，一遇见他就绽开了，一生只为他陈渠珍一个人开。 羌塘路茫茫，无给养无得力的向导，一路上极尽苦寒，断粮长达七个月。部众接二连三饥寒暴毙，几乎每天都有人永远地仰倒在雪原上，赤面朝天，连一席裹尸的草席都没有。荒原之上，好像没什么比找死更容易的事情了。 她不是他的袍泽弟兄，不是他的属下，她只知道她是他的女人。她并不觉得自己是在付出或奉献，只把这些，当成自己应尽的本分。彼时的西原，不过是不到二十岁的一个小嫁娘。 日复一日，她对他的爱几乎浓缩成一种信仰，一种可以舍生忘死放弃一切的信仰。她是他的爱人、母亲和护法绿度母，他要走羌塘，她万里相随，她本藏女，不会不知前路意味着怎样的生死……就算有万分之一的机会安抵汉地，今生她也几乎无缘再度重返西藏。她需要为他放弃父母、语言以及故乡。她没有什么犹豫，甚至没有询问他什么，只是绷紧了弦，死地羌塘舍命相保。她只知道她是他的女人。 她自己少吃或者不吃，省下口粮给他吃，还假装自己已经吃过。她逼他吃最后一块干肉的时候说：“……可以没有我，不可以没有你。” 她用人性中最朴素纯洁的一切深爱着他，爱得就像始祖的先民一样笨拙，她以一个女人所有的一切爱着她唯一的男人……没有人比她更配得起“爱人”这个词汇。 情之所至，缘订三生，相依为命到绝境时，他们俩订下三世盟约：六道轮回中，愿永为夫妻。 情之所至，或许感动了雪域护法，艽野中的神袛网开一面，没有收走他们的命。西原悬起一口真气，终于护送陈渠珍安抵汉地。 整整七个月，梦魇一样的艽野，终于走出来了。从出发时的百二十人，死到最后只剩六七个人。彼时已是1912年的初夏。 西原一到了汉地就没了。用尽最后一丝心力的西原灯油耗干，逝去在西安城。 临终前，她遗言道：“西原万里从君，一直形影相随，不想竟然病入膏肓，不得不与君中道而别……愿君南归途中，一路珍重，西原已不能随行了。” 一切都随风逝去了，荣耀和前途，信念和希望，以及爱人。陈渠珍立在西风里，茕茕孑立。这哪里仅仅是落魄，分明是一颗心被生生剜走。人生的大悲凉，莫如斯。…… 西原，西原，你是否会涅槃在时代更迭的夹缝中，反反复复不停涅槃。时时常示人，世人常不识。 原文请戳————大冰的《西原,西原》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[菩提本无树]]></title>
      <url>%2F2016%2F12%2F05%2F%E8%8F%A9%E6%8F%90%E6%9C%AC%E6%97%A0%E6%A0%91%2F</url>
      <content type="text"><![CDATA[菩提本无树，明镜亦非台。本来无一物，何处惹尘埃。 这个是六祖慧能大师的一个四句偈 佛对我说：你的心上有尘。我用力地擦拭。佛说：你错了，尘是擦不掉的。我于是将心剥了下来.佛又说：你又错了，尘本非尘，何来有尘我领悟不透，是什么意思？我想这是从神秀和慧能那两个偈子引申出来。 神秀说：“身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃。”慧能说：“菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。” 的确，要能够参透这两个偈子的确很难，就是正确的理解也不易。参悟不透…身是菩提树，心如明镜台，时时勤拂拭，勿使惹尘埃众生的身体就是一棵觉悟的智慧树，众生的心灵就象一座明亮的台镜。要时时不断地将它掸拂擦试，不让它被尘垢污染障蔽了光明的本性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[河南啊河南]]></title>
      <url>%2F2016%2F12%2F05%2F%E6%B2%B3%E5%8D%97%E5%95%8A%E6%B2%B3%E5%8D%97%2F</url>
      <content type="text"><![CDATA[中国科技大学为什么没有落户河南？ 今天看到以下文章，不知道是否说的全面。 1969年，有意迁往河南的中国科技大学遭遇河南当局的冷淡，时为安徽省革委会主任的李德生（河南省信阳市新县人，曾任党中央副主席和军委副主席）却主动要去了这所名校。历史很有讽刺性，李德生的故乡就是河南。从此后，中科大成为安徽的骄傲和机会，河南则因此而后悔、痛楚，经年不绝。 一 1969年，中苏边境冲突。根据形势，中央决定进行“战备疏散”，中国科技大学被国务院科教组列入北京十三所下迁高校之中。据时为中科大革委会常委之一的蔡有智教授回忆，“九月下旬，分两组去湖北沙市和河南寻找疏散地址。沙市有科学院的干校，河南组带有国务院科教组组长刘西尧给河南省的亲笔信。预计去这两地选址会容易些，我是去河南组的成员，因为带有刘西尧同志的亲笔信，我们受到了省生产指挥组组长的接待，他让我们去南阳地区看看，在谈话中我们意识到他们对科大来河南不大积极。我们在南阳周边和邓县看了不少地方，地区的同志说：土地有的是，三千亩五千亩没问题，但我们南阳没有接收一所大学的能力。 两组选址人员回到北京，都表示这两地没有条件，不能去。接着又派两组，一组去江西，一组去安徽。我是去江西组的成员，到江西省后，省里明确表示不能接收科大。安徽选址的同志在宣城地区看了以后也觉得不行。在这两组人员还没回到北京时就接到了定点安徽省安庆市的通知。”其间，是安徽的领导人李德生迅速行动，把中科大争取到了安庆。由于安庆条件太差，中科大不愿去，李德生又腾出合肥师范学院和银行干校的校舍，来安置中科大。 另据中国科技大学校史记载，学校南迁原定在河南南阳，后改为安徽安庆。从刘西尧专函河南也可以看出，中国科技大学是想建在河南的。河南之所以拒绝中科大最权威的说法是怕大学师生挤占河南的副食口粮。 当南阳籍的建筑大师杨廷宝在主持规划中科大合肥校园时，我想，他一定别有一番滋味在心头。 后来，中科大多次想迁回北京，毕竟它要依托中科院办学，但安徽省一直极力挽留，就没有走成。安徽省还争取到了下放的中科院研究所，一跃而为科教名城。安徽现有国家同步辐射实验室、微尺度物质科学国家实验室两个国家大科学工程。而河南连更低级别的国家重点实验室都没有。 无独有偶，中国地质大学曾要落户河南平顶山，也被河南错失。 二 河南错失中国科技大学的后悔只在表层、显意识里。河南的小农思维是在骨子里，不自觉的，不那么容易改掉。 在错失中科大十年后的改革开放之初，举国凋敝，各省高教实力差距不大。但随后的河南既没有争到国家投入，也没有自己大力建设，被兄弟省份远远甩下。小省山西现有八个学校可以培养博士，黑龙江有十一个，而大省河南只有五个。我们真的重视教育了吗？ 当中科大在大力扩张建设新校区时，河南大学的2000亩老校园则被挤兑的只剩下八百亩，而人数却涨了好几倍。我们在精神上有境界吗？ 2000年，河南提出加快发展河南大学，坚决破除小农意识，却只给三校合并的新河大拨地1800亩建设新校区。以至于教育部长陈至立都说，这能容纳下几万人吗？以至于现在要跨过大马路再建新新校区。而同期的山东临沂师范学院新校区征地一万亩，人家要为一千万临沂儿女圆大学梦。我们在视野上有眼光吗？ 湖南师范大学整合医专、省人民医院、解放军医院，建设医科。南华大学整合中央科研院所，山东科技大学跨市合并，迅速做大。陕西科技大学、西南石油学院将新校区建在省会，异地办学，摆脱地理局限。这才是解放思想、不拘一格。反观自身，我们在思维上有创新吗？ 节选评论还有一所中国矿业大学也是河南不要啊， 三所“中字头”的大学在任何一个省都是稀缺资源， 河南省就轻易地拒绝了。 现在所谓的高教大省湖北，也只有一所中字头大学， 就是当年河南不要的中国地质大学。 更让人感到绝情的是， 中国矿业大学的前身就是1909年成立的焦作路矿学堂，想搬回家的游子河南也不要。 有道是：前人种树后人乘凉。 在河南，却是前人砍树后人骂娘。 文章转自&amp;天涯社区合肥晚报市场星报知乎爆料搜狐新闻更多文摘请点击]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[系统原生请求表单上传]]></title>
      <url>%2F2016%2F12%2F02%2F%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E8%AF%B7%E6%B1%82%E8%A1%A8%E5%8D%95%E4%B8%8A%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[创建NSMutableURLRequest请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768- (void)setRequest:(NSMutableURLRequest *)request&#123; NSString *boundary = [NSString stringWithFormat:@&quot;Boundary+%08X%08X&quot;, arc4random(), arc4random()]; NSMutableData *body = [NSMutableData data]; // 表单数据 NSMutableDictionary *param = [[NSMutableDictionary alloc] init];// [param setValue:@&quot;254&quot; forKey:@&quot;empId&quot;];// [param setValue:@&quot;18718&quot; forKey:@&quot;shopId&quot;]; /** 遍历字典将字典中的键值对转换成请求格式: --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;empId&quot; 254 --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;shopId&quot; 18718 */ [param enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSMutableString *fieldStr = [NSMutableString string]; [fieldStr appendString:[NSString stringWithFormat:@&quot;--%@\r\n&quot;, boundary]]; [fieldStr appendString:[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;\r\n\r\n&quot;, key]]; [fieldStr appendString:[NSString stringWithFormat:@&quot;%@&quot;, obj]]; [body appendData:[fieldStr dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:[@&quot;\r\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; &#125;]; /// 图片数据部分 NSMutableString *topStr = [NSMutableString string]; NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;001.jpeg&quot; ofType:nil]; NSData *data = [NSData dataWithContentsOfFile:path]; /**拼装成格式： --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=&quot;uploadFile&quot;; filename=&quot;001.png&quot; Content-Type:image/png Content-Transfer-Encoding: binary ... contents of boris.png ... */ [topStr appendString:[NSString stringWithFormat:@&quot;--%@\r\n&quot;, boundary]]; [topStr appendString:@&quot;Content-Disposition: form-data; name=\&quot;file\&quot;; filename=\&quot;001.png\&quot;\r\n&quot;];//⚠️注意：此处的『name=\&quot;file\&quot;』这个 file 就是你后端服务器定义的文件流的字段，特此提醒 [topStr appendString:@&quot;Content-Type:image/jpg\r\n&quot;]; [topStr appendString:@&quot;Content-Transfer-Encoding: binary\r\n\r\n&quot;]; [body appendData:[topStr dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:data]; [body appendData:[@&quot;\r\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; // 结束部分 NSString *bottomStr = [NSString stringWithFormat:@&quot;--%@--&quot;, boundary]; /**拼装成格式： --Boundary+72D4CD655314C423-- */ [body appendData:[bottomStr dataUsingEncoding:NSUTF8StringEncoding]]; // 设置请求类型为post请求 request.HTTPMethod = @&quot;post&quot;; // 设置request的请求体 request.HTTPBody = body; // 设置头部数据，标明上传数据总大小，用于服务器接收校验 [request setValue:[NSString stringWithFormat:@&quot;%lu&quot;, (unsigned long)body.length] forHTTPHeaderField:@&quot;Content-Length&quot;]; // 设置头部数据，指定了http post请求的编码方式为multipart/form-data（上传文件必须用这个）。 [request setValue:[NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,boundary] forHTTPHeaderField:@&quot;Content-Type&quot;];&#125; 上传文件流12345678910111213141516- (void)upload&#123; //uploadModule - 1 im 2 app 3 other //TODO:需要修改 NSString *urlStr = [NSString stringWithFormat:@&quot;http://qp.lianxi.com/file/upload?apiCode=%@&amp;uploadType=1&amp;uploadModule=2&amp;originalFlag=1&quot;,_share_apiCode]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlStr] cachePolicy:0 timeoutInterval:30.0f]; [self setRequest:request]; NSLog(@&quot;开始上传...&quot;); [NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc] init] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; //这里就是服务器返回的图片地址 NSLog(@&quot;Result--%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); &#125;];&#125; 参考文章原文地址 我的我的简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C概述]]></title>
      <url>%2F2016%2F11%2F30%2FObjective-C%E6%A6%82%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[Objective-C的起源 Objective-C与C++、Java、C#等面向对象的语言类似，不过很多方面有所差别。若是使用过一种面向对的开发语言，那么就能理解Objective-C所用的『范式和模板』了。然而，语法上会略显陌生，因为Objective-C使用的”消息结构”而非”函数调用”。Objective-C是由Smalltalk演化而来，后者是消息型语言的鼻祖。他们之间的调用看起来就是这样： 1234567//Messaging （Objective-C）Object *obj = [Object new];[obj performWith:parameter1 and:parameter2];//Function calling (C++)Object *obj = [Object new];obj-&gt;perform(parameter1,parameter2); 关键的区别在于：使用消息结构的语言，其运行时所执行的代码是由运行时环境决定的；而使用函数调用的语言，则由编译器决定。如果上例代码中调用的函数是多态的，那么在运行时就要按照&quot;虚方法表&quot;(virture method table)来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。 Notes：virture method table是编程语言为实现&quot;动态派发&quot;（dynamic dispatch）或 &quot;运行时方法绑定&quot;（runtime method binding） 而采用的一种机制。 “对象”(object)的内存在堆(heap space)上;“指针”(pointer)的内存在栈（stack）上。 在类的头文件中尽量少引入其他头文件可以使用@class 关键字&quot;向前声明&quot;（forward declaring） 该类。引入过多的并不需要的头文件，会增加编译时间，还会导致循环引用。使用『向前声明』可以解决互相引用的问题，减少编译时间，而且还能降低彼此的依赖程度（即我们经常说的降低耦合性） 多用字面量语法（literal syntax），少用与之等价的方法字面数值1234&lt;!-- 字面数值 --&gt;NSNumber *someNumber = [NSNumber numberWithInt:1];等价于NSNumber *someNumber = @1; 字面量语法更加精简。能够以 NSNumber 实例表示的所有数据类型都可以使用这种表示方式。 字面数组123456789&lt;!-- 字面量数组 --&gt; NSArray *array = [NSArray arrayWithObjects:@&quot;Hello&quot;,@&quot;World&quot;,nil]; 等价于 NSArray *array = [@&quot;Hello&quot;,@&quot;World&quot;]; 对应的使用方法：(取下标操作subscripting) NSString *animal = [array objectAtIndex:0]; 等价于 NSString *animal = array[0]; 字面字典“字典”是一种映射型数据结构，可向其中添加键值对。123456789&lt;!-- 字面量字典 --&gt; NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Hello&quot;:@&quot;H&quot;,@&quot;World&quot;:@&quot;W&quot;,[NSNumber numberWithInt:28]:@&quot;A&quot;,nil]; 等价于 NSDictionary *dictionary = @&#123;@&quot;H&quot;:@&quot;Hello&quot;,@&quot;W&quot;:@&quot;World&quot;,@&quot;A&quot;:@28&#125;; 对应的使用方法： NSString *animal = [dictionary valueForKey:@&quot;H&quot;]; 等价于 NSString *animal = dictionary[@&quot;H&quot;]; 使用字面量语法的局限性： 1、除了字符串以外，创建出来的对象必须是 Foundation 框架下的才行。 2、定义了这些可行的子类话，则无法继续使用字面量语法创建对象。 3、使用字面量创建出来的字符串、数组、字典对象都是不可变的（immutable），若要可变，需要调用 mutableCopy。比如：NSMutableDictionary *mutable = [@{@&quot;H&quot;:@&quot;Hello&quot;,@&quot;W&quot;:@&quot;World&quot;,@&quot;A&quot;:@28} mutableCopy] 使用字面量语法的好处： 1、可以缩减代码的长度 使其更加易读 2、使用字面量语法更加安全 3、字面量语法实际上只是一种[&quot;语法糖&quot;syntactic sugar](http://zh.wikipedia.org/wiki/语法糖) 4、使用字面量语法创建数组或字典时，值中不能有 nil 对象，否则抛出异常。其实这样，更便于查错。纠错。 多用类型常量，少用『#define』 预处理指令12345678#define ANIMATION_DURATION 0.3 //没有类型信息与static const NSTimeInterval KAnimationDuration = 0.3; //包含类型信息//变量名已定要同时使用 const 和 static 来声明。//其实这些都是一些命名规范，后边细述。 有时候需要公开某个常量。比如，你可能会给代码块中某个 Event 发送通知（NSNotification）。派发通知时需要使用字符串来表示此项通知的名称，而这个名字就可以为一个外界可见的常值变量（constant variable）。这样的话，注册者无需知道实际字符串的值，只需要以常值变量来注册自己想要接收到的通知即可。此类常量需放在&quot;全局符号表&quot;（global symbol table）中，以便可以再定义该常量的编译单元之外使用。和上边的 static const 有所不同： 1234567//In the header fileextern NSString *const SCStringRefreshNotification; //常量指针//In the implementation fileNSString *const SCStringRefreshNotification = @&quot;SCStringRefreshNotification&quot;;//点 h 文件声明，点 m 文件定义 总之，不要使用预处理指令定义常量。这样定义出来的常量不仅不包含类型信息，而且有人修改了（或重新定义了）这个常量值编译器也不会产生警告⚠️信息。​在实现文件使用 static const 来定义”只在编译单元内可见的变量”(translation-unit-specific constant)。这类常量不会出现在全局符号表中，所以无需为其名称加前缀。 在头文件使用 extern 来声明全局常量，并在实现文件中定义其值。这类常量会出现在全局符号表中，所以通常用与之相关的类名做前缀。 用枚举表示状态、选项、状态吗一个字节含8个二进制位，所以至多能表示可取256种（2^8个）枚举（编号为0~255）的枚举变量。 我们总习惯在 switch 语句中加上 default 分支。然而，若是用枚举来定义状态机（state machine），最好不要有 default 分支。这样的话，如果稍后新加上一个枚举状态，那么编译器会发出警告信息，提示新加入的状态并未在 switch 分支中处理。假如写上了 default 分支，那么他就会处理这个新状态，从而导致编译器不发警告信息。用 NS_ENUM 定义其他枚举类型时候也要注意此问题。 1、应该使用枚举来表示状态机的状态，传递给方法的选项以及状态码等值，给这些起个易懂的名字。2、如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。3、用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样的做就可以确保枚举是开发者所选择的底层数据类型实现出来，而不是采用编译器所选用的类型。4、在处理枚举类型的 switch 语句中不要实现 default 分支。 对象、消息、运行期 用 Objective-C 等面向对象语言编程时，对象（object）就是”基本构造单元”(building block),开发者可以通过对象存储并传递数据。 在对象之间传递数据并执行任务的过程就叫做”消息传递”(Messaging)。 Notes： 如果你熟悉了『对象』和『消息传递』这两个特性的工作原理，就可以写出高效且易维护的代码。 当 App 运行起来后，为其提供相关支持的代码叫做”Objective-C运行期环境”（Objective-C runtime）.runtime提供了一些是的对象之间能够传递消息的重要函数。 熟悉几个术语：存取方法（access method）、点语法（dot syntax）、编译器（compile time）、偏移量（offset）、硬编码（hardcode）、不兼容对象（incompatibility）、特殊变量（special variable）、类对象（class object）、应用程序二进制接口（Application Binary Interface，ABI）、稳固的（nonfragile） 在对象接口的定义中，可以使用属性，这是一种标准的写法，能够访问封装在对象的数据。因此，也可以把属性当做一种简称，其意思就是说：编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 使用点语法和直接调用存取方法之间没有丝毫差别。 123456789SCPerson *person= [SCPerson new];person.firstName = @&quot;CYH&quot;;Same As:[person setFirstName:@&quot;CYH&quot;];NSString *name = person.firstName;Same As:NSString *name = [person firstName]; 属性拥有的特质分为四类： 原子性： 在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性（atomicity）。如果属性具备 nonatomic特质，则不使用同步锁。请注意，如果某属性不具备 nonatomic特质那它就是原子的 atomic。 读/写权限： 1、具备 readwrite 特质的属性拥有 getter 和 setter 方法。 2、具备 readonly 特质属性只有 getter 方法。 内存管理语义： 属性用于封装数据，而数据必须要有”具体的所有权语义”（concrete ownership semantic）。 assign: setter 方法只会执行针对”纯量类型”（scalar type,e.g:CGFloat和 NSInteger）的简单赋值操作 strong: 定义了一种拥有关系（ownership relationship）。为这种属性设置新值时，setter 方法会先保留新值，并释放旧值，然后再将新值设置上去。 weak: 定义了一种非拥有关系（nonowning relationship）。为这种属性设置新值时，setter 方法既不保留新值，也不释放旧值。此特质同 assign 类似，然而在属性特指的对象遭到摧毁时，属性值会清空（nil out） unsafe_unretained: 此特质的语义和 assign 相同，但是它适用于对象类型（object type），该特质表达一种非拥有关系（不保留，unretained），当目标对象遭到摧毁时，属性值不会清空（不安全，unsafe），这一点与 weak 有区别。 copy: 此特质所述的关系和 strong 类似，然而设置方法并不保留新值，而是将其复制 （copy）。当熟悉类型是 NSString* 时候，经常用此特质来保护其封装性。因为传递给 setter 方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可以修改其值的字符串，此时若不拷贝字符串，那么设置完属性之后，字符串的值可能会在对象不知情的情况下遭人更改。所以，就要拷贝一份不可变的字符串，确保对象中的字符串不会无意简变动。只要实现属性所用的对象是可变的，就应该在设置新属性值时拷贝一份。 方法名：可以通过 getter= 和 setter= 指定存取方法的方法名 注释：不应该在 init （或 dealloc） 方法中调用存取方法。 在对象内部尽量直接访问实例变量1、在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写2、在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据3、有时会使用惰性初始化技术配置某分数据，这种情况下，需要通过属性来读取数据。 理解”对象等同性”这一概念 根据”等同性”(equality)来比较对象是一个非常有用的功能。不过，按照==操作符比较出来的结果未必是我们想要的，因为该操作比较的是两个指针本身，而不是其所指的对象。应该使用NSObject协议中声明的”isEqual:”方法来判断两个对象的等同性。一般来说，两个类型不同的对象总是不相等的(unequal)。某些对象提供了特殊的”等同性判定方法”(equality-checking method),如果已经知道两个受测对象都属干同一个类，那么就可以使用这种方法。以下述代码为例： 123456NSString *foo = @&quot;Badge:23&quot;; NSString *bar = [NSString stringWithFormat: @&quot;Badge:%i&quot;, 123]; BOOL equalA = (foo == bar); //&lt; equalA = NO BOOL equalB = [foo isEqual:bar]; //&lt; equalB = YES BOOL equalC = [foo isEqualToString:bar]; //&lt; equalC = YES 大家可以看到==与等同性判断方法之间的差别。NSString类实现了一个自己独有的同性判断方法，名叫” isEqualToString:”。传递给该方法的对象必须是NSString， 否则结果未定义(undefined).调用该方法比调用”isEqual:”方法快，后者还要执行额外的步骤，因为他不知道受测对象的类型。 NSObject协议中有两个用于判断等同性的关键方法：12- (BOOL)isEqual:(id)object; - (NSUInteger)hash; NSObject类对这两个方法的默认实现是：当且仅当其”指针值” (pointer value)完全相等时，这两个对象才相等。若想在自定义的对象中正确覆写这些方法，就必须先理解其约定(contract)。 如果 “ isEqual:” 方法判定两个对象相等，那么其hash方法也必须返回同一个值。但是，如果两个对象的hash方法返回同一个值，那么”isEqual:”方法未必会认为两者相等。比如有下面这个类：12345@interface SCPerson : NSObject @property (nonatomic, copy) NSString *firstName; @property (nonatomic, copy) NSString *lastName; @property (nonatomic, assign) NSUInteger age; @ end 我们认为，如果两个SCPerson的所有字段均相等，那么这西个对象就相等。于是isEqual:”方法可以写成：123456789101112- (Bool） isEqual: (id) object &#123;//指针类型的比较if (self == object) return YES; if ([self class] != [object class]) return NO;//对象类型的比较SCPerson *otherPerson = (SCPerson*)object; if (![ firstName isEqualToString:otherPerson.firstName]) return NO; if (![_lastName isEqualToString:otherPerson.lastName]) return NO; if (_age != otherPerson.age) return NO; return YES; &#125; 首先，直接判断两个指针是否相等。若相等，则其均指向同一对象，所以受测的对象也必定相等。接下来，比较西对象所属的类。若不属于同一个类，则两对象不相等。SCPerson对象当然不可能与SCDog对象相等。不过，有时我们可能认为：一个SCPerson实例可以与其子类（比如SCFanBingBingPerson)实例相等。在继承体系（inheritance hierarchy)中判断等同性时，经常遭遇此类问题。所以实现” isEqual:”方法时要考虑到这种情况.最后，检测每个属性是否相等。只要其中有不相等的属性，就判定两对象不等，否则两对象相等。 Hash 方法，根据等同性约定：若两对象相等，则其哈希码也相等，但是两个哈希码相同的对象却未必相等。这也是能否正确重写”isEqual:”方法的关键所在。编写 hash 方法时，应该用当前对象做做实验，以便在减少碰撞频度与降低运算复杂程度之间取舍。 特定类具有特定的等同性判定方法：123NSString isEqualToString:NSArray isEqualToArray:NSDictionary isEqualToDictionary: 常用的还有NSURL类的对比方法：1234567891011121314151617181920212223- (BOOL)isEqualToURL:(NSURL *)aURL &#123; if ([self isEqual:aURL]) return YES; if ([[self scheme] caseInsensitiveCompare:[aURL scheme]] != NSOrderedSame) return NO; if ([[self host] caseInsensitiveCompare:[aURL host]] != NSOrderedSame) return NO; // NSURL path is smart about trimming trailing slashes // note case-sensitivty here if ([[self path] compare:[aURL path]] != NSOrderedSame) return NO; // at this point, we&apos;ve established that the urls are equivalent according to the rfc // insofar as scheme, host, and paths match // according to rfc2616, port&apos;s can weakly match if one is missing and the // other is default for the scheme, but for now, let&apos;s insist on an explicit match if ([[self port] compare:[aURL port]] != NSOrderedSame) return NO; if ([[self query] compare:[aURL query]] != NSOrderedSame) return NO; // for things like user/pw, fragment, etc., seems sensible to be // permissive about these. (plus, I&apos;m tired :-)) return YES; &#125; 警告⚠️:由于 Objective-C在编译期不做强类型检查（strong type checking）,这样容易不小心传入类型错误的对象，因此开发者应该保证所传对象的类型是正确的。 在编写判定方法时，应该一并 override “isEqual:”方法，目的是：如果受测类型的参数与接收该消息的对象属于同一个类，那么就调用自己写的判定方法，否则就交给超类判断。 创建等同性判定方法时，需要决定是根据整个对象来判定等同性，还是仅根据其中几个字段来判断。 用一个 NSMutableSet 与几个 NSMutableArray 对象测试一下：123456先把一个数组加入set中： NSMutableSet *set = [NSMutableSet new]; NSMutableArray *arrayA = [@[@1, @2] mutableCopy]; [set addObject:arrayA]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2))&#125; 现在set里含有一个数组对象，数组中包含两个对象。再向set中加入一个数组，此数结与前一个数组所含的对象相同，顺序也相同，于是，待加入的数组与set中已有的数组是相等的：1234NSMutableArray *arrayB = [@[@1, @2] mutableCopy]; [set addObject:arrayB];NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1,2))&#125; 此时set里仍然只有一个对象：因为刚才要加人的那个数组对象和set中已有的数组对象相等，所以set并不会改变。这次我们来添加一个和set中已有对象不同的数组：12345678910111213NSMutableArray *arrayC = [@[@1] mutableCopy]; [set addObject:arrayC]; NSLog(@&quot;set = %@&quot;, set); // Output: set = &#123;((1), (1,2)&#125; 正如大家所料，由于arayC与set里已有的对象不相等，所以现在set里有两个数组了:其中一个是最早加入的，另一个是刚才新添加的。最后，我们改变arrayC的内容，令其和最早加入set的那个数组相等： [arrayC add0bject:@2]; NSLog((@&quot;set = %@&quot;, set); // Output: set = &#123;((1, 2) , (1, 2)&#125; set中居然可以泡含两个彼此相等的数组！根据set的语义是不允许出现这种情况的，然而现在却无法保证这一点了， 因为我们修改了 set中已有的对象。若是拷贝此set，那就更糟糕了 : NSSet *setB = [set copy]; NSLog(@&quot;setB = %@&quot;, setB)；// Output: setB = &#123;((1,2))&#125; 把某对象放入 set 之后，就不要在修改该对象的内容了，如果非要改变就要注意其存在的隐患，并使用相应的应对方法处理可能发生的问题。 以类簇模式隐藏实现细节创建类簇：（工厂模式（Factory pattern）是创建类簇的方法之一）定义抽象基类，每个”实体子类”(concrete subclass)都从基类继承而来； 在既有类中使用关联对象存放自定义数据 所谓关联对象（Associated Object），就是给某些对象关联许多其他对象，这些对象通过”键”来区分。存储对象值得时候，可以指明”存储策略”(storage policy),用以维护相应的”内存管理语义”。 关联类型 等效的@property属性 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic,copy OBJC_ASSOCIATION_RETAIN retain OBJC_ASSOCIATION_COPY copy 下列方法可以管理关联对象： 1void objc_setAssociatedObject(id object,void *key,id value,objc_AssociationPolicy policy) 此方法以给指定的键和策略为某对象设置关联对象值。 1id objc_getAssociatedObject(id object,void *key) 此方法根据指定的键从某对象中获取对应的关联对象值。 1void objc_removeAssociatedObjects(id object) 此方法移除指定对象的全部关联对象。 ​ 我们可以把某对象想象成 NSDictionary，把关联到该对象的值理解为字典中的条目，于是，存取关联对象的值就相当于在 NSDictionary 对象上调用[object setObejct:value forKey:key] 与[object valueForKey:key]方法。然而，两者之间有个重要的差别：设置关联对象时用的键（key）是一个“不透明的指针”(opaque pointer)。 如果在两个键上调用” isEqual:”方法返回的是 YES，那么 NSDictionary 就认为二者相等；然而在设置关联对象的值时，若想令两个键匹配到同一个值，则二者必须是完全相同的指针才行。鉴于此，在设置关联对象的值时，通常使用静态的全局变量做键（key）。 Objective-C概述（二）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[忆南工]]></title>
      <url>%2F2016%2F11%2F23%2F%E5%BF%86%E5%8D%97%E5%B7%A5%2F</url>
      <content type="text"><![CDATA[忆南工 能记起刚来南工的时候，香樟林里的香樟轻轻地摇着叶子，如今，校园里已是满地的枫叶和银杏叶，风很大，但人心却很暖。 昔我往矣，杨柳依依，今我来思，雨雪霏霏。 雪使我们感受到生命的美丽和短暂，使我们感到尽管存在敌意，可是人与人之间是非常相似的，还使我们感到时空的广阔和人世的狭窄。所以雪下得越大，人与人之间的距离越小，它似乎盖住了敌意、急躁和愤怒，使人与人之间更加接近。 苍茫白雪间，群屋静立。即使正在下着雪，我们也要在我们的路上。不管过程和结果，看看陌生人群和风景，俘获一颗能装下喜欢雪的心，初雪，只有你最美。 愿初雪不渡我，恋者有来生。 查看原文，请点击 原文链接@南工]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TouchID 的集成开发说明]]></title>
      <url>%2F2016%2F11%2F21%2FTouchID-%E7%9A%84%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[说明：TouchID 指纹识别是iPhone 5s设备新增的一项重大功能，用于数据加密和安全。而在iOS8.0 以后也向第三方开放了相应功能API，我们可以利用这个API做相应的用户验证和登录的功能，省去输入密码的环节，提高登录的用户体验。 TouchID API官方文档:API官方文档仅在 iOS 8.0 之后支持 12345678canEvaluatePolicy:监测设备是否支持TouchID，返回BOOL，并且若不支持，则在NSError里面返回相应状态evaluatePolicy:TouchID验证状态，在Block里面返回验证状态BOOL和NSErroriOS 9.0以后，有更加严密的 TouchID 认证流程，方法如下：- (void)evaluateAccessControl:(SecAccessControlRef)accessControl operation:(LAAccessControlOperation)operation localizedReason:(NSString *)localizedReason reply:(void(^)(BOOL success, NSError * __nullable error))replyNS_AVAILABLE(10_11, 9_0) __WATCHOS_AVAILABLE(3.0) __TVOS_UNAVAILABLE; 逻辑流程设计：在设备第一次使用指纹登录之前，必须先登录原有的账号（app注册账号），进行设备（用户）绑定。 绑定TouchID举例说明： 1、开启指纹验证：在app登录后，比如：在“用户信息－安全”，点击开启“指纹登录”； 2、验证TouchID：检测当前设备是否支持TouchID，若支持则发起TouchID验证； 3、把账号/密码写入 KeyChain：TouchID验证通过后，根据当前已登录的账号和硬件设备Token，生成设备账号/密码（规则可自定，密码要长要复杂），并保存在keychain； 4、绑定：生成设备账号/密码后，将原账号及设备账号/密码，加密后发送到服务端进行绑定； 5、成功：验证原账号及设备账号有效后，返回相应状态，绑定成功则完成整个TouchID（设备）绑定流程。 使用已经绑定的TouchID登录： 在设备（用户）绑定之后，并且用户账号退出后，可以使用指纹登录，若当前设备未绑定，则不会出现“指纹登录” 按钮。 流程说明： 1、TouchID登录：绑定成功后，在用户登录界面，点击“指纹登录”； 2、验证TouchID：检测当前设备是否支持TouchID，若支持则发起TouchID验证； 3、验证登录：从 keychain 读取app在本机存储的设备账号/密码，调用 app 登录接口，发起登录请求； 4、成功：验证设备账号/密码后，返回相应状态，登录成功则完成整个TouchID登录流程。 需要导入LocalAuthentication.framework 特别注意：在使用的过程中，看清属性是在 iOS XX_0 几之后才支持才允许使用的，很多属性和特性都是随着机型的迭代而新增的；使用不当会崩溃哟。用TouchID进行验证登录，尤其涉及到安全和隐私问题，这方面，我们尤其要重视！！！ 几步关键性操作示例如下：验证本机是否支持 TouchID 12345678- (BOOL)isSupportTouchID&#123; //首先使用canEvaluatePolicy 判断设备支持状态 if ([self.context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:nil]) &#123; return YES; &#125; return NO;&#125; 支持,则将密码与 TouchID 进行绑定，并将密码写入 keychain.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- (void)contextBindingTouchIDWithBindString:(NSString *)bindString policy:(LAPolicy)policy complete:(LXBindingInfoCompleteBlock)complete&#123; if (![self isSupportTouchID]) &#123; complete(NO,nil,@&quot;设备不支持 TouchID&quot;); return; &#125; CFErrorRef error = NULL; // Should be the secret invalidated when passcode is removed? If not then use kSecAttrAccessibleWhenUnlocked SecAccessControlRef sacObject = SecAccessControlCreateWithFlags(kCFAllocatorDefault, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, kSecAccessControlTouchIDAny, &amp;error); if (sacObject == NULL || error != NULL) &#123; NSString *errorString = [NSString stringWithFormat:@&quot;SecItemAdd can&apos;t create sacObject: %@&quot;, error]; NSLog(@&quot;errorString : %@&quot;,errorString); complete(NO,(__bridge NSError *)(error),errorString); return; &#125; //默认iOS8.0的验证方式，验证通过，再绑定 /* LAPolicyDeviceOwnerAuthenticationWithBiometrics NS_ENUM_AVAILABLE(NA, 8_0) LAPolicyDeviceOwnerAuthentication NS_ENUM_AVAILABLE(10_11, 9_0) */ [self fingerprintAuthenticationPolicy:policy localizedFallbackTitle:@&quot;&quot; complete:^(BOOL isSuccess, NSError *error, LXLAError errorCode, NSString *errorReason) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (isSuccess) &#123; /* We want the operation to fail if there is an item which needs authentication so we will use `kSecUseNoAuthenticationUI`. */ NSData *secretTextData = [bindString dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary *attributes = @&#123; (id)kSecClass: (id)kSecClassGenericPassword, (id)kSecAttrService: [SCAppMonitor appName], (id)kSecValueData: secretTextData, (id)kSecUseAuthenticationUI: (id)kSecUseAuthenticationUIAllow, (id)kSecAttrAccessControl: (__bridge_transfer id)sacObject &#125;; OSStatus status = SecItemAdd((__bridge CFDictionaryRef)attributes, nil); NSString *message = [NSString stringWithFormat:@&quot;SecItemAdd status: %@&quot;, [self keychainErrorToString:status]]; NSLog(@&quot;message : %@&quot;,message); complete(YES,nil,@&quot;指纹验证成功&quot;); &#125; else&#123; complete(NO,nil,@&quot;指纹验证失败&quot;); &#125; &#125;); &#125;];&#125; 从 keychain 中查询与 TouchID 绑定的密码。123456789101112131415161718192021222324- (void)queryInfoFromKeyChain:(LXQueryBindInfoCompleteBlock)complete&#123; NSDictionary *query = @&#123; (id)kSecClass: (id)kSecClassGenericPassword, (id)kSecAttrService: [SCAppMonitor appName], (id)kSecReturnData: @YES, (id)kSecUseOperationPrompt: @&quot;Authenticate to access service password&quot;, &#125;; dispatch_async(dispatch_get_main_queue(), ^&#123; NSString *message; CFTypeRef dataTypeRef = NULL; OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)(query), &amp;dataTypeRef); if (status == errSecSuccess) &#123; NSData *resultData = (__bridge_transfer NSData *)dataTypeRef; message = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding]; complete(YES,message,nil); &#125; else &#123; message = [NSString stringWithFormat:@&quot;SecItemCopyMatching status: %@&quot;, [self keychainErrorToString:status]]; complete(NO,nil,@&quot;指纹验证失败&quot;); &#125; &#125;);&#125; 指纹识别概念阐述]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[站在岁月之巅放牧心灵]]></title>
      <url>%2F2016%2F11%2F18%2F%E7%AB%99%E5%9C%A8%E5%B2%81%E6%9C%88%E4%B9%8B%E5%B7%85%E6%94%BE%E7%89%A7%E5%BF%83%E7%81%B5%2F</url>
      <content type="text"><![CDATA[生命，是一树花开， 或安静或热烈，或寂寞或璀璨。 — 日子，在岁月的年轮中渐次厚重，那些天真的、跃动的、抑或沉思的灵魂，在繁华与喧嚣中，被刻上深深浅浅、或浓或淡的印痕。 很欣赏这样一句话：生命，是一场虚妄。其实，经年过往，每个人何尝不是在这场虚妄里跋涉?在真实的笑里哭着，在真实的哭里笑着，一笺烟雨，半帘幽梦，许多时候，我们不得不承认：生活，不是不寂寞，只是不想说。 于无声处倾听凡尘落素，渐渐明白：人生，总会有许多无奈，希望、失望、憧憬、彷徨，苦过了，才知甜蜜;痛过了，才懂坚强;傻过了，才会成长。生命中，总有一些令人唏嘘的空白，有些人，让你牵挂，却不能相守;有些东西，让你羡慕，却不能拥有;有些错过，让你留恋，却终生遗憾。 在这喧闹的凡尘，我们需要有适合自己的地方，用来安放灵魂。也许，是一座安静宅院;也许，是一本无字经书;也许，是一条迷津小路。只要是自己心之所往，便是驿站，为了将来起程时，不再那么迷惘。 红尘三千丈，念在山水间。生活，不总是一帆风顺。因为爱，所以放手;因为放手，所以沉默;因为一份懂得，所以安心着一个回眸。也许，有风有雨的日子，才承载了生命的厚重;风轻云淡的日子，更适于静静领悟。 深深懂得：这世界上，并不是所有的东西都符合想象。有些时候，山是水的故事，云是风的故事;有些时候，星不是夜的故事，情不是爱的故事。生命的旅途中，许多人走着、走着，就散了;许多事看着、看着，就淡了;许多梦做着、做着，就断了;许多泪流着、流着，就干了。人生，原本就是风尘中的沧海桑田，只是，回眸处，世态炎凉演绎成了苦辣酸甜。 喜欢那种淡到极致的美，不急不躁，不温不火，款步有声，舒缓有序;一弯浅笑，万千深情，尘烟几许，浅思淡行。于时光深处，静看花开花谢，虽历尽沧桑，仍含笑一腔温暖如初。其实，不是不深情，是曾经情太深;不是不懂爱，是爱过知酒浓。生活的阡陌中，没有人改变得了纵横交错的曾经，只是，在渐行渐远的回望里，那些痛过的、哭过的，都演绎成了坚强;那些不忍遗忘的、念念不忘的，都风干成了风景。 站在岁月之巅放牧心灵，山一程，水一程，红尘、沧桑、流年、清欢，一个人的夜晚，我们终于学会了：于一怀淡泊中，笑望两个人的白月光。 盈一抹领悟，收藏点点滴滴的快乐，经年流转，透过指尖的温度，期许岁月静好，这一路走来，你会发现，生活于我们，温暖，一直是一种牵引，不是吗?于生活的海洋中踏浪，云帆尽头，轻回眸，处处是别有洞天，云淡风轻。 有一种经年叫历尽沧桑，有一种远眺叫含泪微笑，有一种追求叫浅行静思，有一种美丽叫淡到极致。给生命一个微笑的理由吧，别让自己的心承载太多的负重;给自己一个取暖的方式吧，以风的执念求索，以莲的姿态恬淡，盈一抹微笑，将岁月打磨成人生枝头最美的风景。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仓央嘉措情诗]]></title>
      <url>%2F2016%2F11%2F16%2F%E4%BB%93%E5%A4%AE%E5%98%89%E6%8E%AA%E6%83%85%E8%AF%97%2F</url>
      <content type="text"><![CDATA[见与不见]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>%2F2016%2F11%2F16%2F%E5%85%B3%E4%BA%8E%E6%88%91%2F</url>
      <content type="text"><![CDATA[你一旦心有所向，自然会身之所往！You’ll walk when you has someplace to go!知乎@柴亚航微博@柴亚航简书@柴亚航“站在岁月之巅放牧心灵，山一程，水一程，红尘、沧桑、流年、清欢，一个人的夜晚，我们终于学会了：于一杯淡泊中，笑望两个人的白月光。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
