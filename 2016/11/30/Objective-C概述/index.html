<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Objective-C概述 | iOS Developer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学而不思则罔,思而不学则殆">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C概述">
<meta property="og:url" content="http://yoursite.com/2016/11/30/Objective-C概述/index.html">
<meta property="og:site_name" content="iOS Developer">
<meta property="og:description" content="学而不思则罔,思而不学则殆">
<meta property="og:image" content="https://ww4.sinaimg.cn/large/006tNc79jw1fb7yh6bdppj31kw1cuwhm.jpg">
<meta property="og:updated_time" content="2016-12-29T12:59:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C概述">
<meta name="twitter:description" content="学而不思则罔,思而不学则殆">
<meta name="twitter:image" content="https://ww4.sinaimg.cn/large/006tNc79jw1fb7yh6bdppj31kw1cuwhm.jpg">
  
    <link rel="alternate" href="/atom.xml" title="iOS Developer" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">iOS Developer</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hello World</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Objective-C概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/30/Objective-C概述/" class="article-date">
  <time datetime="2016-11-30T02:43:20.000Z" itemprop="datePublished">2016-11-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Objective-C概述
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Objective-C的起源"><a href="#Objective-C的起源" class="headerlink" title="Objective-C的起源"></a>Objective-C的起源</h3><blockquote>
<p>Objective-C与C++、Java、C#等面向对象的语言类似，不过很多方面有所差别。若是使用过一种面向对的开发语言，那么就能理解Objective-C所用的『范式和模板』了。然而，语法上会略显陌生，因为Objective-C使用的”消息结构”而非”函数调用”。Objective-C是由Smalltalk演化而来，后者是消息型语言的鼻祖。他们之间的调用看起来就是这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//Messaging （Objective-C）</div><div class="line">Object *obj = [Object new];</div><div class="line">[obj performWith:parameter1 and:parameter2];</div><div class="line"></div><div class="line">//Function calling (C++)</div><div class="line">Object *obj = [Object new];</div><div class="line">obj-&gt;perform(parameter1,parameter2);</div></pre></td></tr></table></figure>
<pre><code>关键的区别在于：使用消息结构的语言，其运行时所执行的代码是由运行时环境决定的；而使用函数调用的语言，则由编译器决定。如果上例代码中调用的函数是多态的，那么在运行时就要按照&quot;虚方法表&quot;(virture method table)来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。

Notes：virture method table是编程语言为实现&quot;动态派发&quot;（dynamic dispatch）或 &quot;运行时方法绑定&quot;（runtime method binding） 而采用的一种机制。
</code></pre><blockquote>
<p>“对象”(object)的内存在堆(heap space)上;<br>“指针”(pointer)的内存在栈（stack）上。</p>
</blockquote>
<h4 id="在类的头文件中尽量少引入其他头文件"><a href="#在类的头文件中尽量少引入其他头文件" class="headerlink" title="在类的头文件中尽量少引入其他头文件"></a>在类的头文件中尽量少引入其他头文件</h4><pre><code>可以使用@class 关键字&quot;向前声明&quot;（forward declaring） 该类。引入过多的并不需要的头文件，会增加编译时间，还会导致循环引用。使用『向前声明』可以解决互相引用的问题，减少编译时间，而且还能降低彼此的依赖程度（即我们经常说的降低耦合性）
</code></pre><h4 id="多用字面量语法（literal-syntax），少用与之等价的方法"><a href="#多用字面量语法（literal-syntax），少用与之等价的方法" class="headerlink" title="多用字面量语法（literal syntax），少用与之等价的方法"></a>多用字面量语法（literal syntax），少用与之等价的方法</h4><h5 id="字面数值"><a href="#字面数值" class="headerlink" title="字面数值"></a>字面数值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 字面数值 --&gt;</div><div class="line">NSNumber *someNumber = [NSNumber numberWithInt:1];</div><div class="line">等价于</div><div class="line">NSNumber *someNumber = @1;</div></pre></td></tr></table></figure>
<p> 字面量语法更加精简。能够以 NSNumber 实例表示的所有数据类型都可以使用这种表示方式。</p>
<h5 id="字面数组"><a href="#字面数组" class="headerlink" title="字面数组"></a>字面数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 字面量数组 --&gt;</div><div class="line">	 NSArray *array = [NSArray arrayWithObjects:@&quot;Hello&quot;,@&quot;World&quot;,nil];</div><div class="line">	 等价于</div><div class="line">	 NSArray *array = [@&quot;Hello&quot;,@&quot;World&quot;];</div><div class="line"></div><div class="line">	 对应的使用方法：(取下标操作subscripting)</div><div class="line">	 NSString *animal = [array objectAtIndex:0];</div><div class="line">	 等价于</div><div class="line">	 NSString *animal = array[0];</div></pre></td></tr></table></figure>
<h5 id="字面字典"><a href="#字面字典" class="headerlink" title="字面字典"></a>字面字典</h5><p>“字典”是一种映射型数据结构，可向其中添加键值对。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 字面量字典 --&gt;</div><div class="line">	 NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Hello&quot;:@&quot;H&quot;,@&quot;World&quot;:@&quot;W&quot;,[NSNumber numberWithInt:28]:@&quot;A&quot;,nil];</div><div class="line">	 等价于</div><div class="line">	 NSDictionary *dictionary = @&#123;@&quot;H&quot;:@&quot;Hello&quot;,@&quot;W&quot;:@&quot;World&quot;,@&quot;A&quot;:@28&#125;;</div><div class="line">	</div><div class="line">	 对应的使用方法：</div><div class="line">	 NSString *animal = [dictionary  valueForKey:@&quot;H&quot;];</div><div class="line">	 等价于</div><div class="line">	 NSString *animal = dictionary[@&quot;H&quot;];</div></pre></td></tr></table></figure></p>
<pre><code>使用字面量语法的局限性：
1、除了字符串以外，创建出来的对象必须是 Foundation 框架下的才行。
2、定义了这些可行的子类话，则无法继续使用字面量语法创建对象。
3、使用字面量创建出来的字符串、数组、字典对象都是不可变的（immutable），若要可变，需要调用 mutableCopy。比如：NSMutableDictionary *mutable = [@{@&quot;H&quot;:@&quot;Hello&quot;,@&quot;W&quot;:@&quot;World&quot;,@&quot;A&quot;:@28} mutableCopy]

使用字面量语法的好处：
1、可以缩减代码的长度 使其更加易读
2、使用字面量语法更加安全
3、字面量语法实际上只是一种[&quot;语法糖&quot;syntactic sugar](http://zh.wikipedia.org/wiki/语法糖)
4、使用字面量语法创建数组或字典时，值中不能有 nil 对象，否则抛出异常。其实这样，更便于查错。纠错。
</code></pre><h4 id="多用类型常量，少用『-define』-预处理指令"><a href="#多用类型常量，少用『-define』-预处理指令" class="headerlink" title="多用类型常量，少用『#define』 预处理指令"></a>多用类型常量，少用『#define』 预处理指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#define ANIMATION_DURATION 0.3 //没有类型信息</div><div class="line"></div><div class="line">与</div><div class="line"></div><div class="line">static const NSTimeInterval KAnimationDuration = 0.3; //包含类型信息</div><div class="line"></div><div class="line">//变量名已定要同时使用 const 和 static 来声明。</div><div class="line">//其实这些都是一些命名规范，后边细述。</div></pre></td></tr></table></figure>
<pre><code>有时候需要公开某个常量。比如，你可能会给代码块中某个 Event 发送通知（NSNotification）。派发通知时需要使用字符串来表示此项通知的名称，而这个名字就可以为一个外界可见的常值变量（constant variable）。这样的话，注册者无需知道实际字符串的值，只需要以常值变量来注册自己想要接收到的通知即可。此类常量需放在&quot;全局符号表&quot;（global symbol table）中，以便可以再定义该常量的编译单元之外使用。和上边的 static const 有所不同：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//In the header file</div><div class="line">extern NSString *const SCStringRefreshNotification; //常量指针</div><div class="line"></div><div class="line">//In the implementation file</div><div class="line">NSString *const SCStringRefreshNotification = @&quot;SCStringRefreshNotification&quot;;</div><div class="line"></div><div class="line">//点 h 文件声明，点 m 文件定义</div></pre></td></tr></table></figure>
<p>总之，不要使用预处理指令定义常量。这样定义出来的常量不仅不包含类型信息，而且有人修改了（或重新定义了）这个常量值编译器也不会产生警告⚠️信息。<br>​<br>在实现文件使用 static const 来定义”只在编译单元内可见的变量”(translation-unit-specific constant)。这类常量不会出现在全局符号表中，所以无需为其名称加前缀。</p>
<p>在头文件使用 extern 来声明全局常量，并在实现文件中定义其值。这类常量会出现在全局符号表中，所以通常用与之相关的类名做前缀。</p>
<h4 id="用枚举表示状态、选项、状态吗"><a href="#用枚举表示状态、选项、状态吗" class="headerlink" title="用枚举表示状态、选项、状态吗"></a>用枚举表示状态、选项、状态吗</h4><p>一个字节含8个二进制位，所以至多能表示可取256种（2^8个）枚举（编号为0~255）的枚举变量。</p>
<p>我们总习惯在 switch 语句中加上 default 分支。然而，若是用枚举来定义状态机（state machine），最好不要有 default 分支。这样的话，如果稍后新加上一个枚举状态，那么编译器会发出警告信息，提示新加入的状态并未在 switch 分支中处理。假如写上了 default 分支，那么他就会处理这个新状态，从而导致编译器不发警告信息。用 NS_ENUM 定义其他枚举类型时候也要注意此问题。</p>
<p>1、应该使用枚举来表示状态机的状态，传递给方法的选项以及状态码等值，给这些起个易懂的名字。<br>2、如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。<br>3、用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样的做就可以确保枚举是开发者所选择的底层数据类型实现出来，而不是采用编译器所选用的类型。<br>4、在处理枚举类型的 switch 语句中不要实现 default 分支。</p>
<h3 id="对象、消息、运行期"><a href="#对象、消息、运行期" class="headerlink" title="对象、消息、运行期"></a>对象、消息、运行期</h3><blockquote>
<p>用 Objective-C 等面向对象语言编程时，对象（object）就是”基本构造单元”(building block),开发者可以通过对象存储并传递数据。</p>
<p>在对象之间传递数据并执行任务的过程就叫做”消息传递”(Messaging)。</p>
</blockquote>
<p>Notes： 如果你熟悉了『对象』和『消息传递』这两个特性的工作原理，就可以写出高效且易维护的代码。</p>
<blockquote>
<p>当 App 运行起来后，为其提供相关支持的代码叫做”Objective-C运行期环境”（Objective-C runtime）.runtime提供了一些是的对象之间能够传递消息的重要函数。</p>
<p> 熟悉几个术语：存取方法（access method）、点语法（dot syntax）、编译器（compile time）、偏移量（offset）、硬编码（hardcode）、不兼容对象（incompatibility）、特殊变量（special variable）、类对象（class object）、应用程序二进制接口（Application Binary Interface，ABI）、稳固的（nonfragile）</p>
<p>在对象接口的定义中，可以使用属性，这是一种标准的写法，能够访问封装在对象的数据。因此，也可以把属性当做一种简称，其意思就是说：编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。</p>
<p>使用点语法和直接调用存取方法之间没有丝毫差别。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SCPerson *person= [SCPerson new];</div><div class="line">person.firstName = @&quot;CYH&quot;;</div><div class="line">Same As:</div><div class="line">[person setFirstName:@&quot;CYH&quot;];</div><div class="line"></div><div class="line">NSString *name = person.firstName;</div><div class="line">Same As:</div><div class="line">NSString *name = [person firstName];</div></pre></td></tr></table></figure>
<p> 属性拥有的特质分为四类：</p>
<h5 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h5><p> 在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性（atomicity）。如果属性具备 nonatomic特质，则不使用同步锁。请注意，如果某属性不具备 nonatomic特质那它就是原子的 atomic。</p>
<h5 id="读-写权限："><a href="#读-写权限：" class="headerlink" title="读/写权限："></a>读/写权限：</h5><blockquote>
<p>1、具备 readwrite 特质的属性拥有 getter 和 setter 方法。</p>
<p>2、具备 readonly 特质属性只有 getter 方法。</p>
</blockquote>
<h5 id="内存管理语义："><a href="#内存管理语义：" class="headerlink" title="内存管理语义："></a>内存管理语义：</h5><p> 属性用于封装数据，而数据必须要有”具体的所有权语义”（concrete ownership semantic）。</p>
<blockquote>
<p>assign: setter 方法只会执行针对”纯量类型”（scalar type,e.g:CGFloat和 NSInteger）的简单赋值操作</p>
<p>strong: 定义了一种拥有关系（ownership relationship）。为这种属性设置新值时，setter 方法会先保留新值，并释放旧值，然后再将新值设置上去。</p>
<p>weak: 定义了一种非拥有关系（nonowning relationship）。为这种属性设置新值时，setter 方法既不保留新值，也不释放旧值。此特质同 assign 类似，然而在属性特指的对象遭到摧毁时，属性值会清空（nil out）</p>
<p>unsafe_unretained:  此特质的语义和 assign 相同，但是它适用于对象类型（object type），该特质表达一种非拥有关系（不保留，unretained），当目标对象遭到摧毁时，属性值不会清空（不安全，unsafe），这一点与 weak 有区别。</p>
<p>copy: 此特质所述的关系和 strong 类似，然而设置方法并不保留新值，而是将其复制 （copy）。当熟悉类型是 NSString* 时候，经常用此特质来保护其封装性。因为传递给 setter 方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可以修改其值的字符串，此时若不拷贝字符串，那么设置完属性之后，字符串的值可能会在对象不知情的情况下遭人更改。所以，就要拷贝一份不可变的字符串，确保对象中的字符串不会无意简变动。只要实现属性所用的对象是可变的，就应该在设置新属性值时拷贝一份。</p>
</blockquote>
<h5 id="方法名："><a href="#方法名：" class="headerlink" title="方法名："></a>方法名：</h5><p>可以通过 getter=<name> 和 setter=<name> 指定存取方法的方法名</name></name></p>
<p>注释：不应该在 init （或 dealloc） 方法中调用存取方法。</p>
<h4 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h4><p>1、在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写<br>2、在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据<br>3、有时会使用惰性初始化技术配置某分数据，这种情况下，需要通过属性来读取数据。</p>
<h4 id="理解”对象等同性”这一概念"><a href="#理解”对象等同性”这一概念" class="headerlink" title="理解”对象等同性”这一概念"></a>理解”对象等同性”这一概念</h4><blockquote>
<p>根据”等同性”(equality)来比较对象是一个非常有用的功能。不过，按照==操作符比较出来的结果未必是我们想要的，因为该操作比较的是两个指针本身，而不是其所指的对象。应该使用NSObject协议中声明的”isEqual:”方法来判断两个对象的等同性。一般来说，两个类型不同的对象总是不相等的(unequal)。某些对象提供了特殊的”等同性判定方法”(equality-checking method),如果已经知道两个受测对象都属干同一个类，那么就可以使用这种方法。以下述代码为例： </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSString *foo = @&quot;Badge:23&quot;; </div><div class="line">NSString *bar = [NSString stringWithFormat: @&quot;Badge:%i&quot;, 123]; </div><div class="line">BOOL equalA = (foo == bar); //&lt; equalA = NO </div><div class="line">BOOL equalB = [foo isEqual:bar]; //&lt; equalB = YES </div><div class="line">BOOL equalC = [foo isEqualToString:bar]; //&lt; equalC = YES</div></pre></td></tr></table></figure>
<blockquote>
<p>大家可以看到==与等同性判断方法之间的差别。NSString类实现了一个自己独有的同性判断方法，名叫” isEqualToString:”。传递给该方法的对象必须是NSString， 否则结果未定义(undefined).调用该方法比调用”isEqual:”方法快，后者还要执行额外的步骤，因为他不知道受测对象的类型。</p>
</blockquote>
<p>NSObject协议中有两个用于判断等同性的关键方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqual:(id)object; </div><div class="line">- (NSUInteger)hash;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>NSObject类对这两个方法的默认实现是：当且仅当其”指针值” (pointer value)完全相等时，这两个对象才相等。若想在自定义的对象中正确覆写这些方法，就必须先理解其约定(contract)。 如果 “ isEqual:” 方法判定两个对象相等，那么其hash方法也必须返回同一个值。但是，如果两个对象的hash方法返回同一个值，那么”isEqual:”方法未必会认为两者相等。<br>比如有下面这个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface SCPerson : NSObject </div><div class="line">@property (nonatomic, copy) NSString *firstName; </div><div class="line">@property (nonatomic, copy) NSString *lastName; </div><div class="line">@property (nonatomic, assign) NSUInteger age; </div><div class="line">@ end</div></pre></td></tr></table></figure></p>
</blockquote>
<p>我们认为，如果两个SCPerson的所有字段均相等，那么这西个对象就相等。于是<br>isEqual:”方法可以写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (Bool） isEqual: (id) object &#123;</div><div class="line">//指针类型的比较</div><div class="line">if (self == object) return YES;  </div><div class="line">if ([self class] != [object class]) return NO;</div><div class="line"></div><div class="line">//对象类型的比较</div><div class="line">SCPerson *otherPerson = (SCPerson*)object; </div><div class="line">if (![ firstName isEqualToString:otherPerson.firstName]) return NO; </div><div class="line">if (![_lastName isEqualToString:otherPerson.lastName]) return NO; </div><div class="line">if (_age != otherPerson.age) return NO; </div><div class="line">return YES; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>首先，直接判断两个指针是否相等。若相等，则其均指向同一对象，所以受测的对象也必定相等。接下来，比较西对象所属的类。若不属于同一个类，则两对象不相等。SCPerson对象当然不可能与SCDog对象相等。不过，有时我们可能认为：一个SCPerson实例可以与其子类（比如SCFanBingBingPerson)实例相等。在继承体系（inheritance hierarchy)中判断等同性时，经常遭遇此类问题。所以实现” isEqual:”方法时要考虑到这种情况.最后，检测每个属性是否相等。只要其中有不相等的属性，就判定两对象不等，否则两对象相等。</p>
<p>Hash 方法，根据等同性约定：若两对象相等，则其哈希码也相等，但是两个哈希码相同的对象却未必相等。这也是能否正确重写”isEqual:”方法的关键所在。编写 hash 方法时，应该用当前对象做做实验，以便在减少碰撞频度与降低运算复杂程度之间取舍。</p>
</blockquote>
<p>特定类具有特定的等同性判定方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString 			isEqualToString:</div><div class="line">NSArray 			isEqualToArray:</div><div class="line">NSDictionary 		isEqualToDictionary:</div></pre></td></tr></table></figure></p>
<p>常用的还有NSURL类的对比方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isEqualToURL:(NSURL *)aURL</div><div class="line">  &#123;</div><div class="line">    if ([self isEqual:aURL]) return YES;</div><div class="line">    if ([[self scheme] caseInsensitiveCompare:[aURL scheme]] != NSOrderedSame) return NO;</div><div class="line">    if ([[self host] caseInsensitiveCompare:[aURL host]] != NSOrderedSame) return NO;</div><div class="line"></div><div class="line">    // NSURL path is smart about trimming trailing slashes</div><div class="line">    // note case-sensitivty here</div><div class="line">    if ([[self path] compare:[aURL path]] != NSOrderedSame) return NO;</div><div class="line"></div><div class="line">    // at this point, we&apos;ve established that the urls are equivalent according to the rfc</div><div class="line">    // insofar as scheme, host, and paths match</div><div class="line"></div><div class="line">    // according to rfc2616, port&apos;s can weakly match if one is missing and the</div><div class="line">    // other is default for the scheme, but for now, let&apos;s insist on an explicit match</div><div class="line">    if ([[self port] compare:[aURL port]] != NSOrderedSame) return NO;</div><div class="line"></div><div class="line">    if ([[self query] compare:[aURL query]] != NSOrderedSame) return NO;</div><div class="line"></div><div class="line">    // for things like user/pw, fragment, etc., seems sensible to be</div><div class="line">    // permissive about these.  (plus, I&apos;m tired :-))</div><div class="line">    return YES;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>警告⚠️:由于 Objective-C在编译期不做强类型检查（strong type checking）,这样容易不小心传入类型错误的对象，因此开发者应该保证所传对象的类型是正确的。</p>
<p>在编写判定方法时，应该一并 override “isEqual:”方法，目的是：如果受测类型的参数与接收该消息的对象属于同一个类，那么就调用自己写的判定方法，否则就交给超类判断。</p>
<p>创建等同性判定方法时，需要决定是根据整个对象来判定等同性，还是仅根据其中几个字段来判断。</p>
<p>用一个 NSMutableSet 与几个 NSMutableArray 对象测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">先把一个数组加入set中： </div><div class="line">NSMutableSet *set = [NSMutableSet new]; </div><div class="line">NSMutableArray *arrayA = [@[@1, @2] mutableCopy]; </div><div class="line">[set addObject:arrayA]; </div><div class="line">NSLog(@&quot;set = %@&quot;, set); </div><div class="line">// Output: set = &#123;((1,2))&#125;</div></pre></td></tr></table></figure></p>
<p>现在set里含有一个数组对象，数组中包含两个对象。再向set中加入一个数组，此数结<br>与前一个数组所含的对象相同，顺序也相同，于是，待加入的数组与set中已有的数组是相<br>等的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *arrayB = [@[@1, @2] mutableCopy]; </div><div class="line">[set addObject:arrayB];</div><div class="line">NSLog(@&quot;set = %@&quot;, set); </div><div class="line">// Output: set = &#123;((1,2))&#125;</div></pre></td></tr></table></figure></p>
<p>此时set里仍然只有一个对象：因为刚才要加人的那个数组对象和set中已有的数组对象相等，所以set并不会改变。这次我们来添加一个和set中已有对象不同的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *arrayC = [@[@1] mutableCopy]; </div><div class="line">[set addObject:arrayC]; </div><div class="line">NSLog(@&quot;set = %@&quot;, set); </div><div class="line">// Output: set = &#123;((1), (1,2)&#125; </div><div class="line"></div><div class="line">正如大家所料，由于arayC与set里已有的对象不相等，所以现在set里有两个数组了:其中一个是最早加入的，另一个是刚才新添加的。最后，我们改变arrayC的内容，令其和最早加入set的那个数组相等： </div><div class="line">[arrayC add0bject:@2]; </div><div class="line">NSLog((@&quot;set = %@&quot;, set); </div><div class="line">// Output: set = &#123;((1, 2) , (1, 2)&#125; </div><div class="line">set中居然可以泡含两个彼此相等的数组！根据set的语义是不允许出现这种情况的，然而现在却无法保证这一点了， 因为我们修改了 set中已有的对象。若是拷贝此set，那就更糟糕了 : </div><div class="line">NSSet *setB = [set copy]; </div><div class="line">NSLog(@&quot;setB = %@&quot;, setB)；</div><div class="line">// Output: setB = &#123;((1,2))&#125;</div></pre></td></tr></table></figure></p>
<p>把某对象放入 set 之后，就不要在修改该对象的内容了，如果非要改变就要注意其存在的隐患，并使用相应的应对方法处理可能发生的问题。</p>
<h4 id="以类簇模式隐藏实现细节"><a href="#以类簇模式隐藏实现细节" class="headerlink" title="以类簇模式隐藏实现细节"></a>以类簇模式隐藏实现细节</h4><p>创建类簇：（工厂模式（Factory pattern）是创建类簇的方法之一）<br>定义抽象基类，每个”实体子类”(concrete subclass)都从基类继承而来；</p>
<h4 id="在既有类中使用关联对象存放自定义数据"><a href="#在既有类中使用关联对象存放自定义数据" class="headerlink" title="在既有类中使用关联对象存放自定义数据"></a>在既有类中使用关联对象存放自定义数据</h4><p> 所谓关联对象（Associated Object），就是给某些对象关联许多其他对象，这些对象通过”键”来区分。存储对象值得时候，可以指明”存储策略”(storage policy),用以维护相应的”内存管理语义”。</p>
<table>
<thead>
<tr>
<th style="text-align:center">关联类型</th>
<th style="text-align:center">等效的@property属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_ASSIGN</td>
<td style="text-align:center">assign</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td style="text-align:center">nonatomic,retain</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td style="text-align:center">nonatomic,copy</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_RETAIN</td>
<td style="text-align:center">retain</td>
</tr>
<tr>
<td style="text-align:center">OBJC_ASSOCIATION_COPY</td>
<td style="text-align:center">copy</td>
</tr>
</tbody>
</table>
<p>下列方法可以管理关联对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_setAssociatedObject(id object,void *key,id value,objc_AssociationPolicy policy)</div></pre></td></tr></table></figure>
<p>此方法以给指定的键和策略为某对象设置关联对象值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_getAssociatedObject(id object,void *key)</div></pre></td></tr></table></figure>
<p>此方法根据指定的键从某对象中获取对应的关联对象值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void objc_removeAssociatedObjects(id object)</div></pre></td></tr></table></figure>
<p>此方法移除指定对象的全部关联对象。</p>
<p>​    我们可以把某对象想象成 NSDictionary，把关联到该对象的值理解为字典中的条目，于是，存取关联对象的值就相当于在 NSDictionary 对象上调用[object setObejct:value forKey:key] 与[object valueForKey:key]方法。然而，两者之间有个重要的差别：设置关联对象时用的键（key）是一个<a href="http://en.wikipedia.org/wiki/Opaque_pointer" target="_blank" rel="external">“不透明的指针”(opaque pointer)</a>。 如果在两个键上调用” isEqual:”方法返回的是 YES，那么 NSDictionary 就认为二者相等；然而在设置关联对象的值时，若想令两个键匹配到同一个值，则二者必须是完全相同的指针才行。<strong>鉴于此，在设置关联对象的值时，通常使用静态的全局变量做键（key）。</strong></p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79jw1fb7yh6bdppj31kw1cuwhm.jpg" alt=""></p>
<p><a href="http://blog.chaiyahang.com/2016/12/27/Objective-C概述（二）/" target="_blank" rel="external">Objective-C概述（二）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/30/Objective-C概述/" data-id="cj46tfgxg000vo3s6wak3pkho" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/12/02/系统原生请求表单上传/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          系统原生请求表单上传
        
      </div>
    </a>
  
  
    <a href="/2016/11/23/忆南工/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">忆南工</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">ios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/图片/">图片</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小说/">小说</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率/">效率</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/文字/">文字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/网络/iOS/">iOS</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Authentication/">Authentication</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CGRect/">CGRect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NSURLRequest/">NSURLRequest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TouchID/">TouchID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/下载插件/">下载插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/不甘示弱/">不甘示弱</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/仓央嘉措/">仓央嘉措</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/偈子/">偈子</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/南工/">南工</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/历史/">历史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/屏蔽广告/">屏蔽广告</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/悔恨/">悔恨</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/我的母校/">我的母校</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/执子之手，共你一世风霜/">执子之手，共你一世风霜</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文史/">文史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文字/">文字</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文学/">文学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/梦溪湖/">梦溪湖</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/湘西王/">湘西王</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生命/">生命</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网页歌曲/">网页歌曲</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网页视频/">网页视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/表单上传/">表单上传</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/西原/">西原</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/见或不见/">见或不见</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/认真的雪/">认真的雪</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/陈渠珍/">陈渠珍</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Authentication/" style="font-size: 10px;">Authentication</a> <a href="/tags/CGRect/" style="font-size: 10px;">CGRect</a> <a href="/tags/NSURLRequest/" style="font-size: 10px;">NSURLRequest</a> <a href="/tags/Objective-C/" style="font-size: 13.33px;">Objective-C</a> <a href="/tags/TouchID/" style="font-size: 10px;">TouchID</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/下载插件/" style="font-size: 10px;">下载插件</a> <a href="/tags/不甘示弱/" style="font-size: 10px;">不甘示弱</a> <a href="/tags/仓央嘉措/" style="font-size: 10px;">仓央嘉措</a> <a href="/tags/偈子/" style="font-size: 10px;">偈子</a> <a href="/tags/南工/" style="font-size: 10px;">南工</a> <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/屏蔽广告/" style="font-size: 10px;">屏蔽广告</a> <a href="/tags/工具/" style="font-size: 16.67px;">工具</a> <a href="/tags/悔恨/" style="font-size: 10px;">悔恨</a> <a href="/tags/我的母校/" style="font-size: 10px;">我的母校</a> <a href="/tags/执子之手，共你一世风霜/" style="font-size: 10px;">执子之手，共你一世风霜</a> <a href="/tags/文史/" style="font-size: 10px;">文史</a> <a href="/tags/文字/" style="font-size: 16.67px;">文字</a> <a href="/tags/文学/" style="font-size: 10px;">文学</a> <a href="/tags/梦溪湖/" style="font-size: 10px;">梦溪湖</a> <a href="/tags/湘西王/" style="font-size: 10px;">湘西王</a> <a href="/tags/生命/" style="font-size: 10px;">生命</a> <a href="/tags/网页歌曲/" style="font-size: 10px;">网页歌曲</a> <a href="/tags/网页视频/" style="font-size: 10px;">网页视频</a> <a href="/tags/表单上传/" style="font-size: 10px;">表单上传</a> <a href="/tags/西原/" style="font-size: 10px;">西原</a> <a href="/tags/见或不见/" style="font-size: 10px;">见或不见</a> <a href="/tags/认真的雪/" style="font-size: 10px;">认真的雪</a> <a href="/tags/陈渠珍/" style="font-size: 10px;">陈渠珍</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/25/iOS推送机制/">iOS推送机制</a>
          </li>
        
          <li>
            <a href="/2017/03/21/ios应用程序的生命周期/"> ios应用程序的生命周期</a>
          </li>
        
          <li>
            <a href="/2017/03/20/OC内存管理/">OC内存管理</a>
          </li>
        
          <li>
            <a href="/2017/03/19/3·15晚会/">3·15晚会</a>
          </li>
        
          <li>
            <a href="/2017/03/17/NSString属性什么时候用copy，什么时候用strong/">NSString属性什么时候用copy，什么时候用strong?</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 柴亚航<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>